; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\uart.o --depend=.\Obj\uart.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\Inc -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\NXP\LPC11Uxx -D__MICROLIB -D__DEBUG_FLASH --omf_browse=.\Obj\uart.crf Src\uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  UART_IRQHandler PROC
;;;35     *****************************************************************************/
;;;36     void UART_IRQHandler(void)
000000  b530              PUSH     {r4,r5,lr}
;;;37     {
;;;38     	U8 IIRValue, LSRValue,Dummy;
;;;39     
;;;40     	IIRValue = LPC_USART->IIR;
000002  4baf              LDR      r3,|L1.704|
000004  689b              LDR      r3,[r3,#8]
000006  b2d8              UXTB     r0,r3
;;;41     
;;;42     	IIRValue >>= 1;/* skip pending bit in IIR */
000008  1040              ASRS     r0,r0,#1
;;;43     	IIRValue &= 0x07;/* check bit 1~3, interrupt identification */
00000a  0740              LSLS     r0,r0,#29
00000c  0f40              LSRS     r0,r0,#29
;;;44       
;;;45     	switch(IIRValue)
00000e  2801              CMP      r0,#1
000010  d05f              BEQ      |L1.210|
000012  2802              CMP      r0,#2
000014  d036              BEQ      |L1.132|
000016  2803              CMP      r0,#3
000018  d002              BEQ      |L1.32|
00001a  2806              CMP      r0,#6
00001c  d169              BNE      |L1.242|
00001e  e050              B        |L1.194|
                  |L1.32|
;;;46     	{
;;;47     		case  IIR_RLS:/* Receive Line Status */	
;;;48     		LSRValue = LPC_USART->LSR;
000020  4ba7              LDR      r3,|L1.704|
000022  695b              LDR      r3,[r3,#0x14]
000024  b2d9              UXTB     r1,r3
;;;49     		/* Receive Line Status */
;;;50     		if(LSRValue & (LSR_OE | LSR_PE | LSR_FE | LSR_RXFE | LSR_BI))
000026  239e              MOVS     r3,#0x9e
000028  4219              TST      r1,r3
00002a  d005              BEQ      |L1.56|
;;;51     		{
;;;52     			/* There are errors or break interrupt */
;;;53     			/* Read LSR will clear the interrupt */
;;;54     			g_Uart_Setting.UartStatus = LSRValue;
00002c  4ba5              LDR      r3,|L1.708|
00002e  6019              STR      r1,[r3,#0]  ; g_Uart_Setting
;;;55     			Dummy = LPC_USART->RBR;	/* Dummy read on RX to clear 
000030  4ba3              LDR      r3,|L1.704|
000032  681b              LDR      r3,[r3,#0]
000034  b2da              UXTB     r2,r3
;;;56     			interrupt, then bail out */
;;;57     			break;
000036  e05c              B        |L1.242|
                  |L1.56|
;;;58     		}
;;;59     		
;;;60     		if(LSRValue & LSR_RDR)	/* Receive Data Ready */			
000038  07cb              LSLS     r3,r1,#31
00003a  0fdb              LSRS     r3,r3,#31
00003c  d021              BEQ      |L1.130|
;;;61     		{
;;;62     			/* If no error on RLS, normal ready, save into the data buffer. */
;;;63     			/* Note: read RBR will clear the interrupt */
;;;64     			g_Uart_Setting.UartBuffer[g_Uart_Setting.UartCount] = LPC_USART->RBR;
00003e  4ba0              LDR      r3,|L1.704|
000040  681b              LDR      r3,[r3,#0]
000042  b2dc              UXTB     r4,r3
000044  4b9f              LDR      r3,|L1.708|
000046  7e1d              LDRB     r5,[r3,#0x18]  ; g_Uart_Setting
000048  1d1b              ADDS     r3,r3,#4
00004a  555c              STRB     r4,[r3,r5]
;;;65     			g_Uart_Setting.UartCount++;
00004c  1f1b              SUBS     r3,r3,#4
00004e  7e1b              LDRB     r3,[r3,#0x18]  ; g_Uart_Setting
000050  1c5b              ADDS     r3,r3,#1
000052  4c9c              LDR      r4,|L1.708|
000054  7623              STRB     r3,[r4,#0x18]
;;;66     
;;;67     			if (g_Uart_Setting.UartCount > UARTBUFSIZE)   
000056  4623              MOV      r3,r4
000058  7e1b              LDRB     r3,[r3,#0x18]  ; g_Uart_Setting
00005a  2b14              CMP      r3,#0x14
00005c  dd11              BLE      |L1.130|
;;;68     			{
;;;69     				g_Uart_Setting.UartCount = 0;/*buffer overflow*/
00005e  2300              MOVS     r3,#0
000060  7623              STRB     r3,[r4,#0x18]
;;;70     				g_Uart_Setting.UartStatus |= LSR_OE;
000062  4623              MOV      r3,r4
000064  681b              LDR      r3,[r3,#0]  ; g_Uart_Setting
000066  2402              MOVS     r4,#2
000068  4323              ORRS     r3,r3,r4
00006a  4c96              LDR      r4,|L1.708|
00006c  6023              STR      r3,[r4,#0]  ; g_Uart_Setting
;;;71     
;;;72     				for(Dummy = 0; Dummy < UARTBUFSIZE; Dummy++)
00006e  2200              MOVS     r2,#0
000070  e005              B        |L1.126|
                  |L1.114|
;;;73     				g_Uart_Setting.UartBuffer[Dummy] = 0xFF;	
000072  24ff              MOVS     r4,#0xff
000074  4b93              LDR      r3,|L1.708|
000076  1d1b              ADDS     r3,r3,#4
000078  549c              STRB     r4,[r3,r2]
00007a  1c53              ADDS     r3,r2,#1              ;72
00007c  b2da              UXTB     r2,r3                 ;72
                  |L1.126|
00007e  2a14              CMP      r2,#0x14              ;72
000080  dbf7              BLT      |L1.114|
                  |L1.130|
;;;74     			}			
;;;75     		}
;;;76     		break;
000082  e036              B        |L1.242|
                  |L1.132|
;;;77     	
;;;78     		case IIR_RDA:/* Receive Data Available */	
;;;79     		/* Receive Data Available */
;;;80     		g_Uart_Setting.UartBuffer[g_Uart_Setting.UartCount] = LPC_USART->RBR;
000084  4b8e              LDR      r3,|L1.704|
000086  681b              LDR      r3,[r3,#0]
000088  b2dc              UXTB     r4,r3
00008a  4b8e              LDR      r3,|L1.708|
00008c  7e1d              LDRB     r5,[r3,#0x18]  ; g_Uart_Setting
00008e  1d1b              ADDS     r3,r3,#4
000090  555c              STRB     r4,[r3,r5]
;;;81     		g_Uart_Setting.UartCount++;
000092  1f1b              SUBS     r3,r3,#4
000094  7e1b              LDRB     r3,[r3,#0x18]  ; g_Uart_Setting
000096  1c5b              ADDS     r3,r3,#1
000098  4c8a              LDR      r4,|L1.708|
00009a  7623              STRB     r3,[r4,#0x18]
;;;82     
;;;83     		if(g_Uart_Setting.UartCount > UARTBUFSIZE)   
00009c  4623              MOV      r3,r4
00009e  7e1b              LDRB     r3,[r3,#0x18]  ; g_Uart_Setting
0000a0  2b14              CMP      r3,#0x14
0000a2  dd0d              BLE      |L1.192|
;;;84     		{
;;;85     			g_Uart_Setting.UartCount = 0;/* buffer overflow */	
0000a4  2300              MOVS     r3,#0
0000a6  7623              STRB     r3,[r4,#0x18]
;;;86     			g_Uart_Setting.UartStatus = LSR_OE;
0000a8  2302              MOVS     r3,#2
0000aa  6023              STR      r3,[r4,#0]  ; g_Uart_Setting
;;;87     
;;;88     			for(Dummy = 0; Dummy< UARTBUFSIZE; Dummy++)
0000ac  2200              MOVS     r2,#0
0000ae  e005              B        |L1.188|
                  |L1.176|
;;;89     			g_Uart_Setting.UartBuffer[Dummy] = 0xFF;	
0000b0  24ff              MOVS     r4,#0xff
0000b2  4b84              LDR      r3,|L1.708|
0000b4  1d1b              ADDS     r3,r3,#4
0000b6  549c              STRB     r4,[r3,r2]
0000b8  1c53              ADDS     r3,r2,#1              ;88
0000ba  b2da              UXTB     r2,r3                 ;88
                  |L1.188|
0000bc  2a14              CMP      r2,#0x14              ;88
0000be  dbf7              BLT      |L1.176|
                  |L1.192|
;;;90     		}
;;;91     		break;
0000c0  e017              B        |L1.242|
                  |L1.194|
;;;92     	
;;;93     		case IIR_CTI:	/* Character timeout indicator */	
;;;94     		/* Character Time-out indicator */
;;;95     		g_Uart_Setting.UartStatus |= 0x100;/* Bit 9 as the CTI error */
0000c2  4b80              LDR      r3,|L1.708|
0000c4  681b              LDR      r3,[r3,#0]  ; g_Uart_Setting
0000c6  24ff              MOVS     r4,#0xff
0000c8  3401              ADDS     r4,#1
0000ca  4323              ORRS     r3,r3,r4
0000cc  4c7d              LDR      r4,|L1.708|
0000ce  6023              STR      r3,[r4,#0]  ; g_Uart_Setting
;;;96     		break;
0000d0  e00f              B        |L1.242|
                  |L1.210|
;;;97     	
;;;98     		case IIR_THRE:/* THRE, transmit holding register empty */	
;;;99     		/* THRE interrupt */
;;;100    		LSRValue = LPC_USART->LSR;/* Check status in the LSR to see if valid data in U0THR or not */
0000d2  4b7b              LDR      r3,|L1.704|
0000d4  695b              LDR      r3,[r3,#0x14]
0000d6  b2d9              UXTB     r1,r3
;;;101    
;;;102    		if(LSRValue & LSR_THRE)   
0000d8  2320              MOVS     r3,#0x20
0000da  4219              TST      r1,r3
0000dc  d002              BEQ      |L1.228|
;;;103    		g_Uart_Setting.UartStatus = LSR_THRE;	    
0000de  4c79              LDR      r4,|L1.708|
0000e0  6023              STR      r3,[r4,#0]  ; g_Uart_Setting
0000e2  e005              B        |L1.240|
                  |L1.228|
;;;104    		else   
;;;105    		g_Uart_Setting.UartStatus &= ~LSR_THRE;	 
0000e4  4b77              LDR      r3,|L1.708|
0000e6  681b              LDR      r3,[r3,#0]  ; g_Uart_Setting
0000e8  2420              MOVS     r4,#0x20
0000ea  43a3              BICS     r3,r3,r4
0000ec  4c75              LDR      r4,|L1.708|
0000ee  6023              STR      r3,[r4,#0]  ; g_Uart_Setting
                  |L1.240|
;;;106    		break;
0000f0  bf00              NOP      
                  |L1.242|
0000f2  bf00              NOP                            ;57
;;;107    	}
;;;108    }
0000f4  bd30              POP      {r4,r5,pc}
;;;109    
                          ENDP

                  nsAPI_UART_Init PROC
;;;119    *****************************************************************************/
;;;120    void nsAPI_UART_Init(U32 baudrate)
0000f6  b5f8              PUSH     {r3-r7,lr}
;;;121    {
0000f8  4604              MOV      r4,r0
;;;122    	U32 Fdiv,regVal;  
;;;123    
;;;124    	g_Uart_Setting.UartStatus = LSR_THRE;	
0000fa  2020              MOVS     r0,#0x20
0000fc  4971              LDR      r1,|L1.708|
0000fe  6008              STR      r0,[r1,#0]  ; g_Uart_Setting
;;;125    	g_Uart_Setting.UartCount = 0;
000100  2000              MOVS     r0,#0
000102  7608              STRB     r0,[r1,#0x18]
;;;126    
;;;127    	for(Fdiv = 0; Fdiv < UARTBUFSIZE; Fdiv++)
000104  2500              MOVS     r5,#0
000106  e004              B        |L1.274|
                  |L1.264|
;;;128    	g_Uart_Setting.UartBuffer[Fdiv] = 0xFF;	
000108  21ff              MOVS     r1,#0xff
00010a  486e              LDR      r0,|L1.708|
00010c  1d00              ADDS     r0,r0,#4
00010e  5541              STRB     r1,[r0,r5]
000110  1c6d              ADDS     r5,r5,#1              ;127
                  |L1.274|
000112  2d14              CMP      r5,#0x14              ;127
000114  d3f8              BCC      |L1.264|
;;;129    
;;;130    	NVIC_DisableIRQ(UART_IRQn);
000116  bf00              NOP      
000118  2115              MOVS     r1,#0x15
00011a  2001              MOVS     r0,#1
00011c  4088              LSLS     r0,r0,r1
00011e  496a              LDR      r1,|L1.712|
000120  6008              STR      r0,[r1,#0]
000122  bf00              NOP      
;;;131    	/* Select only one location from below. */
;;;132    
;;;133    	LPC_IOCON->PIO0_18 &= ~0x07;/*UART I/O config*/
000124  4869              LDR      r0,|L1.716|
000126  6880              LDR      r0,[r0,#8]
000128  08c0              LSRS     r0,r0,#3
00012a  00c0              LSLS     r0,r0,#3
00012c  4967              LDR      r1,|L1.716|
00012e  6088              STR      r0,[r1,#8]
;;;134    	LPC_IOCON->PIO0_18 |= 0x01;/*UART RXD*/
000130  4608              MOV      r0,r1
000132  6880              LDR      r0,[r0,#8]
000134  2101              MOVS     r1,#1
000136  4308              ORRS     r0,r0,r1
000138  4964              LDR      r1,|L1.716|
00013a  6088              STR      r0,[r1,#8]
;;;135    	LPC_IOCON->PIO0_19 &= ~0x07;	
00013c  4608              MOV      r0,r1
00013e  68c0              LDR      r0,[r0,#0xc]
000140  08c0              LSRS     r0,r0,#3
000142  00c0              LSLS     r0,r0,#3
000144  60c8              STR      r0,[r1,#0xc]
;;;136    	LPC_IOCON->PIO0_19 |= 0x01;/*UART TXD*/
000146  4608              MOV      r0,r1
000148  68c0              LDR      r0,[r0,#0xc]
00014a  2101              MOVS     r1,#1
00014c  4308              ORRS     r0,r0,r1
00014e  495f              LDR      r1,|L1.716|
000150  60c8              STR      r0,[r1,#0xc]
;;;137    
;;;138    	/* Enable UART clock */
;;;139    	LPC_SYSCON->SYSAHBCLKCTRL |= BIT12;
000152  485f              LDR      r0,|L1.720|
000154  6800              LDR      r0,[r0,#0]
000156  2101              MOVS     r1,#1
000158  0309              LSLS     r1,r1,#12
00015a  4308              ORRS     r0,r0,r1
00015c  495c              LDR      r1,|L1.720|
00015e  6008              STR      r0,[r1,#0]
;;;140    	LPC_SYSCON->UARTCLKDIV = BIT0;/* divided by 1 */
000160  2001              MOVS     r0,#1
000162  6188              STR      r0,[r1,#0x18]
;;;141    
;;;142    	LPC_USART->LCR = 0x83;/* 8 bits, no Parity, 1 Stop bit */
000164  2083              MOVS     r0,#0x83
000166  4956              LDR      r1,|L1.704|
000168  60c8              STR      r0,[r1,#0xc]
;;;143    	regVal = LPC_SYSCON->UARTCLKDIV;
00016a  4859              LDR      r0,|L1.720|
00016c  6986              LDR      r6,[r0,#0x18]
;;;144    	Fdiv = ((SystemCoreClock/regVal)/16)/baudrate;/*baud rate */
00016e  4631              MOV      r1,r6
000170  4858              LDR      r0,|L1.724|
000172  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000174  f7fffffe          BL       __aeabi_uidivmod
000178  0907              LSRS     r7,r0,#4
00017a  4621              MOV      r1,r4
00017c  4638              MOV      r0,r7
00017e  f7fffffe          BL       __aeabi_uidivmod
000182  4605              MOV      r5,r0
;;;145    
;;;146    	LPC_USART->DLM = Fdiv >> 8;							
000184  0a28              LSRS     r0,r5,#8
000186  494e              LDR      r1,|L1.704|
000188  6048              STR      r0,[r1,#4]
;;;147    	LPC_USART->DLL = Fdiv % 256;
00018a  b2e8              UXTB     r0,r5
00018c  6008              STR      r0,[r1,#0]
;;;148    	LPC_USART->LCR = 0x03;/* DLAB = 0 */
00018e  2003              MOVS     r0,#3
000190  60c8              STR      r0,[r1,#0xc]
;;;149    	LPC_USART->FCR = 0x07;/* Enable and reset TX and RX FIFO. */
000192  2007              MOVS     r0,#7
000194  6088              STR      r0,[r1,#8]
;;;150    
;;;151    	/* Read to clear the line status */
;;;152    	regVal = LPC_USART->LSR;
000196  4608              MOV      r0,r1
000198  6946              LDR      r6,[r0,#0x14]
;;;153    
;;;154    	/* Ensure a clean start, no data in either TX or RX FIFO. */
;;;155    	while(( LPC_USART->LSR & (LSR_THRE|LSR_TEMT)) != (LSR_THRE|LSR_TEMT)){}
00019a  bf00              NOP      
                  |L1.412|
00019c  4848              LDR      r0,|L1.704|
00019e  6940              LDR      r0,[r0,#0x14]
0001a0  2160              MOVS     r1,#0x60
0001a2  4008              ANDS     r0,r0,r1
0001a4  2860              CMP      r0,#0x60
0001a6  d1f9              BNE      |L1.412|
;;;156    	while(LPC_USART->LSR & LSR_RDR )
0001a8  e001              B        |L1.430|
                  |L1.426|
;;;157    	{
;;;158    		regVal = LPC_USART->RBR;	/* Dump data from RX FIFO */
0001aa  4845              LDR      r0,|L1.704|
0001ac  6806              LDR      r6,[r0,#0]
                  |L1.430|
0001ae  4844              LDR      r0,|L1.704|
0001b0  6940              LDR      r0,[r0,#0x14]         ;156
0001b2  07c0              LSLS     r0,r0,#31             ;156
0001b4  0fc0              LSRS     r0,r0,#31             ;156
0001b6  d1f8              BNE      |L1.426|
;;;159    	}
;;;160    
;;;161    	/* Enable the UART Interrupt */
;;;162    	NVIC_EnableIRQ(UART_IRQn);
0001b8  bf00              NOP      
0001ba  2115              MOVS     r1,#0x15
0001bc  2001              MOVS     r0,#1
0001be  4088              LSLS     r0,r0,r1
0001c0  4941              LDR      r1,|L1.712|
0001c2  3980              SUBS     r1,r1,#0x80
0001c4  6008              STR      r0,[r1,#0]
0001c6  bf00              NOP      
;;;163    
;;;164    #if TX_INTERRUPT
;;;165    	LPC_USART->IER = IER_RBR | IER_THRE | IER_RLS;/* Enable UART interrupt */
;;;166    #else
;;;167    	LPC_USART->IER = IER_RBR | IER_RLS;/* Enable UART interrupt */
0001c8  2005              MOVS     r0,#5
0001ca  493d              LDR      r1,|L1.704|
0001cc  6048              STR      r0,[r1,#4]
;;;168    #endif
;;;169    }
0001ce  bdf8              POP      {r3-r7,pc}
;;;170    
                          ENDP

                  nsAPI_UART_Send PROC
;;;180    *****************************************************************************/
;;;181    void nsAPI_UART_Send(U8 *BufferPtr, U32 Length)
0001d0  e00a              B        |L1.488|
                  |L1.466|
;;;182    {  
;;;183    	while(Length != 0)
;;;184    	{
;;;185    		/* THRE status, contain valid data */
;;;186    #if !TX_INTERRUPT
;;;187    		while(!(LPC_USART->LSR & LSR_THRE)){}
0001d2  bf00              NOP      
                  |L1.468|
0001d4  4a3a              LDR      r2,|L1.704|
0001d6  6952              LDR      r2,[r2,#0x14]
0001d8  2320              MOVS     r3,#0x20
0001da  421a              TST      r2,r3
0001dc  d0fa              BEQ      |L1.468|
;;;188    		LPC_USART->THR = *BufferPtr;
0001de  7802              LDRB     r2,[r0,#0]
0001e0  4b37              LDR      r3,|L1.704|
0001e2  601a              STR      r2,[r3,#0]
;;;189    #else
;;;190    		/* Below flag is set inside the interrupt handler when THRE occurs. */
;;;191    		while (!(g_Uart_Setting.UartStatus & LSR_THRE)){}
;;;192    		LPC_USART->THR = *BufferPtr;
;;;193    		g_Uart_Setting.UartStatus &= ~LSR_THRE; /* not empty in the THR until it shifts out */
;;;194    #endif
;;;195    		BufferPtr++;
0001e4  1c40              ADDS     r0,r0,#1
;;;196    		Length--;
0001e6  1e49              SUBS     r1,r1,#1
                  |L1.488|
0001e8  2900              CMP      r1,#0                 ;183
0001ea  d1f2              BNE      |L1.466|
;;;197    	}
;;;198    }
0001ec  4770              BX       lr
;;;199    
                          ENDP

                  xprintf PROC
;;;200    void xprintf(U8 *pFmt,U32 wVal,...)
0001ee  b5f0              PUSH     {r4-r7,lr}
;;;201    {
0001f0  b085              SUB      sp,sp,#0x14
0001f2  4604              MOV      r4,r0
0001f4  460d              MOV      r5,r1
;;;202    	U8 ucBff,ucDisp;
;;;203    	U8 bHex = FALSE,u8Into = 0,bNotZero = FALSE;   
0001f6  2700              MOVS     r7,#0
0001f8  2000              MOVS     r0,#0
0001fa  9002              STR      r0,[sp,#8]
0001fc  9001              STR      r0,[sp,#4]
;;;204    	U32 wDivider = 10000000;	
0001fe  4836              LDR      r0,|L1.728|
000200  9000              STR      r0,[sp,#0]
;;;205    
;;;206    
;;;207    	//LPC_USART->IER = IER_THRE | IER_RLS;/* Disable RBR */
;;;208    
;;;209    	while((ucBff =*(pFmt++)) > 0)
000202  e056              B        |L1.690|
                  |L1.516|
;;;210    	{	
;;;211    		if(ucBff == '%') // check special case
000204  466b              MOV      r3,sp
000206  7b18              LDRB     r0,[r3,#0xc]
000208  2825              CMP      r0,#0x25
00020a  d14e              BNE      |L1.682|
;;;212    		{
;;;213    			u8Into++;  		 
00020c  9802              LDR      r0,[sp,#8]
00020e  1c40              ADDS     r0,r0,#1
000210  b2c0              UXTB     r0,r0
000212  9002              STR      r0,[sp,#8]
;;;214    			switch(*(pFmt++)) // check next character
000214  7821              LDRB     r1,[r4,#0]
000216  1c64              ADDS     r4,r4,#1
000218  2958              CMP      r1,#0x58
00021a  d006              BEQ      |L1.554|
00021c  2964              CMP      r1,#0x64
00021e  d009              BEQ      |L1.564|
000220  2969              CMP      r1,#0x69
000222  d008              BEQ      |L1.566|
000224  2978              CMP      r1,#0x78
000226  d13f              BNE      |L1.680|
;;;215    			{
;;;216    				case 'x': // hexadecimal number
;;;217    				case 'X':
000228  bf00              NOP      
                  |L1.554|
;;;218    				wDivider = 0x10000000;
00022a  2001              MOVS     r0,#1
00022c  0700              LSLS     r0,r0,#28
00022e  9000              STR      r0,[sp,#0]
;;;219    				bHex = TRUE;
000230  2701              MOVS     r7,#1
;;;220    				case 'd': // decimal number
000232  bf00              NOP      
                  |L1.564|
;;;221    				case 'i':
000234  bf00              NOP      
                  |L1.566|
;;;222    
;;;223    				if(wVal)
000236  2d00              CMP      r5,#0
000238  d02f              BEQ      |L1.666|
;;;224    				{
;;;225    					while(wDivider)
00023a  e02a              B        |L1.658|
                  |L1.572|
;;;226    					{
;;;227    						ucDisp = wVal / wDivider;
00023c  4628              MOV      r0,r5
00023e  9900              LDR      r1,[sp,#0]
000240  f7fffffe          BL       __aeabi_uidivmod
000244  b2c6              UXTB     r6,r0
;;;228    						wVal = wVal % wDivider;
000246  4628              MOV      r0,r5
000248  9900              LDR      r1,[sp,#0]
00024a  f7fffffe          BL       __aeabi_uidivmod
00024e  460d              MOV      r5,r1
;;;229    
;;;230    						if(ucDisp)
000250  2e00              CMP      r6,#0
000252  d001              BEQ      |L1.600|
;;;231    						bNotZero=TRUE;					
000254  2001              MOVS     r0,#1
000256  9001              STR      r0,[sp,#4]
                  |L1.600|
;;;232    
;;;233    						if(bNotZero)
000258  9801              LDR      r0,[sp,#4]
00025a  2800              CMP      r0,#0
00025c  d00e              BEQ      |L1.636|
;;;234    						{
;;;235    							if(ucDisp > 9)
00025e  2e09              CMP      r6,#9
000260  dd04              BLE      |L1.620|
;;;236    							ucBff = ucDisp-0x0a+'A';
000262  4630              MOV      r0,r6
000264  3037              ADDS     r0,r0,#0x37
000266  b2c0              UXTB     r0,r0
000268  9003              STR      r0,[sp,#0xc]
00026a  e003              B        |L1.628|
                  |L1.620|
;;;237    							else
;;;238    							ucBff = ucDisp+'0';
00026c  4630              MOV      r0,r6
00026e  3030              ADDS     r0,r0,#0x30
000270  b2c0              UXTB     r0,r0
000272  9003              STR      r0,[sp,#0xc]
                  |L1.628|
;;;239    
;;;240    							nsAPI_UART_Send(&ucBff,1);
000274  2101              MOVS     r1,#1
000276  a803              ADD      r0,sp,#0xc
000278  f7fffffe          BL       nsAPI_UART_Send
                  |L1.636|
;;;241    						}					
;;;242    
;;;243    						if(bHex)
00027c  2f00              CMP      r7,#0
00027e  d003              BEQ      |L1.648|
;;;244    						wDivider /= 0x10;
000280  9800              LDR      r0,[sp,#0]
000282  0900              LSRS     r0,r0,#4
000284  9000              STR      r0,[sp,#0]
000286  e004              B        |L1.658|
                  |L1.648|
;;;245    						else
;;;246    						wDivider /= 10;
000288  210a              MOVS     r1,#0xa
00028a  9800              LDR      r0,[sp,#0]
00028c  f7fffffe          BL       __aeabi_uidivmod
000290  9000              STR      r0,[sp,#0]
                  |L1.658|
000292  9800              LDR      r0,[sp,#0]            ;225
000294  2800              CMP      r0,#0                 ;225
000296  d1d1              BNE      |L1.572|
000298  e005              B        |L1.678|
                  |L1.666|
;;;247    					}
;;;248    				}
;;;249    				else
;;;250    				{
;;;251    					ucBff = '0';
00029a  2030              MOVS     r0,#0x30
00029c  9003              STR      r0,[sp,#0xc]
;;;252    					nsAPI_UART_Send(&ucBff,1);
00029e  2101              MOVS     r1,#1
0002a0  a803              ADD      r0,sp,#0xc
0002a2  f7fffffe          BL       nsAPI_UART_Send
                  |L1.678|
;;;253    				}		   
;;;254    				break;				
0002a6  bf00              NOP      
                  |L1.680|
0002a8  e003              B        |L1.690|
                  |L1.682|
;;;255    			}
;;;256    		}
;;;257    		else // general
;;;258    		nsAPI_UART_Send(&ucBff,1); 
0002aa  2101              MOVS     r1,#1
0002ac  a803              ADD      r0,sp,#0xc
0002ae  f7fffffe          BL       nsAPI_UART_Send
                  |L1.690|
0002b2  7821              LDRB     r1,[r4,#0]            ;209
0002b4  1c64              ADDS     r4,r4,#1              ;209
0002b6  9103              STR      r1,[sp,#0xc]          ;209
0002b8  2900              CMP      r1,#0                 ;209
0002ba  dca3              BGT      |L1.516|
;;;259    	} 
;;;260    }
0002bc  b005              ADD      sp,sp,#0x14
0002be  bdf0              POP      {r4-r7,pc}
;;;261    
                          ENDP

                  |L1.704|
                          DCD      0x40008000
                  |L1.708|
                          DCD      g_Uart_Setting
                  |L1.712|
                          DCD      0xe000e180
                  |L1.716|
                          DCD      0x40044040
                  |L1.720|
                          DCD      0x40048080
                  |L1.724|
                          DCD      SystemCoreClock
                  |L1.728|
                          DCD      0x00989680

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_Uart_Setting
                          %        28

;*** Start embedded assembler ***

#line 1 "Src\\uart.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_uart_c_6d57c09f____REV16|
#line 112 ".\\Inc\\core_cmInstr.h"
|__asm___6_uart_c_6d57c09f____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_uart_c_6d57c09f____REVSH|
#line 130
|__asm___6_uart_c_6d57c09f____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
