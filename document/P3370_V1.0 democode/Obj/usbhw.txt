; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\usbhw.o --depend=.\Obj\usbhw.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\Inc -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\NXP\LPC11Uxx -D__MICROLIB -D__DEBUG_FLASH --omf_browse=.\Obj\usbhw.crf Src\usbhw.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  EPAdr PROC
;;;69      */
;;;70     static RetU32 EPAdr(U32 EPNum)
000000  4601              MOV      r1,r0
;;;71     {
;;;72     	U32 val;
;;;73     
;;;74     	val = (EPNum & 0x0F) << 1;
000002  070a              LSLS     r2,r1,#28
000004  0ed0              LSRS     r0,r2,#27
;;;75     
;;;76     	if(EPNum & 0x80)
000006  2280              MOVS     r2,#0x80
000008  4211              TST      r1,r2
00000a  d000              BEQ      |L1.14|
;;;77     	{
;;;78     		val += 1;
00000c  1c40              ADDS     r0,r0,#1
                  |L1.14|
;;;79     	}
;;;80     	return (val);
;;;81     }
00000e  4770              BX       lr
;;;82     
                          ENDP

                  NDrv_USB_IOClkConfig PROC
;;;89      */
;;;90     void NDrv_USB_IOClkConfig(void)
000010  48fe              LDR      r0,|L1.1036|
;;;91     {
;;;92     	/* Enable AHB clock to the GPIO domain. */
;;;93     	LPC_SYSCON->SYSAHBCLKCTRL |= BIT6;
000012  6800              LDR      r0,[r0,#0]
000014  2140              MOVS     r1,#0x40
000016  4308              ORRS     r0,r0,r1
000018  49fc              LDR      r1,|L1.1036|
00001a  6008              STR      r0,[r1,#0]
;;;94     
;;;95     	/* Enable AHB clock to the USB block and USB RAM. */
;;;96     	LPC_SYSCON->SYSAHBCLKCTRL |= (BIT14|BIT27);
00001c  4608              MOV      r0,r1
00001e  6800              LDR      r0,[r0,#0]
000020  49fb              LDR      r1,|L1.1040|
000022  4308              ORRS     r0,r0,r1
000024  49f9              LDR      r1,|L1.1036|
000026  6008              STR      r0,[r1,#0]
;;;97     
;;;98     	/* Pull-down is needed, or internally, VBUS will be floating. This is to
;;;99     	address the wrong status in VBUSDebouncing bit in CmdStatus register. It
;;;100    	happens on the NXP Validation Board only that a wrong ESD protection chip is used. */
;;;101    	LPC_IOCON->PIO0_3 &= ~0x1F;
000028  48fa              LDR      r0,|L1.1044|
00002a  68c0              LDR      r0,[r0,#0xc]
00002c  0940              LSRS     r0,r0,#5
00002e  0140              LSLS     r0,r0,#5
000030  49f8              LDR      r1,|L1.1044|
000032  60c8              STR      r0,[r1,#0xc]
;;;102    	LPC_IOCON->PIO0_3 |= (BIT3|BIT0);	/* Secondary function VBUS */
000034  4608              MOV      r0,r1
000036  68c0              LDR      r0,[r0,#0xc]
000038  2109              MOVS     r1,#9
00003a  4308              ORRS     r0,r0,r1
00003c  49f5              LDR      r1,|L1.1044|
00003e  60c8              STR      r0,[r1,#0xc]
;;;103    	//  LPC_IOCON->PIO0_3   |= (0x01<<0);			/* Secondary function VBUS */
;;;104    	LPC_IOCON->PIO0_6 &= ~0x07;
000040  4608              MOV      r0,r1
000042  6980              LDR      r0,[r0,#0x18]
000044  08c0              LSRS     r0,r0,#3
000046  00c0              LSLS     r0,r0,#3
000048  6188              STR      r0,[r1,#0x18]
;;;105    	LPC_IOCON->PIO0_6 |= BIT0;			/* Secondary function SoftConn */
00004a  4608              MOV      r0,r1
00004c  6980              LDR      r0,[r0,#0x18]
00004e  2101              MOVS     r1,#1
000050  4308              ORRS     r0,r0,r1
000052  49f0              LDR      r1,|L1.1044|
000054  6188              STR      r0,[r1,#0x18]
;;;106    
;;;107    #if POWERDOWN_MODE_USB_WAKEUP
;;;108    	LPC_USB->DEVCMDSTAT &= ~USB_PLL_ON;	/* NeedClk normal mode(not ALWAYS ON) */
;;;109    	LPC_SYSCON->USBCLKCTRL = 0x1<<1;  /* USB wakeup interrupt on rising edge of Needclk. */
;;;110    #endif
;;;111    }
000056  4770              BX       lr
;;;112    
                          ENDP

                  USB_GetEPCmdStatusPtr PROC
;;;155     */
;;;156    RetU32 USB_GetEPCmdStatusPtr(U32 EPNum)
000058  b570              PUSH     {r4-r6,lr}
;;;157    {
00005a  4604              MOV      r4,r0
;;;158    	U32 addr;
;;;159    
;;;160    	addr = (U32)USB_EPLIST_ADDR;
00005c  4dee              LDR      r5,|L1.1048|
;;;161    	addr += ((EPAdr(EPNum)*2) << 2);/* Based on EPCommand/Status List, all EPs are double buffered except CTRL EP 0, size is 32-bit. */
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       EPAdr
000064  00c0              LSLS     r0,r0,#3
000066  1945              ADDS     r5,r0,r5
;;;162    	return (addr);
000068  4628              MOV      r0,r5
;;;163    }
00006a  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP

                  NDrv_USB_EPInit PROC
;;;174     */
;;;175    void NDrv_USB_EPInit(void)
00006c  b570              PUSH     {r4-r6,lr}
;;;176    {
;;;177    	U32 *addr, data_ptr,i, j = 0;
00006e  2200              MOVS     r2,#0
;;;178    
;;;179    	addr = (U32 *)USB_EPLIST_ADDR;
000070  48e9              LDR      r0,|L1.1048|
;;;180    	LPC_USB->EPLISTSTART = USB_EPLIST_ADDR;
000072  4604              MOV      r4,r0
000074  4de9              LDR      r5,|L1.1052|
000076  60ac              STR      r4,[r5,#8]
;;;181    	data_ptr = USB_EPDATA_ADDR;
000078  49e9              LDR      r1,|L1.1056|
;;;182    	LPC_USB->DATABUFSTART = USB_EPDATA_PAGE;
00007a  026c              LSLS     r4,r5,#9
00007c  60ec              STR      r4,[r5,#0xc]
;;;183    
;;;184    	/* CTRL, BULK or Interrupt IN/OUT EPs, max EP size is 64 */
;;;185    	/* For EP0, double buffer doesn't apply to CTRL EPs, but, EP0OUTBuf0 is
;;;186    	for EP0OUT, EP0OUTBuf1 is for SETUP, EP0INBuf0 is for EP0IN, EP0INTBuf1 is
;;;187    	reserved. Also note: ACTIVE bit doesn't apply to SETUP and Reserved EP buffer. */
;;;188    	*addr++ = (USB_MAX_PACKET0 << 16)|((U16)(data_ptr >> 6));
00007e  028c              LSLS     r4,r1,#10
000080  0c24              LSRS     r4,r4,#16
000082  00ed              LSLS     r5,r5,#3
000084  432c              ORRS     r4,r4,r5
000086  c010              STM      r0!,{r4}
;;;189    	g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
000088  00d5              LSLS     r5,r2,#3
00008a  4ce6              LDR      r4,|L1.1060|
00008c  5161              STR      r1,[r4,r5]
;;;190    	g_USBHW_Setting.EPList[j++].buf_length = USB_MAX_PACKET0;
00008e  2640              MOVS     r6,#0x40
000090  4614              MOV      r4,r2
000092  1c52              ADDS     r2,r2,#1
000094  00e5              LSLS     r5,r4,#3
000096  4ce3              LDR      r4,|L1.1060|
000098  192c              ADDS     r4,r5,r4
00009a  6066              STR      r6,[r4,#4]
;;;191    	data_ptr += USB_MAX_PACKET0;
00009c  3140              ADDS     r1,r1,#0x40
;;;192    
;;;193    	*addr++ = ((U16)(data_ptr >> 6));/* No length field for SETUP */
00009e  028c              LSLS     r4,r1,#10
0000a0  0c24              LSRS     r4,r4,#16
0000a2  c010              STM      r0!,{r4}
;;;194    	g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
0000a4  00d5              LSLS     r5,r2,#3
0000a6  4cdf              LDR      r4,|L1.1060|
0000a8  5161              STR      r1,[r4,r5]
;;;195    	g_USBHW_Setting.EPList[j++].buf_length = USB_SETUP_PACKET_SIZE;
0000aa  2608              MOVS     r6,#8
0000ac  4614              MOV      r4,r2
0000ae  1c52              ADDS     r2,r2,#1
0000b0  00e5              LSLS     r5,r4,#3
0000b2  4cdc              LDR      r4,|L1.1060|
0000b4  192c              ADDS     r4,r5,r4
0000b6  6066              STR      r6,[r4,#4]
;;;196    	/* For easier alignment, the data field is aligned to 64 bytes for all EPs. */
;;;197    	data_ptr += USB_MAX_PACKET0;
0000b8  3140              ADDS     r1,r1,#0x40
;;;198    
;;;199    	*addr++ = (USB_MAX_PACKET0 << 16)|((U16)(data_ptr >> 6));
0000ba  028c              LSLS     r4,r1,#10
0000bc  0c24              LSRS     r4,r4,#16
0000be  0555              LSLS     r5,r2,#21
0000c0  432c              ORRS     r4,r4,r5
0000c2  c010              STM      r0!,{r4}
;;;200    	g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
0000c4  00d5              LSLS     r5,r2,#3
0000c6  4cd7              LDR      r4,|L1.1060|
0000c8  5161              STR      r1,[r4,r5]
;;;201    	g_USBHW_Setting.EPList[j++].buf_length = USB_MAX_PACKET0;
0000ca  2640              MOVS     r6,#0x40
0000cc  4615              MOV      r5,r2
0000ce  1c52              ADDS     r2,r2,#1
0000d0  00ed              LSLS     r5,r5,#3
0000d2  192c              ADDS     r4,r5,r4
0000d4  6066              STR      r6,[r4,#4]
;;;202    	data_ptr += USB_MAX_PACKET0;
0000d6  3140              ADDS     r1,r1,#0x40
;;;203    
;;;204    #if 0
;;;205    	/* EP0 IN second buffer(buffer1) is reserved. */
;;;206    	*addr++ = (USB_MAX_PACKET0<<16)|((uint16_t)(data_ptr>>6));
;;;207    #else
;;;208    	addr++;
0000d8  1d00              ADDS     r0,r0,#4
;;;209    #endif
;;;210    
;;;211    	g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
0000da  00d5              LSLS     r5,r2,#3
0000dc  4cd1              LDR      r4,|L1.1060|
0000de  5161              STR      r1,[r4,r5]
;;;212    	g_USBHW_Setting.EPList[j++].buf_length = USB_MAX_PACKET0;
0000e0  4614              MOV      r4,r2
0000e2  1c52              ADDS     r2,r2,#1
0000e4  00e5              LSLS     r5,r4,#3
0000e6  4ccf              LDR      r4,|L1.1060|
0000e8  192c              ADDS     r4,r5,r4
0000ea  6066              STR      r6,[r4,#4]
;;;213    	data_ptr += USB_MAX_PACKET0;
0000ec  3140              ADDS     r1,r1,#0x40
;;;214    
;;;215    	for(i = 2; i < USB_EP_NUM; i++)
0000ee  2302              MOVS     r3,#2
0000f0  e01f              B        |L1.306|
                  |L1.242|
;;;216    	{
;;;217    		/* Buffer 0 */
;;;218    #if USB_ISO_COMMUNICATION
;;;219    		*addr++ = EP_DISABLED|EP_ISO_TYPE|(USB_MAX_ISO_SIZE << 16)|((U16)(data_ptr >> 6));
;;;220    		g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
;;;221    		g_USBHW_Setting.EPList[j++].buf_length = USB_MAX_ISO_SIZE;
;;;222    		data_ptr += USB_MAX_ISO_SIZE;
;;;223    #else
;;;224    		*addr++ = EP_DISABLED|(USB_MAX_NON_ISO_SIZE << 16)|((U16)(data_ptr >> 6));
0000f2  028c              LSLS     r4,r1,#10
0000f4  0c24              LSRS     r4,r4,#16
0000f6  4dcc              LDR      r5,|L1.1064|
0000f8  432c              ORRS     r4,r4,r5
0000fa  c010              STM      r0!,{r4}
;;;225    		g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
0000fc  00d5              LSLS     r5,r2,#3
0000fe  4cc9              LDR      r4,|L1.1060|
000100  5161              STR      r1,[r4,r5]
;;;226    		g_USBHW_Setting.EPList[j++].buf_length = USB_MAX_NON_ISO_SIZE;
000102  2640              MOVS     r6,#0x40
000104  4614              MOV      r4,r2
000106  1c52              ADDS     r2,r2,#1
000108  00e5              LSLS     r5,r4,#3
00010a  4cc6              LDR      r4,|L1.1060|
00010c  192c              ADDS     r4,r5,r4
00010e  6066              STR      r6,[r4,#4]
;;;227    		data_ptr += USB_MAX_NON_ISO_SIZE;
000110  3140              ADDS     r1,r1,#0x40
;;;228    #endif
;;;229    		/* Buffer 1 */
;;;230    #if USB_ISO_COMMUNICATION
;;;231    		*addr++ = EP_DISABLED|EP_ISO_TYPE|(USB_MAX_ISO_SIZE << 16)|((U16)(data_ptr >> 6));
;;;232    		g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
;;;233    		g_USBHW_Setting.EPList[j++].buf_length = USB_MAX_ISO_SIZE;
;;;234    		data_ptr += USB_MAX_ISO_SIZE;
;;;235    #else
;;;236    		*addr++ = EP_DISABLED|(USB_MAX_NON_ISO_SIZE << 16)|((U16)(data_ptr >> 6));
000112  028c              LSLS     r4,r1,#10
000114  0c24              LSRS     r4,r4,#16
000116  4dc4              LDR      r5,|L1.1064|
000118  432c              ORRS     r4,r4,r5
00011a  c010              STM      r0!,{r4}
;;;237    		g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
00011c  00d5              LSLS     r5,r2,#3
00011e  4cc1              LDR      r4,|L1.1060|
000120  5161              STR      r1,[r4,r5]
;;;238    		g_USBHW_Setting.EPList[j++].buf_length = USB_MAX_NON_ISO_SIZE;
000122  4614              MOV      r4,r2
000124  1c52              ADDS     r2,r2,#1
000126  00e5              LSLS     r5,r4,#3
000128  4cbe              LDR      r4,|L1.1060|
00012a  192c              ADDS     r4,r5,r4
00012c  6066              STR      r6,[r4,#4]
;;;239    		data_ptr += USB_MAX_NON_ISO_SIZE;
00012e  3140              ADDS     r1,r1,#0x40
000130  1c5b              ADDS     r3,r3,#1              ;215
                  |L1.306|
000132  2b04              CMP      r3,#4                 ;215
000134  d3dd              BCC      |L1.242|
;;;240    #endif
;;;241    	}
;;;242    }
000136  bd70              POP      {r4-r6,pc}
;;;243    
                          ENDP

                  NDrv_USB_Connect PROC
;;;288    
;;;289    void NDrv_USB_Connect(U8 con)
000138  2800              CMP      r0,#0
;;;290    {
;;;291    	if(con)
00013a  d007              BEQ      |L1.332|
;;;292    	LPC_USB->DEVCMDSTAT |= USB_DCON;
00013c  49b7              LDR      r1,|L1.1052|
00013e  6809              LDR      r1,[r1,#0]
000140  2201              MOVS     r2,#1
000142  0412              LSLS     r2,r2,#16
000144  4311              ORRS     r1,r1,r2
000146  4ab5              LDR      r2,|L1.1052|
000148  6011              STR      r1,[r2,#0]
00014a  e006              B        |L1.346|
                  |L1.332|
;;;293    	else
;;;294    	LPC_USB->DEVCMDSTAT &= ~USB_DCON;
00014c  49b3              LDR      r1,|L1.1052|
00014e  6809              LDR      r1,[r1,#0]
000150  2201              MOVS     r2,#1
000152  0412              LSLS     r2,r2,#16
000154  4391              BICS     r1,r1,r2
000156  4ab1              LDR      r2,|L1.1052|
000158  6011              STR      r1,[r2,#0]
                  |L1.346|
;;;295    }
00015a  4770              BX       lr
;;;296    
                          ENDP

                  NDrv_USB_Reset PROC
;;;304    
;;;305    void NDrv_USB_Reset(void)
00015c  b500              PUSH     {lr}
;;;306    {
;;;307    	g_USBHW_Setting.BufferUsed = 0;
00015e  2000              MOVS     r0,#0
000160  49b0              LDR      r1,|L1.1060|
000162  3908              SUBS     r1,r1,#8
000164  6008              STR      r0,[r1,#0]  ; g_USBHW_Setting
;;;308    	g_USBHW_Setting.EPActiveFlag = 0;
000166  6048              STR      r0,[r1,#4]  ; g_USBHW_Setting
;;;309    
;;;310    	/* Initialize EP Command/Status List. */
;;;311    	NDrv_USB_EPInit();
000168  f7fffffe          BL       NDrv_USB_EPInit
;;;312    
;;;313    	LPC_USB->DEVCMDSTAT |= USB_EN;
00016c  48ab              LDR      r0,|L1.1052|
00016e  6800              LDR      r0,[r0,#0]
000170  2180              MOVS     r1,#0x80
000172  4308              ORRS     r0,r0,r1
000174  49a9              LDR      r1,|L1.1052|
000176  6008              STR      r0,[r1,#0]
;;;314    	/* Clear all EP interrupts, device status, and SOF interrupts. */
;;;315    	LPC_USB->INTSTAT = 0xC00003FF;
000178  48ac              LDR      r0,|L1.1068|
00017a  6208              STR      r0,[r1,#0x20]
;;;316    	/* Enable all ten(10) EPs interrupts including EP0, note: EP won't be
;;;317    	ready until it's configured/enabled when device sending SetEPStatus command
;;;318    	to the command engine. */
;;;319    	LPC_USB->INTEN  = DEV_STAT_INT | 0x3FF | (USB_SOF_EVENT ? FRAME_INT : 0);
00017c  48ac              LDR      r0,|L1.1072|
00017e  6248              STR      r0,[r1,#0x24]
;;;320    }
000180  bd00              POP      {pc}
;;;321    
                          ENDP

                  nsAPI_USB_Init PROC
;;;250    
;;;251    void nsAPI_USB_Init (void)
000182  b500              PUSH     {lr}
;;;252    {
;;;253    	NVIC_DisableIRQ(USB_IRQn);
000184  bf00              NOP      
000186  2116              MOVS     r1,#0x16
000188  2001              MOVS     r0,#1
00018a  4088              LSLS     r0,r0,r1
00018c  49a9              LDR      r1,|L1.1076|
00018e  6008              STR      r0,[r1,#0]
000190  bf00              NOP      
;;;254    	/* Initialize clock and I/O pins for USB. */
;;;255    	NDrv_USB_IOClkConfig();
000192  f7fffffe          BL       NDrv_USB_IOClkConfig
;;;256    
;;;257    #if LPM_SUPPORT
;;;258    	/* Link Power Management is supported. */
;;;259    	LPC_USB->DEVCMDSTAT |= USB_LPM;
;;;260    	LPC_USB->LPM |= (0x2 << 4);		/* RESUME duration. */
;;;261    #endif
;;;262    
;;;263    #if USB_FIQ_EVENT
;;;264    	/* At present, only FRAME(ISO) is routed to FIQ. */
;;;265    	LPC_USB->IntRouting = FRAME_INT;		/* SOF uses FIQ */
;;;266    
;;;267    	/* Enable the USB FIQ Interrupt */
;;;268    	NVIC_EnableIRQ(USB_FIQn);
;;;269    #endif
;;;270    
;;;271    #if USE_DOUBLE_BUFFER
;;;272    	LPC_USB->EPBUFCFG = 0x3FC;
;;;273    #endif
;;;274    	/* Enable the USB Interrupt */
;;;275    	NVIC_EnableIRQ(USB_IRQn);
000196  bf00              NOP      
000198  2116              MOVS     r1,#0x16
00019a  2001              MOVS     r0,#1
00019c  4088              LSLS     r0,r0,r1
00019e  49a5              LDR      r1,|L1.1076|
0001a0  3980              SUBS     r1,r1,#0x80
0001a2  6008              STR      r0,[r1,#0]
0001a4  bf00              NOP      
;;;276    
;;;277    	NDrv_USB_Reset();
0001a6  f7fffffe          BL       NDrv_USB_Reset
;;;278    	NDrv_USB_Connect(TRUE);/* USB Connect */
0001aa  2001              MOVS     r0,#1
0001ac  f7fffffe          BL       NDrv_USB_Connect
;;;279    }
0001b0  bd00              POP      {pc}
;;;280    
                          ENDP

                  USB_Suspend PROC
;;;329    
;;;330    void USB_Suspend (void) {
0001b2  4770              BX       lr
;;;331      /* Performed by Hardware */
;;;332    #if POWERDOWN_MODE_USB_WAKEUP
;;;333      timer16_0_counter = 0;
;;;334      NDrv_Timer16_Enable( 0 );
;;;335    
;;;336      if ( SuspendFlag == 0 ) {
;;;337    	SuspendFlag = 1;
;;;338      }
;;;339    #endif
;;;340    }
;;;341    
                          ENDP

                  USB_Resume PROC
;;;349    
;;;350    void USB_Resume (void) {
0001b4  4770              BX       lr
;;;351      /* Performed by Hardware */
;;;352    #if POWERDOWN_MODE_USB_WAKEUP
;;;353      NDrv_Timer16_Disable( 0 );
;;;354      timer16_0_counter = 0;
;;;355      if ( SuspendFlag == 1 ) {
;;;356    	SuspendFlag = 0;
;;;357      }
;;;358    #endif
;;;359    }
;;;360    
                          ENDP

                  USB_WakeUp PROC
;;;368    
;;;369    void USB_WakeUp (void) {
0001b6  48a0              LDR      r0,|L1.1080|
;;;370    
;;;371      if (g_USBCore_Setting.USB_DeviceStatus & USB_GETSTATUS_REMOTE_WAKEUP) {
0001b8  8800              LDRH     r0,[r0,#0]  ; g_USBCore_Setting
0001ba  2102              MOVS     r1,#2
0001bc  4208              TST      r0,r1
0001be  d005              BEQ      |L1.460|
;;;372    	LPC_USB->DEVCMDSTAT &= ~USB_DSUS;
0001c0  4896              LDR      r0,|L1.1052|
0001c2  6800              LDR      r0,[r0,#0]
0001c4  0409              LSLS     r1,r1,#16
0001c6  4388              BICS     r0,r0,r1
0001c8  4994              LDR      r1,|L1.1052|
0001ca  6008              STR      r0,[r1,#0]
                  |L1.460|
;;;373      }
;;;374    }
0001cc  4770              BX       lr
;;;375    
                          ENDP

                  NDrv_USB_WakeUpCfg PROC
;;;382    
;;;383    void NDrv_USB_WakeUpCfg(U8 cfg)
0001ce  bf00              NOP      
;;;384    {
;;;385    #if REMOTE_WAKEUP_ENABLE
;;;386    	if(cfg == TRUE)
;;;387    	{
;;;388    		LPC_USB->DEVCMDSTAT &= ~USB_PLL_ON;/* NeedClk functional */
;;;389    		LPC_SYSCON->USBCLKCTRL = 1;
;;;390    	}
;;;391    	else
;;;392    	{
;;;393    		LPC_USB->DEVCMDSTAT |= USB_PLL_ON;/* NeedClk always "1" */
;;;394    		LPC_SYSCON->USBCLKCTRL = 0;
;;;395    	}
;;;396    #else
;;;397    	cfg = cfg;  /* Not needed */
;;;398    #endif
;;;399    }
0001d0  4770              BX       lr
;;;400    
                          ENDP

                  nsAPI_USB_SetAddress PROC
;;;407    
;;;408    void nsAPI_USB_SetAddress(U32 adr)
0001d2  4992              LDR      r1,|L1.1052|
;;;409    {
;;;410    	LPC_USB->DEVCMDSTAT &= ~0x7F;
0001d4  6809              LDR      r1,[r1,#0]
0001d6  09c9              LSRS     r1,r1,#7
0001d8  01c9              LSLS     r1,r1,#7
0001da  4a90              LDR      r2,|L1.1052|
0001dc  6011              STR      r1,[r2,#0]
;;;411    	LPC_USB->DEVCMDSTAT |= (USB_EN | adr);
0001de  4611              MOV      r1,r2
0001e0  6809              LDR      r1,[r1,#0]
0001e2  2280              MOVS     r2,#0x80
0001e4  4302              ORRS     r2,r2,r0
0001e6  4311              ORRS     r1,r1,r2
0001e8  4a8c              LDR      r2,|L1.1052|
0001ea  6011              STR      r1,[r2,#0]
;;;412    }
0001ec  4770              BX       lr
;;;413    
                          ENDP

                  NDrv_USB_Configure PROC
;;;420    
;;;421    void NDrv_USB_Configure(U8 cfg)
0001ee  2800              CMP      r0,#0
;;;422    {
;;;423    	if(cfg)
0001f0  d003              BEQ      |L1.506|
;;;424    	{
;;;425    		/* All the non-zero EPs are configured and enabled per configuration
;;;426    		descriptor. Enable all interrupts. */
;;;427    		LPC_USB->INTEN  = DEV_STAT_INT | 0x3FF | (USB_SOF_EVENT ? FRAME_INT : 0);
0001f2  498f              LDR      r1,|L1.1072|
0001f4  4a89              LDR      r2,|L1.1052|
0001f6  6251              STR      r1,[r2,#0x24]
0001f8  e002              B        |L1.512|
                  |L1.506|
;;;428    	}
;;;429    	else
;;;430    	{
;;;431    		/* TBD. if the configuration is FALSE, turn off all the non-zero EPs. Only
;;;432    		CTRL EP interrupts are enabled. */
;;;433    		LPC_USB->INTEN  = DEV_STAT_INT | 0x03 | (USB_SOF_EVENT ? FRAME_INT : 0);
0001fa  4990              LDR      r1,|L1.1084|
0001fc  4a87              LDR      r2,|L1.1052|
0001fe  6251              STR      r1,[r2,#0x24]
                  |L1.512|
;;;434    	}
;;;435    }
000200  4770              BX       lr
;;;436    
                          ENDP

                  nsAPI_USB_DeactivateEP PROC
;;;471    
;;;472    void nsAPI_USB_DeactivateEP(U32 EPNum)
000202  b570              PUSH     {r4-r6,lr}
;;;473    {
000204  4604              MOV      r4,r0
;;;474    	U32 epbit;
;;;475    
;;;476    	epbit = 0x1U << EPAdr(EPNum);
000206  4620              MOV      r0,r4
000208  f7fffffe          BL       EPAdr
00020c  2101              MOVS     r1,#1
00020e  4081              LSLS     r1,r1,r0
000210  460d              MOV      r5,r1
;;;477    	LPC_USB->EPSKIP |= epbit;
000212  4882              LDR      r0,|L1.1052|
000214  6940              LDR      r0,[r0,#0x14]
000216  4328              ORRS     r0,r0,r5
000218  4980              LDR      r1,|L1.1052|
00021a  6148              STR      r0,[r1,#0x14]
;;;478    
;;;479    	while(LPC_USB->EPSKIP & epbit){}
00021c  bf00              NOP      
                  |L1.542|
00021e  487f              LDR      r0,|L1.1052|
000220  6940              LDR      r0,[r0,#0x14]
000222  4228              TST      r0,r5
000224  d1fb              BNE      |L1.542|
;;;480    
;;;481    	LPC_USB->INTSTAT = epbit;/* Clear EP interrupt(s). */
000226  487d              LDR      r0,|L1.1052|
000228  6205              STR      r5,[r0,#0x20]
;;;482    }
00022a  bd70              POP      {r4-r6,pc}
;;;483    
                          ENDP

                  nsAPI_USB_EnableEP PROC
;;;491    
;;;492    void nsAPI_USB_EnableEP(U32 EPNum)
00022c  b570              PUSH     {r4-r6,lr}
;;;493    {
00022e  4604              MOV      r4,r0
;;;494    	U32 *addr;
;;;495    
;;;496    	addr = (U32 *)USB_GetEPCmdStatusPtr(EPNum);
000230  4620              MOV      r0,r4
000232  f7fffffe          BL       USB_GetEPCmdStatusPtr
000236  4605              MOV      r5,r0
;;;497    	*addr &= ~EP_DISABLED;
000238  2101              MOVS     r1,#1
00023a  0789              LSLS     r1,r1,#30
00023c  6828              LDR      r0,[r5,#0]
00023e  4388              BICS     r0,r0,r1
000240  6028              STR      r0,[r5,#0]
;;;498    
;;;499    	if(EPNum & 0x0F)/* Non-zero EPs */
000242  0720              LSLS     r0,r4,#28
000244  0f00              LSRS     r0,r0,#28
000246  d02a              BEQ      |L1.670|
;;;500    	{
;;;501    		if(EPNum & 0x80)/* For non-zero IN */
000248  2080              MOVS     r0,#0x80
00024a  4204              TST      r4,r0
00024c  d00f              BEQ      |L1.622|
;;;502    		{
;;;503    			if( LPC_USB->EPBUFCFG & (0x1U << EPAdr(EPNum)))
00024e  4620              MOV      r0,r4
000250  f7fffffe          BL       EPAdr
000254  2101              MOVS     r1,#1
000256  4081              LSLS     r1,r1,r0
000258  4870              LDR      r0,|L1.1052|
00025a  69c0              LDR      r0,[r0,#0x1c]
00025c  4201              TST      r1,r0
00025e  d01e              BEQ      |L1.670|
;;;504    			{
;;;505    				/* For non-zero double buffer EPs, clear EP_DISABLED to both buffer. */
;;;506    				addr++;
000260  1d2d              ADDS     r5,r5,#4
;;;507    				*addr &= ~EP_DISABLED;
000262  2101              MOVS     r1,#1
000264  0789              LSLS     r1,r1,#30
000266  6828              LDR      r0,[r5,#0]
000268  4388              BICS     r0,r0,r1
00026a  6028              STR      r0,[r5,#0]
00026c  e017              B        |L1.670|
                  |L1.622|
;;;508    			}
;;;509    		}
;;;510    		else
;;;511    		{
;;;512    			/* For non-zero EP OUT, in addition to clear EP_DISABLED bits,
;;;513    			set the ACTIVE bit indicating that EP is ready to read. For
;;;514    			double buffered EPs, set ACTIVE bit and clear EP_DISABLED bit
;;;515    			for both buffer0 and 1. */
;;;516    			*addr |= BUF_ACTIVE;
00026e  2101              MOVS     r1,#1
000270  07c9              LSLS     r1,r1,#31
000272  6828              LDR      r0,[r5,#0]
000274  4308              ORRS     r0,r0,r1
000276  6028              STR      r0,[r5,#0]
;;;517    
;;;518    			if( LPC_USB->EPBUFCFG & (0x1U << EPAdr(EPNum)) )
000278  4620              MOV      r0,r4
00027a  f7fffffe          BL       EPAdr
00027e  2101              MOVS     r1,#1
000280  4081              LSLS     r1,r1,r0
000282  4866              LDR      r0,|L1.1052|
000284  69c0              LDR      r0,[r0,#0x1c]
000286  4201              TST      r1,r0
000288  d009              BEQ      |L1.670|
;;;519    			{
;;;520    				/* For double buffer. */
;;;521    				addr++;
00028a  1d2d              ADDS     r5,r5,#4
;;;522    				*addr &= ~EP_DISABLED;
00028c  2101              MOVS     r1,#1
00028e  0789              LSLS     r1,r1,#30
000290  6828              LDR      r0,[r5,#0]
000292  4388              BICS     r0,r0,r1
000294  6028              STR      r0,[r5,#0]
;;;523    				*addr |= BUF_ACTIVE;
000296  0049              LSLS     r1,r1,#1
000298  6828              LDR      r0,[r5,#0]
00029a  4308              ORRS     r0,r0,r1
00029c  6028              STR      r0,[r5,#0]
                  |L1.670|
;;;524    			}
;;;525    		}
;;;526    	}
;;;527    }
00029e  bd70              POP      {r4-r6,pc}
;;;528    
                          ENDP

                  nsAPI_USB_DisableEP PROC
;;;537    
;;;538    void nsAPI_USB_DisableEP(U32 EPNum)
0002a0  b570              PUSH     {r4-r6,lr}
;;;539    {
0002a2  4604              MOV      r4,r0
;;;540    	U32 *addr;
;;;541    
;;;542    	addr = (U32 *)USB_GetEPCmdStatusPtr(EPNum);
0002a4  4620              MOV      r0,r4
0002a6  f7fffffe          BL       USB_GetEPCmdStatusPtr
0002aa  4605              MOV      r5,r0
;;;543    
;;;544    	if(EPNum & 0x0F)	/* Non-zero EPs only, EP0 should never be disabled. */
0002ac  0720              LSLS     r0,r4,#28
0002ae  0f00              LSRS     r0,r0,#28
0002b0  d013              BEQ      |L1.730|
;;;545    	{
;;;546    		*addr |= EP_DISABLED;
0002b2  2101              MOVS     r1,#1
0002b4  0789              LSLS     r1,r1,#30
0002b6  6828              LDR      r0,[r5,#0]
0002b8  4308              ORRS     r0,r0,r1
0002ba  6028              STR      r0,[r5,#0]
;;;547    		/* For non-zero EPs, if double buffer is used, disable both EP buffers. */
;;;548    		if(LPC_USB->EPBUFCFG & (0x1U << EPAdr(EPNum)))
0002bc  4620              MOV      r0,r4
0002be  f7fffffe          BL       EPAdr
0002c2  2101              MOVS     r1,#1
0002c4  4081              LSLS     r1,r1,r0
0002c6  4855              LDR      r0,|L1.1052|
0002c8  69c0              LDR      r0,[r0,#0x1c]
0002ca  4201              TST      r1,r0
0002cc  d005              BEQ      |L1.730|
;;;549    		{
;;;550    			addr++;
0002ce  1d2d              ADDS     r5,r5,#4
;;;551    			*addr |= EP_DISABLED;
0002d0  2101              MOVS     r1,#1
0002d2  0789              LSLS     r1,r1,#30
0002d4  6828              LDR      r0,[r5,#0]
0002d6  4308              ORRS     r0,r0,r1
0002d8  6028              STR      r0,[r5,#0]
                  |L1.730|
;;;552    		}
;;;553    	}
;;;554    }
0002da  bd70              POP      {r4-r6,pc}
;;;555    
                          ENDP

                  nsAPI_USB_ResetEP PROC
;;;564    
;;;565    void nsAPI_USB_ResetEP(U32 EPNum)
0002dc  b570              PUSH     {r4-r6,lr}
;;;566    {
0002de  4604              MOV      r4,r0
;;;567    	U32 *addr;
;;;568    
;;;569    	addr = (U32 *)USB_GetEPCmdStatusPtr( EPNum );
0002e0  4620              MOV      r0,r4
0002e2  f7fffffe          BL       USB_GetEPCmdStatusPtr
0002e6  4605              MOV      r5,r0
;;;570    	/* Based on EPInUse register to decide which buffer needs to toggle
;;;571    	reset. When this happens, the STALL bits need to be cleared for both
;;;572    	buffer 0 and 1. */
;;;573    	*addr &= ~EP_STALL;
0002e8  2101              MOVS     r1,#1
0002ea  0749              LSLS     r1,r1,#29
0002ec  6828              LDR      r0,[r5,#0]
0002ee  4388              BICS     r0,r0,r1
0002f0  6028              STR      r0,[r5,#0]
;;;574    	*(addr+2) &= ~EP_STALL;
0002f2  68a8              LDR      r0,[r5,#8]
0002f4  4388              BICS     r0,r0,r1
0002f6  60a8              STR      r0,[r5,#8]
;;;575    
;;;576    	if(LPC_USB->EPINUSE & (0x1U << EPAdr(EPNum)) )
0002f8  4620              MOV      r0,r4
0002fa  f7fffffe          BL       EPAdr
0002fe  2101              MOVS     r1,#1
000300  4081              LSLS     r1,r1,r0
000302  4846              LDR      r0,|L1.1052|
000304  6980              LDR      r0,[r0,#0x18]
000306  4201              TST      r1,r0
000308  d000              BEQ      |L1.780|
;;;577    	{
;;;578    	addr++;
00030a  1d2d              ADDS     r5,r5,#4
                  |L1.780|
;;;579    	}
;;;580    	*addr |= EP_RESET;
00030c  2101              MOVS     r1,#1
00030e  0709              LSLS     r1,r1,#28
000310  6828              LDR      r0,[r5,#0]
000312  4308              ORRS     r0,r0,r1
000314  6028              STR      r0,[r5,#0]
;;;581    }
000316  bd70              POP      {r4-r6,pc}
;;;582    
                          ENDP

                  nsAPI_USB_SetStallEP PROC
;;;592    
;;;593    void nsAPI_USB_SetStallEP(U32 EPNum)
000318  b570              PUSH     {r4-r6,lr}
;;;594    {
00031a  4605              MOV      r5,r0
;;;595    	U32 *addr;
;;;596    
;;;597    	if((EPNum & 0x0F) == 0)
00031c  0728              LSLS     r0,r5,#28
00031e  0f00              LSRS     r0,r0,#28
000320  d111              BNE      |L1.838|
;;;598    	{
;;;599    		/* For EP0 IN or OUT, simply clear the ACTIVE and set the STALL bit. */
;;;600    		addr = (U32 *)USB_GetEPCmdStatusPtr(EPNum);
000322  4628              MOV      r0,r5
000324  f7fffffe          BL       USB_GetEPCmdStatusPtr
000328  4604              MOV      r4,r0
;;;601    		/* STALL bit can't be set until ACTIVE bit is gone. For EP0,
;;;602    		SKIP register won't do. Force ACTIVE bit to low if it's set. */
;;;603    		if(*addr & BUF_ACTIVE)
00032a  6820              LDR      r0,[r4,#0]
00032c  0fc0              LSRS     r0,r0,#31
00032e  07c0              LSLS     r0,r0,#31
000330  d003              BEQ      |L1.826|
;;;604    		{
;;;605    			*addr &= ~BUF_ACTIVE;
000332  6820              LDR      r0,[r4,#0]
000334  0040              LSLS     r0,r0,#1
000336  0840              LSRS     r0,r0,#1
000338  6020              STR      r0,[r4,#0]
                  |L1.826|
;;;606    		}
;;;607    		*addr |= EP_STALL;
00033a  2101              MOVS     r1,#1
00033c  0749              LSLS     r1,r1,#29
00033e  6820              LDR      r0,[r4,#0]
000340  4308              ORRS     r0,r0,r1
000342  6020              STR      r0,[r4,#0]
000344  e02a              B        |L1.924|
                  |L1.838|
;;;608    	}
;;;609    	else
;;;610    	{
;;;611    		/* For non-zero EPs, deactivate the EP first, clear the ACTIVE bit
;;;612    		before setting the STALL bit. It applies to both buffer 0 and 1 if
;;;613    		double buffer is enabled. */
;;;614    		nsAPI_USB_DeactivateEP(EPNum);
000346  4628              MOV      r0,r5
000348  f7fffffe          BL       nsAPI_USB_DeactivateEP
;;;615    		addr = (U32 *)USB_GetEPCmdStatusPtr(EPNum);
00034c  4628              MOV      r0,r5
00034e  f7fffffe          BL       USB_GetEPCmdStatusPtr
000352  4604              MOV      r4,r0
;;;616    
;;;617    		if(*addr & BUF_ACTIVE)
000354  6820              LDR      r0,[r4,#0]
000356  0fc0              LSRS     r0,r0,#31
000358  07c0              LSLS     r0,r0,#31
00035a  d003              BEQ      |L1.868|
;;;618    		{
;;;619    			*addr &= ~BUF_ACTIVE;
00035c  6820              LDR      r0,[r4,#0]
00035e  0040              LSLS     r0,r0,#1
000360  0840              LSRS     r0,r0,#1
000362  6020              STR      r0,[r4,#0]
                  |L1.868|
;;;620    		}
;;;621    
;;;622    		*addr |= EP_STALL;/* STALL on buffer 0. */
000364  2101              MOVS     r1,#1
000366  0749              LSLS     r1,r1,#29
000368  6820              LDR      r0,[r4,#0]
00036a  4308              ORRS     r0,r0,r1
00036c  6020              STR      r0,[r4,#0]
;;;623    
;;;624    		if(LPC_USB->EPBUFCFG & (0x1U << EPAdr(EPNum)))
00036e  4628              MOV      r0,r5
000370  f7fffffe          BL       EPAdr
000374  2101              MOVS     r1,#1
000376  4081              LSLS     r1,r1,r0
000378  4828              LDR      r0,|L1.1052|
00037a  69c0              LDR      r0,[r0,#0x1c]
00037c  4201              TST      r1,r0
00037e  d00d              BEQ      |L1.924|
;;;625    		{
;;;626    			/* If double buffer is enabled, STALL on buffer 1. */
;;;627    			addr++;
000380  1d24              ADDS     r4,r4,#4
;;;628    			if(*addr & BUF_ACTIVE)
000382  6820              LDR      r0,[r4,#0]
000384  0fc0              LSRS     r0,r0,#31
000386  07c0              LSLS     r0,r0,#31
000388  d003              BEQ      |L1.914|
;;;629    			{
;;;630    				*addr &= ~BUF_ACTIVE;
00038a  6820              LDR      r0,[r4,#0]
00038c  0040              LSLS     r0,r0,#1
00038e  0840              LSRS     r0,r0,#1
000390  6020              STR      r0,[r4,#0]
                  |L1.914|
;;;631    			}
;;;632    			*addr |= EP_STALL;
000392  2101              MOVS     r1,#1
000394  0749              LSLS     r1,r1,#29
000396  6820              LDR      r0,[r4,#0]
000398  4308              ORRS     r0,r0,r1
00039a  6020              STR      r0,[r4,#0]
                  |L1.924|
;;;633    		}
;;;634    	}
;;;635    }
00039c  bd70              POP      {r4-r6,pc}
;;;636    
                          ENDP

                  nsAPI_USB_ClrStallEP PROC
;;;652    
;;;653    void nsAPI_USB_ClrStallEP(U32 EPNum)
00039e  b570              PUSH     {r4-r6,lr}
;;;654    {
0003a0  4604              MOV      r4,r0
;;;655    	U32 *addr,index;
;;;656    	index = EPAdr(EPNum);
0003a2  4620              MOV      r0,r4
0003a4  f7fffffe          BL       EPAdr
0003a8  4606              MOV      r6,r0
;;;657    
;;;658    	if((EPNum & 0x0F) == 0)
0003aa  0720              LSLS     r0,r4,#28
0003ac  0f00              LSRS     r0,r0,#28
0003ae  d109              BNE      |L1.964|
;;;659    	{
;;;660    		/* For EP0 IN and OUT, simply clear the STALL bit. */
;;;661    		addr = (U32 *)USB_GetEPCmdStatusPtr(EPNum);
0003b0  4620              MOV      r0,r4
0003b2  f7fffffe          BL       USB_GetEPCmdStatusPtr
0003b6  4605              MOV      r5,r0
;;;662    		*addr &= ~EP_STALL;
0003b8  2001              MOVS     r0,#1
0003ba  0740              LSLS     r0,r0,#29
0003bc  6829              LDR      r1,[r5,#0]
0003be  4381              BICS     r1,r1,r0
0003c0  6029              STR      r1,[r5,#0]
0003c2  e053              B        |L1.1132|
                  |L1.964|
;;;663    	}
;;;664    	else
;;;665    	{
;;;666    		addr = (U32 *)USB_GetEPCmdStatusPtr(EPNum);
0003c4  4620              MOV      r0,r4
0003c6  f7fffffe          BL       USB_GetEPCmdStatusPtr
0003ca  4605              MOV      r5,r0
;;;667    		/* For non-zero EPs if double buffer, both STALL bits should be cleared. */
;;;668    		*addr &= ~EP_STALL;
0003cc  2001              MOVS     r0,#1
0003ce  0740              LSLS     r0,r0,#29
0003d0  6829              LDR      r1,[r5,#0]
0003d2  4381              BICS     r1,r1,r0
0003d4  6029              STR      r1,[r5,#0]
;;;669    		*(addr+1) &= ~EP_STALL;
0003d6  6869              LDR      r1,[r5,#4]
0003d8  4381              BICS     r1,r1,r0
0003da  6069              STR      r1,[r5,#4]
;;;670    
;;;671    		/* Based on EPInUse register to decide which buffer needs to toggle reset. */
;;;672    		if(LPC_USB->EPINUSE & (0x1U << index))
0003dc  480f              LDR      r0,|L1.1052|
0003de  6981              LDR      r1,[r0,#0x18]
0003e0  2001              MOVS     r0,#1
0003e2  40b0              LSLS     r0,r0,r6
0003e4  4201              TST      r1,r0
0003e6  d000              BEQ      |L1.1002|
;;;673    		{
;;;674    			/* Buffer 1 is in use. Toggle Reset Buffer 1, otherwise, toggle Reset
;;;675    			buffer 0. */
;;;676    			addr++;
0003e8  1d2d              ADDS     r5,r5,#4
                  |L1.1002|
;;;677    		}
;;;678    
;;;679    		*addr |= EP_RESET;
0003ea  2101              MOVS     r1,#1
0003ec  0709              LSLS     r1,r1,#28
0003ee  6828              LDR      r0,[r5,#0]
0003f0  4308              ORRS     r0,r0,r1
0003f2  6028              STR      r0,[r5,#0]
;;;680    		if(!(EPNum & 0x80))
0003f4  2080              MOVS     r0,#0x80
0003f6  4204              TST      r4,r0
0003f8  d126              BNE      |L1.1096|
;;;681    		{
;;;682    			/* For non-zero EP OUT, ACTIVE bit and length field need to
;;;683    			be set again after clearing STALL. */
;;;684    			*addr &= ~(PKT_LNGTH_MASK << 16);
0003fa  4911              LDR      r1,|L1.1088|
0003fc  6828              LDR      r0,[r5,#0]
0003fe  4008              ANDS     r0,r0,r1
000400  6028              STR      r0,[r5,#0]
;;;685    #if USB_ISO_COMMUNICATION
;;;686    			*addr |= ((USB_MAX_ISO_SIZE << 16) | BUF_ACTIVE);
;;;687    #else
;;;688    			*addr |= ((USB_MAX_NON_ISO_SIZE << 16) | BUF_ACTIVE);
000402  4910              LDR      r1,|L1.1092|
000404  6828              LDR      r0,[r5,#0]
000406  4308              ORRS     r0,r0,r1
000408  6028              STR      r0,[r5,#0]
00040a  e02f              B        |L1.1132|
                  |L1.1036|
                          DCD      0x40048080
                  |L1.1040|
                          DCD      0x08004000
                  |L1.1044|
                          DCD      0x40044000
                  |L1.1048|
                          DCD      0x10001800
                  |L1.1052|
                          DCD      0x40080000
                  |L1.1056|
                          DCD      0x10001900
                  |L1.1060|
                          DCD      g_USBHW_Setting+0x8
                  |L1.1064|
                          DCD      0x40400000
                  |L1.1068|
                          DCD      0xc00003ff
                  |L1.1072|
                          DCD      0x800003ff
                  |L1.1076|
                          DCD      0xe000e180
                  |L1.1080|
                          DCD      g_USBCore_Setting
                  |L1.1084|
                          DCD      0x80000003
                  |L1.1088|
                          DCD      0xfc00ffff
                  |L1.1092|
                          DCD      0x80400000
                  |L1.1096|
;;;689    #endif
;;;690    		}
;;;691    		else
;;;692    		{
;;;693    			/* For non-zero EP IN, the EPActiveFlag will be set when WriteEP() happens
;;;694    			while STALL is set. If so, when ClearSTALL happens, set the ACTIVE bit that
;;;695    			data buffer is ready to write data to the EPs. */
;;;696    			if(g_USBHW_Setting.EPActiveFlag & (0x1U << index))
000448  48fa              LDR      r0,|L1.2100|
00044a  6841              LDR      r1,[r0,#4]  ; g_USBHW_Setting
00044c  2001              MOVS     r0,#1
00044e  40b0              LSLS     r0,r0,r6
000450  4201              TST      r1,r0
000452  d00b              BEQ      |L1.1132|
;;;697    			{
;;;698    				*addr |= BUF_ACTIVE;
000454  2101              MOVS     r1,#1
000456  07c9              LSLS     r1,r1,#31
000458  6828              LDR      r0,[r5,#0]
00045a  4308              ORRS     r0,r0,r1
00045c  6028              STR      r0,[r5,#0]
;;;699    				g_USBHW_Setting.EPActiveFlag &= ~(0x1U << index);
00045e  48f5              LDR      r0,|L1.2100|
000460  6841              LDR      r1,[r0,#4]  ; g_USBHW_Setting
000462  2001              MOVS     r0,#1
000464  40b0              LSLS     r0,r0,r6
000466  4381              BICS     r1,r1,r0
000468  48f2              LDR      r0,|L1.2100|
00046a  6041              STR      r1,[r0,#4]  ; g_USBHW_Setting
                  |L1.1132|
;;;700    			}
;;;701    		}
;;;702    	}
;;;703    }
00046c  bd70              POP      {r4-r6,pc}
;;;704    
                          ENDP

                  nsAPI_USB_ReadSetupEP PROC
;;;713    
;;;714    void nsAPI_USB_ReadSetupEP(U32 EPNum, U8 *pData)
00046e  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;715    {
000470  b081              SUB      sp,sp,#4
000472  460c              MOV      r4,r1
;;;716    	U32 cnt, n,*addr,*dataptr;
;;;717    
;;;718    
;;;719    	addr = (U32 *)USB_GetEPCmdStatusPtr( EPNum );
000474  9801              LDR      r0,[sp,#4]
000476  f7fffffe          BL       USB_GetEPCmdStatusPtr
00047a  4607              MOV      r7,r0
;;;720    
;;;721    	/* Check/Clear STALL on both EP0 IN and OUT when SETUP is received. */
;;;722    	if((*addr & EP_STALL) || ((*addr+2) & EP_STALL))
00047c  2101              MOVS     r1,#1
00047e  0749              LSLS     r1,r1,#29
000480  6838              LDR      r0,[r7,#0]
000482  4208              TST      r0,r1
000484  d103              BNE      |L1.1166|
000486  6838              LDR      r0,[r7,#0]
000488  1c80              ADDS     r0,r0,#2
00048a  4208              TST      r0,r1
00048c  d007              BEQ      |L1.1182|
                  |L1.1166|
;;;723    	{
;;;724    		*addr &= ~EP_STALL;
00048e  2101              MOVS     r1,#1
000490  0749              LSLS     r1,r1,#29
000492  6838              LDR      r0,[r7,#0]
000494  4388              BICS     r0,r0,r1
000496  6038              STR      r0,[r7,#0]
;;;725    		*(addr+2) &= ~EP_STALL;
000498  68b8              LDR      r0,[r7,#8]
00049a  4388              BICS     r0,r0,r1
00049c  60b8              STR      r0,[r7,#8]
                  |L1.1182|
;;;726    	}
;;;727    
;;;728    	cnt = USB_SETUP_PACKET_SIZE;
00049e  2508              MOVS     r5,#8
;;;729    	dataptr = (U32 *)g_USBHW_Setting.EPList[1].buf_ptr;
0004a0  48e4              LDR      r0,|L1.2100|
0004a2  6900              LDR      r0,[r0,#0x10]
0004a4  9000              STR      r0,[sp,#0]
;;;730    
;;;731    	for (n = 0; n < (cnt + 3) / 4; n++)
0004a6  2600              MOVS     r6,#0
0004a8  e009              B        |L1.1214|
                  |L1.1194|
;;;732    	{
;;;733    		*((__packed U32 *)pData) = *((__packed U32 *)dataptr);
0004aa  9900              LDR      r1,[sp,#0]
0004ac  6808              LDR      r0,[r1,#0]
0004ae  4621              MOV      r1,r4
0004b0  f7fffffe          BL       __aeabi_uwrite4
;;;734    		pData += 4;
0004b4  1d24              ADDS     r4,r4,#4
;;;735    		dataptr++;
0004b6  9800              LDR      r0,[sp,#0]
0004b8  1d00              ADDS     r0,r0,#4
0004ba  9000              STR      r0,[sp,#0]
0004bc  1c76              ADDS     r6,r6,#1              ;731
                  |L1.1214|
0004be  1ce8              ADDS     r0,r5,#3              ;731
0004c0  0880              LSRS     r0,r0,#2              ;731
0004c2  42b0              CMP      r0,r6                 ;731
0004c4  d8f1              BHI      |L1.1194|
;;;736    	}
;;;737    
;;;738    	addr++;		/* Use EP0 buffer 1 for SETUP packet */
0004c6  1d3f              ADDS     r7,r7,#4
;;;739    	/* Fixed Command/Status location(EPList[1] for SETUP. Reset buffer pointer
;;;740    	field, SETUP length is fixed with eight bytes. */
;;;741    	*addr &= ~0x3FFFFFF;
0004c8  6838              LDR      r0,[r7,#0]
0004ca  0e80              LSRS     r0,r0,#26
0004cc  0680              LSLS     r0,r0,#26
0004ce  6038              STR      r0,[r7,#0]
;;;742    	*addr |= (U16)((g_USBHW_Setting.EPList[1].buf_ptr) >> 6);
0004d0  48d8              LDR      r0,|L1.2100|
0004d2  6839              LDR      r1,[r7,#0]
0004d4  6900              LDR      r0,[r0,#0x10]
0004d6  0280              LSLS     r0,r0,#10
0004d8  0c00              LSRS     r0,r0,#16
0004da  4301              ORRS     r1,r1,r0
0004dc  6039              STR      r1,[r7,#0]
;;;743    
;;;744    	//return (cnt);
;;;745    }
0004de  bdfe              POP      {r1-r7,pc}
;;;746    
                          ENDP

                  nsAPI_USB_ReadEP PROC
;;;755    
;;;756    RetU32 nsAPI_USB_ReadEP(U32 EPNum, U8 *pData)
0004e0  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;757    {
0004e2  b085              SUB      sp,sp,#0x14
0004e4  4604              MOV      r4,r0
;;;758    	U32 cnt, n,*addr,buf_flag,*dataptr,index[2] = {0};
0004e6  a801              ADD      r0,sp,#4
0004e8  2100              MOVS     r1,#0
0004ea  460a              MOV      r2,r1
0004ec  c006              STM      r0!,{r1,r2}
;;;759    
;;;760    	addr = (U32 *)USB_GetEPCmdStatusPtr(EPNum);
0004ee  4620              MOV      r0,r4
0004f0  f7fffffe          BL       USB_GetEPCmdStatusPtr
0004f4  4607              MOV      r7,r0
;;;761    	index[0] = EPAdr(EPNum);
0004f6  4620              MOV      r0,r4
0004f8  f7fffffe          BL       EPAdr
0004fc  9001              STR      r0,[sp,#4]
;;;762    	index[1] = EPAdr(EPNum) * 2;/* Double buffer is considered. */
0004fe  4620              MOV      r0,r4
000500  f7fffffe          BL       EPAdr
000504  0040              LSLS     r0,r0,#1
000506  9002              STR      r0,[sp,#8]
;;;763    	if(EPNum & 0x0F)
000508  0720              LSLS     r0,r4,#28
00050a  0f00              LSRS     r0,r0,#28
00050c  d00d              BEQ      |L1.1322|
;;;764    	{
;;;765    		/* For EP0 IN/OUT, there is no double buffer. For non-zero
;;;766    		EP, double buffer is considered. If BufferUsed bit mask is set,
;;;767    		buffer0 is used, switch to buffer 1, index needs to be changed
;;;768    		accordingly too. */
;;;769    		buf_flag = g_USBHW_Setting.BufferUsed & (0x1U << index[0]);
00050e  48c9              LDR      r0,|L1.2100|
000510  6801              LDR      r1,[r0,#0]  ; g_USBHW_Setting
000512  2001              MOVS     r0,#1
000514  9a01              LDR      r2,[sp,#4]
000516  4090              LSLS     r0,r0,r2
000518  4001              ANDS     r1,r1,r0
00051a  9104              STR      r1,[sp,#0x10]
;;;770    
;;;771    		if(buf_flag != 0)
00051c  9904              LDR      r1,[sp,#0x10]
00051e  2900              CMP      r1,#0
000520  d003              BEQ      |L1.1322|
;;;772    		{
;;;773    			addr++;/* Use buffer 1 */
000522  1d3f              ADDS     r7,r7,#4
;;;774    			index[1]++;
000524  9802              LDR      r0,[sp,#8]
000526  1c40              ADDS     r0,r0,#1
000528  9002              STR      r0,[sp,#8]
                  |L1.1322|
;;;775    		}
;;;776    	}
;;;777    
;;;778    	cnt = (*addr >> 16) & PKT_LNGTH_MASK;
00052a  6838              LDR      r0,[r7,#0]
00052c  0180              LSLS     r0,r0,#6
00052e  0d85              LSRS     r5,r0,#22
;;;779    	/* The NBytes field decrements by H/W with the packet byte each time. */
;;;780    	cnt = g_USBHW_Setting.EPList[index[1]].buf_length - cnt;
000530  9802              LDR      r0,[sp,#8]
000532  00c1              LSLS     r1,r0,#3
000534  48bf              LDR      r0,|L1.2100|
000536  3008              ADDS     r0,r0,#8
000538  1808              ADDS     r0,r1,r0
00053a  6840              LDR      r0,[r0,#4]
00053c  1b45              SUBS     r5,r0,r5
;;;781    	dataptr = (uint32_t *)g_USBHW_Setting.EPList[index[1]].buf_ptr;
00053e  9802              LDR      r0,[sp,#8]
000540  00c1              LSLS     r1,r0,#3
000542  48bc              LDR      r0,|L1.2100|
000544  3008              ADDS     r0,r0,#8
000546  5840              LDR      r0,[r0,r1]
000548  9003              STR      r0,[sp,#0xc]
;;;782    	for(n = 0; n < (cnt + 3) / 4; n++)
00054a  2600              MOVS     r6,#0
00054c  e00b              B        |L1.1382|
                  |L1.1358|
;;;783    	{
;;;784    		*((__packed uint32_t *)pData) = *((__packed uint32_t *)dataptr);
00054e  9903              LDR      r1,[sp,#0xc]
000550  6808              LDR      r0,[r1,#0]
000552  9906              LDR      r1,[sp,#0x18]
000554  f7fffffe          BL       __aeabi_uwrite4
;;;785    		pData += 4;
000558  9806              LDR      r0,[sp,#0x18]
00055a  1d00              ADDS     r0,r0,#4
00055c  9006              STR      r0,[sp,#0x18]
;;;786    		dataptr++;
00055e  9803              LDR      r0,[sp,#0xc]
000560  1d00              ADDS     r0,r0,#4
000562  9003              STR      r0,[sp,#0xc]
000564  1c76              ADDS     r6,r6,#1              ;782
                  |L1.1382|
000566  1ce8              ADDS     r0,r5,#3              ;782
000568  0880              LSRS     r0,r0,#2              ;782
00056a  42b0              CMP      r0,r6                 ;782
00056c  d8ef              BHI      |L1.1358|
;;;787    	}
;;;788    
;;;789    	/* Clear buffer after EP read, reset EP length and buffer pointer field */
;;;790    	*addr &= ~0x3FFFFFF;
00056e  6838              LDR      r0,[r7,#0]
000570  0e80              LSRS     r0,r0,#26
000572  0680              LSLS     r0,r0,#26
000574  6038              STR      r0,[r7,#0]
;;;791    	if((EPNum & 0x0F) == 0)
000576  0720              LSLS     r0,r4,#28
000578  0f00              LSRS     r0,r0,#28
00057a  d115              BNE      |L1.1448|
;;;792    	{
;;;793    		/* EP0 is single buffer only. */
;;;794    		*addr |= ((g_USBHW_Setting.EPList[index[1]].buf_length << 16)
00057c  9802              LDR      r0,[sp,#8]
00057e  00c1              LSLS     r1,r0,#3
000580  48ac              LDR      r0,|L1.2100|
000582  3008              ADDS     r0,r0,#8
000584  1808              ADDS     r0,r1,r0
000586  6840              LDR      r0,[r0,#4]
000588  0401              LSLS     r1,r0,#16
00058a  9802              LDR      r0,[sp,#8]
00058c  00c2              LSLS     r2,r0,#3
00058e  48a9              LDR      r0,|L1.2100|
000590  3008              ADDS     r0,r0,#8
000592  5880              LDR      r0,[r0,r2]
000594  0280              LSLS     r0,r0,#10
000596  0c00              LSRS     r0,r0,#16
000598  4301              ORRS     r1,r1,r0
00059a  2001              MOVS     r0,#1
00059c  07c0              LSLS     r0,r0,#31
00059e  4301              ORRS     r1,r1,r0
0005a0  6838              LDR      r0,[r7,#0]
0005a2  4301              ORRS     r1,r1,r0
0005a4  6039              STR      r1,[r7,#0]
0005a6  e039              B        |L1.1564|
                  |L1.1448|
;;;795    		| (uint16_t)((g_USBHW_Setting.EPList[index[1]].buf_ptr) >> 6) | BUF_ACTIVE);
;;;796    	}
;;;797    	else
;;;798    	{
;;;799    		/* Toggle buffer if double buffer is used for non-zero EPs.  */
;;;800    		g_USBHW_Setting.BufferUsed ^= (0x1U << index[0]);
0005a8  48a2              LDR      r0,|L1.2100|
0005aa  6801              LDR      r1,[r0,#0]  ; g_USBHW_Setting
0005ac  2001              MOVS     r0,#1
0005ae  9a01              LDR      r2,[sp,#4]
0005b0  4090              LSLS     r0,r0,r2
0005b2  4041              EORS     r1,r1,r0
0005b4  489f              LDR      r0,|L1.2100|
0005b6  6001              STR      r1,[r0,#0]  ; g_USBHW_Setting
;;;801    		g_USBHW_Setting.BufferUsed &= LPC_USB->EPBUFCFG;
0005b8  6800              LDR      r0,[r0,#0]  ; g_USBHW_Setting
0005ba  499f              LDR      r1,|L1.2104|
0005bc  69c9              LDR      r1,[r1,#0x1c]
0005be  4008              ANDS     r0,r0,r1
0005c0  499c              LDR      r1,|L1.2100|
0005c2  6008              STR      r0,[r1,#0]  ; g_USBHW_Setting
;;;802    
;;;803    		if(LPC_USB->EPBUFCFG & (0x1U << index[0]))
0005c4  489c              LDR      r0,|L1.2104|
0005c6  69c1              LDR      r1,[r0,#0x1c]
0005c8  2001              MOVS     r0,#1
0005ca  9a01              LDR      r2,[sp,#4]
0005cc  4090              LSLS     r0,r0,r2
0005ce  4201              TST      r1,r0
0005d0  d00f              BEQ      |L1.1522|
;;;804    		{
;;;805    			if(g_USBHW_Setting.BufferUsed & (0x1U << index[0]))
0005d2  4898              LDR      r0,|L1.2100|
0005d4  6801              LDR      r1,[r0,#0]  ; g_USBHW_Setting
0005d6  2001              MOVS     r0,#1
0005d8  9a01              LDR      r2,[sp,#4]
0005da  4090              LSLS     r0,r0,r2
0005dc  4201              TST      r1,r0
0005de  d004              BEQ      |L1.1514|
;;;806    			{
;;;807    				addr++;/* Set buffer 1 ACTIVE */
0005e0  1d3f              ADDS     r7,r7,#4
;;;808    				index[1]++;
0005e2  9802              LDR      r0,[sp,#8]
0005e4  1c40              ADDS     r0,r0,#1
0005e6  9002              STR      r0,[sp,#8]
0005e8  e003              B        |L1.1522|
                  |L1.1514|
;;;809    			}
;;;810    			else
;;;811    			{
;;;812    				addr--;/* Set buffer 0 ACTIVE */
0005ea  1f3f              SUBS     r7,r7,#4
;;;813    				index[1]--;
0005ec  9802              LDR      r0,[sp,#8]
0005ee  1e40              SUBS     r0,r0,#1
0005f0  9002              STR      r0,[sp,#8]
                  |L1.1522|
;;;814    			}
;;;815    		}
;;;816    		*addr |= ((g_USBHW_Setting.EPList[index[1]].buf_length << 16)
0005f2  9802              LDR      r0,[sp,#8]
0005f4  00c1              LSLS     r1,r0,#3
0005f6  488f              LDR      r0,|L1.2100|
0005f8  3008              ADDS     r0,r0,#8
0005fa  1808              ADDS     r0,r1,r0
0005fc  6840              LDR      r0,[r0,#4]
0005fe  0401              LSLS     r1,r0,#16
000600  9802              LDR      r0,[sp,#8]
000602  00c2              LSLS     r2,r0,#3
000604  488b              LDR      r0,|L1.2100|
000606  3008              ADDS     r0,r0,#8
000608  5880              LDR      r0,[r0,r2]
00060a  0280              LSLS     r0,r0,#10
00060c  0c00              LSRS     r0,r0,#16
00060e  4301              ORRS     r1,r1,r0
000610  2001              MOVS     r0,#1
000612  07c0              LSLS     r0,r0,#31
000614  4301              ORRS     r1,r1,r0
000616  6838              LDR      r0,[r7,#0]
000618  4301              ORRS     r1,r1,r0
00061a  6039              STR      r1,[r7,#0]
                  |L1.1564|
;;;817    		| (U16)((g_USBHW_Setting.EPList[index[1]].buf_ptr) >> 6) | BUF_ACTIVE);
;;;818    	}
;;;819    	return (cnt);
00061c  4628              MOV      r0,r5
;;;820    }
00061e  b007              ADD      sp,sp,#0x1c
000620  bdf0              POP      {r4-r7,pc}
;;;821    
                          ENDP

                  nsAPI_USB_WriteEP PROC
;;;834    
;;;835    RetU32 nsAPI_USB_WriteEP(U32 EPNum,U8 *pData,U32 cnt)
000622  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;836    {
000624  b084              SUB      sp,sp,#0x10
000626  4604              MOV      r4,r0
000628  4615              MOV      r5,r2
;;;837    	U32 n, index[2],*addr,*dataptr;
;;;838    
;;;839    	addr = (U32*)USB_GetEPCmdStatusPtr( EPNum );
00062a  4620              MOV      r0,r4
00062c  f7fffffe          BL       USB_GetEPCmdStatusPtr
000630  4607              MOV      r7,r0
;;;840    
;;;841    	index[0] = EPAdr(EPNum);
000632  4620              MOV      r0,r4
000634  f7fffffe          BL       EPAdr
000638  9002              STR      r0,[sp,#8]
;;;842    	index[1] = index[0] * 2;/* Double buffer is considered. */
00063a  9802              LDR      r0,[sp,#8]
00063c  0040              LSLS     r0,r0,#1
00063e  9003              STR      r0,[sp,#0xc]
;;;843    
;;;844    	if(!(EPNum & 0x0F))
000640  0720              LSLS     r0,r4,#28
000642  0f00              LSRS     r0,r0,#28
000644  d10e              BNE      |L1.1636|
;;;845    	{
;;;846    		/* When EP0 IN is received, set ACTIVE bit on both EP0 IN
;;;847    		and OUT. */
;;;848    		*addr &= ~EP_STALL;
000646  2101              MOVS     r1,#1
000648  0749              LSLS     r1,r1,#29
00064a  6838              LDR      r0,[r7,#0]
00064c  4388              BICS     r0,r0,r1
00064e  6038              STR      r0,[r7,#0]
;;;849    		*(addr-2) |= BUF_ACTIVE;	/* Set ACTIVE bit on EP0 OUT */
000650  4638              MOV      r0,r7
000652  3840              SUBS     r0,r0,#0x40
000654  6b81              LDR      r1,[r0,#0x38]
000656  2001              MOVS     r0,#1
000658  07c0              LSLS     r0,r0,#31
00065a  4301              ORRS     r1,r1,r0
00065c  4638              MOV      r0,r7
00065e  3840              SUBS     r0,r0,#0x40
000660  6381              STR      r1,[r0,#0x38]
000662  e011              B        |L1.1672|
                  |L1.1636|
;;;850    	}
;;;851    	else
;;;852    	{
;;;853    		/* For non-zero EPs, if double buffer is used and EPInUse is set, buffer0
;;;854    		is used, otherwise, buffer1 is used. */
;;;855    		if(LPC_USB->EPBUFCFG & (0x1U << index[0]) )
000664  4874              LDR      r0,|L1.2104|
000666  69c1              LDR      r1,[r0,#0x1c]
000668  2001              MOVS     r0,#1
00066a  9a02              LDR      r2,[sp,#8]
00066c  4090              LSLS     r0,r0,r2
00066e  4201              TST      r1,r0
000670  d00a              BEQ      |L1.1672|
;;;856    		{
;;;857    			if(LPC_USB->EPINUSE & (0x1U << index[0]) )
000672  4871              LDR      r0,|L1.2104|
000674  6981              LDR      r1,[r0,#0x18]
000676  2001              MOVS     r0,#1
000678  9a02              LDR      r2,[sp,#8]
00067a  4090              LSLS     r0,r0,r2
00067c  4201              TST      r1,r0
00067e  d003              BEQ      |L1.1672|
;;;858    			{
;;;859    				addr++;/* move to buffer1 address in EP command/status list. */
000680  1d3f              ADDS     r7,r7,#4
;;;860    				index[1]++;
000682  9803              LDR      r0,[sp,#0xc]
000684  1c40              ADDS     r0,r0,#1
000686  9003              STR      r0,[sp,#0xc]
                  |L1.1672|
;;;861    			}
;;;862    		}
;;;863    	}
;;;864    
;;;865    	/* Get EP command/status List, update the length field and data pointer. */
;;;866    	*addr &= ~0x3FFFFFF;
000688  6838              LDR      r0,[r7,#0]
00068a  0e80              LSRS     r0,r0,#26
00068c  0680              LSLS     r0,r0,#26
00068e  6038              STR      r0,[r7,#0]
;;;867    	cnt &= PKT_LNGTH_MASK;
000690  05ad              LSLS     r5,r5,#22
000692  0dad              LSRS     r5,r5,#22
;;;868    	*addr |= (cnt << 16)|(U16)((g_USBHW_Setting.EPList[index[1]].buf_ptr) >> 6);
000694  0429              LSLS     r1,r5,#16
000696  9803              LDR      r0,[sp,#0xc]
000698  00c2              LSLS     r2,r0,#3
00069a  4866              LDR      r0,|L1.2100|
00069c  3008              ADDS     r0,r0,#8
00069e  5880              LDR      r0,[r0,r2]
0006a0  0280              LSLS     r0,r0,#10
0006a2  0c00              LSRS     r0,r0,#16
0006a4  4301              ORRS     r1,r1,r0
0006a6  6838              LDR      r0,[r7,#0]
0006a8  4301              ORRS     r1,r1,r0
0006aa  6039              STR      r1,[r7,#0]
;;;869    
;;;870    	dataptr = (U32 *)g_USBHW_Setting.EPList[index[1]].buf_ptr;
0006ac  9803              LDR      r0,[sp,#0xc]
0006ae  00c1              LSLS     r1,r0,#3
0006b0  4860              LDR      r0,|L1.2100|
0006b2  3008              ADDS     r0,r0,#8
0006b4  5840              LDR      r0,[r0,r1]
0006b6  9001              STR      r0,[sp,#4]
;;;871    	/* Stuff the data first, whether send out or not(set ACTIVE bit) is based on STALL condition. */
;;;872    	for (n = 0; n < (cnt + 3) / 4; n++)
0006b8  2600              MOVS     r6,#0
0006ba  e00b              B        |L1.1748|
                  |L1.1724|
;;;873    	{
;;;874    		*((__packed U32 *)dataptr) = *((__packed U32 *)pData);
0006bc  9805              LDR      r0,[sp,#0x14]
0006be  f7fffffe          BL       __aeabi_uread4
0006c2  9901              LDR      r1,[sp,#4]
0006c4  6008              STR      r0,[r1,#0]
;;;875    		pData += 4;
0006c6  9805              LDR      r0,[sp,#0x14]
0006c8  1d00              ADDS     r0,r0,#4
0006ca  9005              STR      r0,[sp,#0x14]
;;;876    		dataptr++;
0006cc  9801              LDR      r0,[sp,#4]
0006ce  1d00              ADDS     r0,r0,#4
0006d0  9001              STR      r0,[sp,#4]
0006d2  1c76              ADDS     r6,r6,#1              ;872
                  |L1.1748|
0006d4  1ce8              ADDS     r0,r5,#3              ;872
0006d6  0880              LSRS     r0,r0,#2              ;872
0006d8  42b0              CMP      r0,r6                 ;872
0006da  d8ef              BHI      |L1.1724|
;;;877    	}
;;;878    
;;;879    	if((*addr & EP_STALL) && (EPNum & 0x0F))
0006dc  2101              MOVS     r1,#1
0006de  0749              LSLS     r1,r1,#29
0006e0  6838              LDR      r0,[r7,#0]
0006e2  4208              TST      r0,r1
0006e4  d00d              BEQ      |L1.1794|
0006e6  0720              LSLS     r0,r4,#28
0006e8  0f00              LSRS     r0,r0,#28
0006ea  d00a              BEQ      |L1.1794|
;;;880    	{
;;;881    	 /* This is for MSC class when STALL occurs and non-zero EPs,
;;;882    		set the ACTIVE flag, but don't do anything until ClearFeature
;;;883    		to clear STALL, then tranfer the data. */
;;;884    		g_USBHW_Setting.EPActiveFlag |= (0x1U << index[0]);
0006ec  4851              LDR      r0,|L1.2100|
0006ee  6841              LDR      r1,[r0,#4]  ; g_USBHW_Setting
0006f0  2001              MOVS     r0,#1
0006f2  9a02              LDR      r2,[sp,#8]
0006f4  4090              LSLS     r0,r0,r2
0006f6  4301              ORRS     r1,r1,r0
0006f8  484e              LDR      r0,|L1.2100|
0006fa  6041              STR      r1,[r0,#4]  ; g_USBHW_Setting
;;;885    		return (cnt);
0006fc  4628              MOV      r0,r5
                  |L1.1790|
;;;886    	}
;;;887    
;;;888    	*addr |= BUF_ACTIVE;
;;;889    	return (cnt);
;;;890    }
0006fe  b007              ADD      sp,sp,#0x1c
000700  bdf0              POP      {r4-r7,pc}
                  |L1.1794|
000702  2101              MOVS     r1,#1                 ;888
000704  07c9              LSLS     r1,r1,#31             ;888
000706  6838              LDR      r0,[r7,#0]            ;888
000708  4308              ORRS     r0,r0,r1              ;888
00070a  6038              STR      r0,[r7,#0]            ;888
00070c  4628              MOV      r0,r5                 ;889
00070e  e7f6              B        |L1.1790|
;;;891    
                          ENDP

                  wnDrv_Usb_ClrGetReqStatus PROC
;;;892    void wnDrv_Usb_ClrGetReqStatus(U32 EPNum)
000710  b570              PUSH     {r4-r6,lr}
;;;893    {
000712  4604              MOV      r4,r0
;;;894    	U32 *addr;
;;;895    
;;;896    	addr = (U32*)USB_GetEPCmdStatusPtr(EPNum);
000714  4620              MOV      r0,r4
000716  f7fffffe          BL       USB_GetEPCmdStatusPtr
00071a  4605              MOV      r5,r0
;;;897    
;;;898    	*addr &=~ BUF_ACTIVE;
00071c  6828              LDR      r0,[r5,#0]
00071e  0040              LSLS     r0,r0,#1
000720  0840              LSRS     r0,r0,#1
000722  6028              STR      r0,[r5,#0]
;;;899    }
000724  bd70              POP      {r4-r6,pc}
;;;900    #if USB_FIQ_EVENT
                          ENDP

                  USB_IRQHandler PROC
;;;925    
;;;926    void USB_IRQHandler (void)
000726  b5f8              PUSH     {r3-r7,lr}
;;;927    {
;;;928      uint32_t disr, val, n, m;
;;;929    
;;;930      disr = LPC_USB->INTSTAT;         /* Get Interrupt Status and clear immediately. */
000728  4843              LDR      r0,|L1.2104|
00072a  6a04              LDR      r4,[r0,#0x20]
;;;931      LPC_USB->INTSTAT = disr;
00072c  6204              STR      r4,[r0,#0x20]
;;;932    
;;;933      /* Device Status Interrupt (Reset, Connect change, Suspend/Resume) */
;;;934      if (disr & DEV_STAT_INT) {
00072e  0fe0              LSRS     r0,r4,#31
000730  07c0              LSLS     r0,r0,#31
000732  d019              BEQ      |L1.1896|
;;;935        val = LPC_USB->DEVCMDSTAT;       /* Device Status */
000734  4840              LDR      r0,|L1.2104|
000736  6805              LDR      r5,[r0,#0]
;;;936    
;;;937        if (val & USB_DRESET_C) {               /* Reset */
000738  01c0              LSLS     r0,r0,#7
00073a  4205              TST      r5,r0
00073c  d003              BEQ      |L1.1862|
;;;938          NDrv_USB_Reset();
00073e  f7fffffe          BL       NDrv_USB_Reset
;;;939    #if   USB_RESET_EVENT
;;;940          USB_Reset_Event();
000742  f7fffffe          BL       USB_Reset_Event
                  |L1.1862|
;;;941    #endif
;;;942        }
;;;943        if (val & USB_DCON_C) {                 /* Connect change */
;;;944    #if   USB_POWER_EVENT
;;;945          USB_Power_Event(val & DEV_CON);
;;;946    #endif
;;;947        }
;;;948        if (val & USB_DSUS_C) {                 /* Suspend/Resume */
000746  2001              MOVS     r0,#1
000748  0640              LSLS     r0,r0,#25
00074a  4205              TST      r5,r0
00074c  d00b              BEQ      |L1.1894|
;;;949          if (val & USB_DSUS) {                 /* Suspend */
00074e  1200              ASRS     r0,r0,#8
000750  4205              TST      r5,r0
000752  d004              BEQ      |L1.1886|
;;;950            USB_Suspend();
000754  f7fffffe          BL       USB_Suspend
;;;951    #if     USB_SUSPEND_EVENT
;;;952            USB_Suspend_Event();
000758  f7fffffe          BL       USB_Suspend_Event
00075c  e003              B        |L1.1894|
                  |L1.1886|
;;;953    #endif
;;;954          } else {                              /* Resume */
;;;955            USB_Resume();
00075e  f7fffffe          BL       USB_Resume
;;;956    #if REMOTE_WAKEUP_ENABLE
;;;957            LPC_SYSCON->USBCLKCTRL = 0;
;;;958    #endif
;;;959    #if     USB_RESUME_EVENT
;;;960            USB_Resume_Event();
000762  f7fffffe          BL       USB_Resume_Event
                  |L1.1894|
;;;961    #endif
;;;962          }
;;;963        }
;;;964    #if LPM_SUPPORT
;;;965    	if (val & USB_LPM_SUS) {                /* LPM Suspend */
;;;966          DevStatusLPMSuspend++;
;;;967        }
;;;968    #endif
;;;969        goto isr_end;
000766  e041              B        |L1.2028|
                  |L1.1896|
;;;970      }
;;;971    
;;;972    #if USB_SOF_EVENT
;;;973      /* Start of Frame Interrupt */
;;;974      if (disr & FRAME_INT) {
;;;975        USB_SOF_Event();
;;;976    	SOFIRQCount++;
;;;977      }
;;;978    #endif
;;;979    
;;;980    
;;;981      /* Endpoint's Interrupt */
;;;982      if (disr & 0x3FF) {
000768  05a0              LSLS     r0,r4,#22
00076a  0d80              LSRS     r0,r0,#22
00076c  d03d              BEQ      |L1.2026|
;;;983    	/* if any of the EP0 through EP9 is set, or bit 0 through 9 on disr */
;;;984        for (n = 0; n < USB_EP_NUM; n++) {      /* Check All Endpoints */
00076e  2600              MOVS     r6,#0
000770  e039              B        |L1.2022|
                  |L1.1906|
;;;985    	  if (disr & (1 << n)) {
000772  2001              MOVS     r0,#1
000774  40b0              LSLS     r0,r0,r6
000776  4220              TST      r0,r4
000778  d033              BEQ      |L1.2018|
;;;986            m = n >> 1;
00077a  0877              LSRS     r7,r6,#1
;;;987            if ((n & 1) == 0) {                 /* OUT Endpoint */
00077c  07f0              LSLS     r0,r6,#31
00077e  0fc0              LSRS     r0,r0,#31
000780  d122              BNE      |L1.1992|
;;;988              if (n == 0) {                     /* Control OUT Endpoint */
000782  2e00              CMP      r6,#0
000784  d115              BNE      |L1.1970|
;;;989                if ( LPC_USB->DEVCMDSTAT & USB_SETUP_RCVD ) {
000786  482c              LDR      r0,|L1.2104|
000788  6800              LDR      r0,[r0,#0]
00078a  21ff              MOVS     r1,#0xff
00078c  3101              ADDS     r1,#1
00078e  4208              TST      r0,r1
000790  d00f              BEQ      |L1.1970|
;;;990     											/* Setup packet is received. */
;;;991                  if (USB_P_EP[0]) {
000792  482a              LDR      r0,|L1.2108|
000794  6800              LDR      r0,[r0,#0]  ; USB_P_EP
000796  2800              CMP      r0,#0
000798  d00b              BEQ      |L1.1970|
;;;992                    USB_P_EP[0](USB_EVT_SETUP);
00079a  4828              LDR      r0,|L1.2108|
00079c  6801              LDR      r1,[r0,#0]  ; USB_P_EP
00079e  2001              MOVS     r0,#1
0007a0  4788              BLX      r1
;;;993    				LPC_USB->DEVCMDSTAT |= USB_SETUP_RCVD;
0007a2  4825              LDR      r0,|L1.2104|
0007a4  6800              LDR      r0,[r0,#0]
0007a6  21ff              MOVS     r1,#0xff
0007a8  3101              ADDS     r1,#1
0007aa  4308              ORRS     r0,r0,r1
0007ac  4922              LDR      r1,|L1.2104|
0007ae  6008              STR      r0,[r1,#0]
;;;994                    continue;
0007b0  e018              B        |L1.2020|
                  |L1.1970|
;;;995                  }
;;;996                }
;;;997              }
;;;998              if (USB_P_EP[m]) {
0007b2  00b8              LSLS     r0,r7,#2
0007b4  4921              LDR      r1,|L1.2108|
0007b6  5808              LDR      r0,[r1,r0]
0007b8  2800              CMP      r0,#0
0007ba  d012              BEQ      |L1.2018|
;;;999                USB_P_EP[m](USB_EVT_OUT);
0007bc  00b8              LSLS     r0,r7,#2
0007be  460a              MOV      r2,r1
0007c0  5811              LDR      r1,[r2,r0]
0007c2  2002              MOVS     r0,#2
0007c4  4788              BLX      r1
0007c6  e00c              B        |L1.2018|
                  |L1.1992|
;;;1000             }
;;;1001           } else {                            /* IN Endpoint */
;;;1002             if (USB_P_EP[m]) {
0007c8  00b8              LSLS     r0,r7,#2
0007ca  491c              LDR      r1,|L1.2108|
0007cc  5808              LDR      r0,[r1,r0]
0007ce  2800              CMP      r0,#0
0007d0  d007              BEQ      |L1.2018|
;;;1003               USB_P_EP[m](USB_EVT_IN);
0007d2  00b8              LSLS     r0,r7,#2
0007d4  460a              MOV      r2,r1
0007d6  5811              LDR      r1,[r2,r0]
0007d8  2003              MOVS     r0,#3
0007da  4788              BLX      r1
;;;1004   			if( m == 1)
0007dc  2f01              CMP      r7,#1
0007de  d100              BNE      |L1.2018|
;;;1005   			{
;;;1006   				m = 1;
0007e0  bf00              NOP      
                  |L1.2018|
0007e2  bf00              NOP                            ;994
                  |L1.2020|
0007e4  1c76              ADDS     r6,r6,#1              ;984
                  |L1.2022|
0007e6  2e04              CMP      r6,#4                 ;984
0007e8  d3c3              BCC      |L1.1906|
                  |L1.2026|
;;;1007   			}
;;;1008             }
;;;1009           }
;;;1010         }
;;;1011       }
;;;1012     }
;;;1013   isr_end:
0007ea  bf00              NOP      
                  |L1.2028|
;;;1014     return;
;;;1015   }
0007ec  bdf8              POP      {r3-r7,pc}
;;;1016   
                          ENDP

                  wnDrv_Usb_EP_Status PROC
;;;1017   
;;;1018   Boolean wnDrv_Usb_EP_Status(U32 EPNum)
0007ee  b570              PUSH     {r4-r6,lr}
;;;1019   {
0007f0  4604              MOV      r4,r0
;;;1020       uint32_t *addr;
;;;1021   
;;;1022       addr = (uint32_t *)USB_GetEPCmdStatusPtr( EPNum );
0007f2  4620              MOV      r0,r4
0007f4  f7fffffe          BL       USB_GetEPCmdStatusPtr
0007f8  4605              MOV      r5,r0
;;;1023   
;;;1024       /* For non-zero EPs, if double buffer is used and EPInUse is set, buffer0
;;;1025       is used, otherwise, buffer1 is used. */
;;;1026       if(LPC_USB->EPBUFCFG & (0x1U << EPAdr(EPNum)))
0007fa  4620              MOV      r0,r4
0007fc  f7fffffe          BL       EPAdr
000800  2101              MOVS     r1,#1
000802  4081              LSLS     r1,r1,r0
000804  480c              LDR      r0,|L1.2104|
000806  69c0              LDR      r0,[r0,#0x1c]
000808  4201              TST      r1,r0
00080a  d009              BEQ      |L1.2080|
;;;1027       {
;;;1028           if(LPC_USB->EPINUSE & (0x1U << EPAdr(EPNum)))
00080c  4620              MOV      r0,r4
00080e  f7fffffe          BL       EPAdr
000812  2101              MOVS     r1,#1
000814  4081              LSLS     r1,r1,r0
000816  4808              LDR      r0,|L1.2104|
000818  6980              LDR      r0,[r0,#0x18]
00081a  4201              TST      r1,r0
00081c  d000              BEQ      |L1.2080|
;;;1029           {
;;;1030               addr++;/* move to buffer1 address in EP command/status list. */
00081e  1d2d              ADDS     r5,r5,#4
                  |L1.2080|
;;;1031           }
;;;1032       }
;;;1033   
;;;1034       /* Get EP command/status List, update the length field and data pointer. */
;;;1035       if((*addr & BUF_ACTIVE) ==  BUF_ACTIVE)
000820  6828              LDR      r0,[r5,#0]
000822  0fc0              LSRS     r0,r0,#31
000824  07c0              LSLS     r0,r0,#31
000826  2101              MOVS     r1,#1
000828  07c9              LSLS     r1,r1,#31
00082a  4288              CMP      r0,r1
00082c  d108              BNE      |L1.2112|
;;;1036       {
;;;1037           return FALSE;
00082e  2000              MOVS     r0,#0
                  |L1.2096|
;;;1038       }
;;;1039       return TRUE;
;;;1040   }
000830  bd70              POP      {r4-r6,pc}
000832  0000              DCW      0x0000
                  |L1.2100|
                          DCD      g_USBHW_Setting
                  |L1.2104|
                          DCD      0x40080000
                  |L1.2108|
                          DCD      USB_P_EP
                  |L1.2112|
000840  2001              MOVS     r0,#1                 ;1039
000842  e7f5              B        |L1.2096|
;;;1041   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_USBHW_Setting
                          %        72

;*** Start embedded assembler ***

#line 1 "Src\\usbhw.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_usbhw_c_f2ca8f3d____REV16|
#line 112 ".\\Inc\\core_cmInstr.h"
|__asm___7_usbhw_c_f2ca8f3d____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_usbhw_c_f2ca8f3d____REVSH|
#line 130
|__asm___7_usbhw_c_f2ca8f3d____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
