; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\i2c.o --depend=.\Obj\i2c.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\Inc -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\NXP\LPC11Uxx -D__MICROLIB -D__DEBUG_FLASH --omf_browse=.\Obj\i2c.crf Src\I2c.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_IRQHandler PROC
;;;37     *****************************************************************************/
;;;38     void I2C_IRQHandler(void) 
000000  b500              PUSH     {lr}
;;;39     {
;;;40     	U8 StatValue;
;;;41     
;;;42     	/* this handler deals with master read and master write only */
;;;43     	StatValue = LPC_I2C->STAT;
000002  2101              MOVS     r1,#1
000004  0789              LSLS     r1,r1,#30
000006  6849              LDR      r1,[r1,#4]
000008  b2c8              UXTB     r0,r1
;;;44     	_DEBUG_I2C_(xprintf("\r\n StatValue=%x",StatValue));
;;;45     
;;;46     	switch(StatValue)
00000a  0741              LSLS     r1,r0,#29
00000c  0f49              LSRS     r1,r1,#29
00000e  d17b              BNE      |L1.264|
000010  10c3              ASRS     r3,r0,#3
000012  f7fffffe          BL       __ARM_common_switch8
000016  0cd2              DCB      0x0c,0xd2
000018  071521cd          DCB      0x07,0x15,0x21,0xcd
00001c  3264d38c          DCB      0x32,0x64,0xd3,0x8c
000020  ce98b8d2          DCB      0xce,0x98,0xb8,0xd2
;;;47     	{
;;;48     		case 0x08:/* A Start condition is issued. */
;;;49     		g_I2C_Setting.WrIndex = 0;
000024  2100              MOVS     r1,#0
000026  4acd              LDR      r2,|L1.860|
000028  7391              STRB     r1,[r2,#0xe]
;;;50     		LPC_I2C->DAT = g_I2C_Setting.I2CDeviceAdr;	
00002a  4611              MOV      r1,r2
00002c  7849              LDRB     r1,[r1,#1]  ; g_I2C_Setting
00002e  2201              MOVS     r2,#1
000030  0792              LSLS     r2,r2,#30
000032  6091              STR      r1,[r2,#8]
;;;51     		LPC_I2C->CONCLR = I2CONCLR_STAC;		
000034  2120              MOVS     r1,#0x20
000036  6191              STR      r1,[r2,#0x18]
;;;52     		g_I2C_Setting.I2CMasterState = I2C_DEVICEARD;
000038  2101              MOVS     r1,#1
00003a  4ac8              LDR      r2,|L1.860|
00003c  7011              STRB     r1,[r2,#0]
;;;53     		break;
00003e  e0be              B        |L1.446|
;;;54     	
;;;55     		case 0x10:/* A repeated started is issued */
;;;56     		g_I2C_Setting.RdIndex = 0;
000040  2100              MOVS     r1,#0
000042  4ac6              LDR      r2,|L1.860|
000044  7351              STRB     r1,[r2,#0xd]
;;;57     		/* Send SLA with R bit set, */
;;;58     		LPC_I2C->DAT = AT24C512_ADDR|READ_STATUS;
000046  21a1              MOVS     r1,#0xa1
000048  078a              LSLS     r2,r1,#30
00004a  6091              STR      r1,[r2,#8]
;;;59     		LPC_I2C->CONCLR = I2CONCLR_STAC;
00004c  2120              MOVS     r1,#0x20
00004e  6191              STR      r1,[r2,#0x18]
;;;60     		g_I2C_Setting.I2CMasterState = I2C_RESTARTED;
000050  2104              MOVS     r1,#4
000052  4ac2              LDR      r2,|L1.860|
000054  7011              STRB     r1,[r2,#0]
;;;61     		break;
000056  e0b2              B        |L1.446|
;;;62     	
;;;63     		case 0x18:/* Regardless, it's a ACK */
;;;64     		if(g_I2C_Setting.I2CMasterState == I2C_DEVICEARD)
000058  49c0              LDR      r1,|L1.860|
00005a  7809              LDRB     r1,[r1,#0]  ; g_I2C_Setting
00005c  2901              CMP      r1,#1
00005e  d10b              BNE      |L1.120|
;;;65     		{
;;;66     			g_I2C_Setting.I2CMasterState = I2C_FWORDARD;	
000060  2102              MOVS     r1,#2
000062  4abe              LDR      r2,|L1.860|
000064  7011              STRB     r1,[r2,#0]
;;;67     			LPC_I2C->DAT = (g_I2C_Setting.I2CWordAdr & 0xFF00) >> 8;					
000066  4611              MOV      r1,r2
000068  8a09              LDRH     r1,[r1,#0x10]  ; g_I2C_Setting
00006a  22ff              MOVS     r2,#0xff
00006c  0212              LSLS     r2,r2,#8
00006e  4011              ANDS     r1,r1,r2
000070  1209              ASRS     r1,r1,#8
000072  2201              MOVS     r2,#1
000074  0792              LSLS     r2,r2,#30
000076  6091              STR      r1,[r2,#8]
                  |L1.120|
;;;68     		}	
;;;69     		break; 
000078  e0a1              B        |L1.446|
;;;70     
;;;71     		case 0x28:/* Data byte has been transmitted, regardless ACK or NACK */		
;;;72     		if(g_I2C_Setting.I2CMasterState == I2C_FWORDARD)
00007a  49b8              LDR      r1,|L1.860|
00007c  7809              LDRB     r1,[r1,#0]  ; g_I2C_Setting
00007e  2902              CMP      r1,#2
000080  d109              BNE      |L1.150|
;;;73     		{
;;;74     			LPC_I2C->DAT = (g_I2C_Setting.I2CWordAdr & 0x00FF) >> 0;				
000082  49b6              LDR      r1,|L1.860|
000084  8a09              LDRH     r1,[r1,#0x10]  ; g_I2C_Setting
000086  b2c9              UXTB     r1,r1
000088  2201              MOVS     r2,#1
00008a  0792              LSLS     r2,r2,#30
00008c  6091              STR      r1,[r2,#8]
;;;75     			g_I2C_Setting.I2CMasterState = I2C_SWORDARD; 			
00008e  2103              MOVS     r1,#3
000090  4ab2              LDR      r2,|L1.860|
000092  7011              STRB     r1,[r2,#0]
;;;76     			break;
000094  e093              B        |L1.446|
                  |L1.150|
;;;77     		}
;;;78     		
;;;79                  if(g_I2C_Setting.I2CBusState == I2C_BUS_WRITE)
000096  49b1              LDR      r1,|L1.860|
000098  7889              LDRB     r1,[r1,#2]  ; g_I2C_Setting
00009a  2901              CMP      r1,#1
00009c  d113              BNE      |L1.198|
;;;80     		{
;;;81     			if(g_I2C_Setting.I2CMasterState == I2C_SWORDARD)
00009e  49af              LDR      r1,|L1.860|
0000a0  7809              LDRB     r1,[r1,#0]  ; g_I2C_Setting
0000a2  2903              CMP      r1,#3
0000a4  d11a              BNE      |L1.220|
;;;82     			{
;;;83     				g_I2C_Setting.I2CMasterState = DATA_ACK; 			
0000a6  2106              MOVS     r1,#6
0000a8  4aac              LDR      r2,|L1.860|
0000aa  7011              STRB     r1,[r2,#0]
;;;84     				LPC_I2C->DAT = g_I2C_Setting.I2CMasterBuffer[g_I2C_Setting.WrIndex];
0000ac  4611              MOV      r1,r2
0000ae  7b8a              LDRB     r2,[r1,#0xe]  ; g_I2C_Setting
0000b0  1cc9              ADDS     r1,r1,#3
0000b2  5c89              LDRB     r1,[r1,r2]
0000b4  2201              MOVS     r2,#1
0000b6  0792              LSLS     r2,r2,#30
0000b8  6091              STR      r1,[r2,#8]
;;;85     				g_I2C_Setting.WrIndex++;			
0000ba  49a8              LDR      r1,|L1.860|
0000bc  7b89              LDRB     r1,[r1,#0xe]  ; g_I2C_Setting
0000be  1c49              ADDS     r1,r1,#1
0000c0  4aa6              LDR      r2,|L1.860|
0000c2  7391              STRB     r1,[r2,#0xe]
;;;86     				break;
0000c4  e07b              B        |L1.446|
                  |L1.198|
;;;87     			}		
;;;88     		}
;;;89     		else
;;;90     		{
;;;91     			if(g_I2C_Setting.I2CBusState == I2C_BUS_READ)
0000c6  49a5              LDR      r1,|L1.860|
0000c8  7889              LDRB     r1,[r1,#2]  ; g_I2C_Setting
0000ca  2902              CMP      r1,#2
0000cc  d106              BNE      |L1.220|
;;;92     			{
;;;93     				LPC_I2C->CONSET = I2CONSET_STA;/* Set Repeated-start flag */
0000ce  2120              MOVS     r1,#0x20
0000d0  064a              LSLS     r2,r1,#25
0000d2  6011              STR      r1,[r2,#0]
;;;94     				g_I2C_Setting.I2CMasterState = I2C_REPEATED_START; 
0000d4  2105              MOVS     r1,#5
0000d6  4aa1              LDR      r2,|L1.860|
0000d8  7011              STRB     r1,[r2,#0]
;;;95     				break;
0000da  e070              B        |L1.446|
                  |L1.220|
;;;96     			}
;;;97     		}
;;;98     			 
;;;99     		case 0x30:
0000dc  bf00              NOP      
;;;100    		if(g_I2C_Setting.WrIndex < g_I2C_Setting.I2CWriteLength)
0000de  499f              LDR      r1,|L1.860|
0000e0  7b89              LDRB     r1,[r1,#0xe]  ; g_I2C_Setting
0000e2  4a9e              LDR      r2,|L1.860|
0000e4  7b12              LDRB     r2,[r2,#0xc]  ; g_I2C_Setting
0000e6  4291              CMP      r1,r2
0000e8  da0f              BGE      |L1.266|
;;;101    		{   
;;;102    			LPC_I2C->DAT = g_I2C_Setting.I2CMasterBuffer[g_I2C_Setting.WrIndex];/* this should be the last one */
0000ea  499c              LDR      r1,|L1.860|
0000ec  7b8a              LDRB     r2,[r1,#0xe]  ; g_I2C_Setting
0000ee  1cc9              ADDS     r1,r1,#3
0000f0  5c89              LDRB     r1,[r1,r2]
0000f2  2201              MOVS     r2,#1
0000f4  0792              LSLS     r2,r2,#30
0000f6  6091              STR      r1,[r2,#8]
;;;103    			g_I2C_Setting.WrIndex++;
0000f8  4998              LDR      r1,|L1.860|
0000fa  7b89              LDRB     r1,[r1,#0xe]  ; g_I2C_Setting
0000fc  1c49              ADDS     r1,r1,#1
0000fe  4a97              LDR      r2,|L1.860|
000100  7391              STRB     r1,[r2,#0xe]
;;;104    			g_I2C_Setting.I2CMasterState = DATA_ACK; 
000102  2106              MOVS     r1,#6
000104  7011              STRB     r1,[r2,#0]
000106  e011              B        |L1.300|
                  |L1.264|
000108  e057              B        |L1.442|
                  |L1.266|
;;;105    		}
;;;106    		else
;;;107    		{
;;;108    			if(g_I2C_Setting.I2CReadLength != 0)
00010a  4994              LDR      r1,|L1.860|
00010c  7ac9              LDRB     r1,[r1,#0xb]  ; g_I2C_Setting
00010e  2900              CMP      r1,#0
000110  d006              BEQ      |L1.288|
;;;109    			{
;;;110    				LPC_I2C->CONSET = I2CONSET_STA;/* Set Repeated-start flag */
000112  2120              MOVS     r1,#0x20
000114  064a              LSLS     r2,r1,#25
000116  6011              STR      r1,[r2,#0]
;;;111    				g_I2C_Setting.I2CMasterState = I2C_REPEATED_START; 
000118  2105              MOVS     r1,#5
00011a  4a90              LDR      r2,|L1.860|
00011c  7011              STRB     r1,[r2,#0]
00011e  e005              B        |L1.300|
                  |L1.288|
;;;112    			}
;;;113    			else
;;;114    			{
;;;115    				g_I2C_Setting.I2CMasterState = DATA_NACK;
000120  2107              MOVS     r1,#7
000122  4a8e              LDR      r2,|L1.860|
000124  7011              STRB     r1,[r2,#0]
;;;116    				LPC_I2C->CONSET = I2CONSET_STO;/* Set Stop flag */
000126  2110              MOVS     r1,#0x10
000128  068a              LSLS     r2,r1,#26
00012a  6011              STR      r1,[r2,#0]
                  |L1.300|
;;;117    			}
;;;118    		}		
;;;119    		break;
00012c  e047              B        |L1.446|
;;;120    	
;;;121    		case 0x40:/* Master Receive, SLA_R has been sent */
;;;122    		if(g_I2C_Setting.I2CReadLength == 1)
00012e  498b              LDR      r1,|L1.860|
000130  7ac9              LDRB     r1,[r1,#0xb]  ; g_I2C_Setting
000132  2901              CMP      r1,#1
000134  d103              BNE      |L1.318|
;;;123    		{
;;;124    			/* Will go to State 0x58 */
;;;125    			LPC_I2C->CONCLR = I2CONCLR_AAC;/* assert NACK after data is received */
000136  2104              MOVS     r1,#4
000138  070a              LSLS     r2,r1,#28
00013a  6191              STR      r1,[r2,#0x18]
00013c  e002              B        |L1.324|
                  |L1.318|
;;;126    		}
;;;127    		else
;;;128    		{
;;;129    			/* Will go to State 0x50 */
;;;130    			LPC_I2C->CONSET = I2CONSET_AA;/* assert ACK after data is received */
00013e  2104              MOVS     r1,#4
000140  070a              LSLS     r2,r1,#28
000142  6011              STR      r1,[r2,#0]
                  |L1.324|
;;;131    		}		
;;;132    		break;
000144  e03b              B        |L1.446|
;;;133    	
;;;134    		case 0x50:/* Data byte has been received, regardless following ACK or NACK */
;;;135    		g_I2C_Setting.I2CSlaveBuffer[g_I2C_Setting.RdIndex] = LPC_I2C->DAT;
000146  2101              MOVS     r1,#1
000148  0789              LSLS     r1,r1,#30
00014a  6889              LDR      r1,[r1,#8]
00014c  b2ca              UXTB     r2,r1
00014e  4983              LDR      r1,|L1.860|
000150  7b4b              LDRB     r3,[r1,#0xd]  ; g_I2C_Setting
000152  1dc9              ADDS     r1,r1,#7
000154  54ca              STRB     r2,[r1,r3]
;;;136    		g_I2C_Setting.RdIndex++;
000156  1fc9              SUBS     r1,r1,#7
000158  7b49              LDRB     r1,[r1,#0xd]  ; g_I2C_Setting
00015a  1c49              ADDS     r1,r1,#1
00015c  4a7f              LDR      r2,|L1.860|
00015e  7351              STRB     r1,[r2,#0xd]
;;;137    		
;;;138    		if(g_I2C_Setting.RdIndex < g_I2C_Setting.I2CReadLength)
000160  4611              MOV      r1,r2
000162  7b49              LDRB     r1,[r1,#0xd]  ; g_I2C_Setting
000164  7ad2              LDRB     r2,[r2,#0xb]  ; g_I2C_Setting
000166  4291              CMP      r1,r2
000168  da06              BGE      |L1.376|
;;;139    		{   
;;;140    			g_I2C_Setting.I2CMasterState = DATA_ACK;
00016a  2106              MOVS     r1,#6
00016c  4a7b              LDR      r2,|L1.860|
00016e  7011              STRB     r1,[r2,#0]
;;;141    			LPC_I2C->CONSET = I2CONSET_AA;/* assert ACK after data is received */
000170  2104              MOVS     r1,#4
000172  070a              LSLS     r2,r1,#28
000174  6011              STR      r1,[r2,#0]
000176  e005              B        |L1.388|
                  |L1.376|
;;;142    		}
;;;143    		else
;;;144    		{
;;;145    			g_I2C_Setting.I2CMasterState = DATA_NACK;
000178  2107              MOVS     r1,#7
00017a  4a78              LDR      r2,|L1.860|
00017c  7011              STRB     r1,[r2,#0]
;;;146    			LPC_I2C->CONCLR = I2CONCLR_AAC;/* assert NACK on last byte */
00017e  2104              MOVS     r1,#4
000180  070a              LSLS     r2,r1,#28
000182  6191              STR      r1,[r2,#0x18]
                  |L1.388|
;;;147    		}		
;;;148    		break;
000184  e01b              B        |L1.446|
;;;149    	
;;;150    		case 0x58:
;;;151    		g_I2C_Setting.I2CSlaveBuffer[g_I2C_Setting.RdIndex] = LPC_I2C->DAT;
000186  2101              MOVS     r1,#1
000188  0789              LSLS     r1,r1,#30
00018a  6889              LDR      r1,[r1,#8]
00018c  b2ca              UXTB     r2,r1
00018e  4973              LDR      r1,|L1.860|
000190  7b4b              LDRB     r3,[r1,#0xd]  ; g_I2C_Setting
000192  1dc9              ADDS     r1,r1,#7
000194  54ca              STRB     r2,[r1,r3]
;;;152    		g_I2C_Setting.RdIndex++;
000196  1fc9              SUBS     r1,r1,#7
000198  7b49              LDRB     r1,[r1,#0xd]  ; g_I2C_Setting
00019a  1c49              ADDS     r1,r1,#1
00019c  4a6f              LDR      r2,|L1.860|
00019e  7351              STRB     r1,[r2,#0xd]
;;;153    		g_I2C_Setting.I2CMasterState = DATA_NACK;
0001a0  2107              MOVS     r1,#7
0001a2  7011              STRB     r1,[r2,#0]
;;;154    		LPC_I2C->CONSET = I2CONSET_STO;/* Set Stop flag */ 
0001a4  2110              MOVS     r1,#0x10
0001a6  068a              LSLS     r2,r1,#26
0001a8  6011              STR      r1,[r2,#0]
;;;155    		LPC_I2C->CONCLR = I2CONCLR_SIC;/* Clear SI flag */
0001aa  2108              MOVS     r1,#8
0001ac  6191              STR      r1,[r2,#0x18]
;;;156    		break;
0001ae  e006              B        |L1.446|
;;;157    
;;;158    		case 0x20:/* regardless, it's a NACK */
;;;159    		case 0x48:		
0001b0  bf00              NOP      
;;;160    		g_I2C_Setting.I2CMasterState = DATA_NACK;
0001b2  2107              MOVS     r1,#7
0001b4  4a69              LDR      r2,|L1.860|
0001b6  7011              STRB     r1,[r2,#0]
;;;161    		break;
0001b8  e001              B        |L1.446|
                  |L1.442|
;;;162    	
;;;163    		case 0x38:/* Arbitration lost, in this example, we don't
0001ba  bf00              NOP      
;;;164    		deal with multiple master situation */
;;;165    		default:		
;;;166    		break;
0001bc  bf00              NOP      
                  |L1.446|
0001be  bf00              NOP                            ;53
;;;167    	}
;;;168    
;;;169    	LPC_I2C->CONCLR = I2CONCLR_SIC;	
0001c0  2108              MOVS     r1,#8
0001c2  06ca              LSLS     r2,r1,#27
0001c4  6191              STR      r1,[r2,#0x18]
;;;170    }
0001c6  bd00              POP      {pc}
;;;171    
                          ENDP

                  NDrv_API_I2C_Start PROC
;;;182    *****************************************************************************/
;;;183    Boolean NDrv_API_I2C_Start(void)
0001c8  2100              MOVS     r1,#0
;;;184    {
;;;185    	U32 Timeout = 0;
;;;186    	U8 retVal = FALSE;
0001ca  2000              MOVS     r0,#0
;;;187    
;;;188    	LPC_I2C->CONCLR = I2CONCLR_AAC | I2CONCLR_SIC | I2CONCLR_STAC | I2CONCLR_I2ENC;  
0001cc  226c              MOVS     r2,#0x6c
0001ce  2301              MOVS     r3,#1
0001d0  079b              LSLS     r3,r3,#30
0001d2  619a              STR      r2,[r3,#0x18]
;;;189    	/*--- Issue a start condition ---*/
;;;190    	LPC_I2C->CONSET = I2CONSET_STA|I2CONSET_I2EN;/* Set Start flag */       
0001d4  2260              MOVS     r2,#0x60
0001d6  601a              STR      r2,[r3,#0]
;;;191    	/*--- Wait until START transmitted ---*/
;;;192    	while(1)
0001d8  e00b              B        |L1.498|
                  |L1.474|
;;;193    	{
;;;194    		if(g_I2C_Setting.I2CMasterState == I2C_DEVICEARD)
0001da  4a60              LDR      r2,|L1.860|
0001dc  7812              LDRB     r2,[r2,#0]  ; g_I2C_Setting
0001de  2a01              CMP      r2,#1
0001e0  d101              BNE      |L1.486|
;;;195    		{    
;;;196    			retVal = TRUE;
0001e2  2001              MOVS     r0,#1
;;;197    			break;	
0001e4  e006              B        |L1.500|
                  |L1.486|
;;;198    		}
;;;199    		
;;;200    		if(Timeout >= MAX_TIMEOUT )
0001e6  4a5e              LDR      r2,|L1.864|
0001e8  4291              CMP      r1,r2
0001ea  d301              BCC      |L1.496|
;;;201    		{
;;;202    			retVal = FALSE;
0001ec  2000              MOVS     r0,#0
;;;203    			break;
0001ee  e001              B        |L1.500|
                  |L1.496|
;;;204    		}
;;;205    		Timeout++;
0001f0  1c49              ADDS     r1,r1,#1
                  |L1.498|
0001f2  e7f2              B        |L1.474|
                  |L1.500|
0001f4  bf00              NOP                            ;197
;;;206    	}	
;;;207    	return(retVal);
;;;208    }
0001f6  4770              BX       lr
;;;209    
                          ENDP

                  NDrv_API_I2C_Stop PROC
;;;219    *****************************************************************************/
;;;220    void NDrv_API_I2C_Stop(void)
0001f8  2050              MOVS     r0,#0x50
;;;221    {
;;;222    	LPC_I2C->CONSET = I2CONSET_STO|I2CONSET_I2EN;/* Set Stop flag */ 
0001fa  0681              LSLS     r1,r0,#26
0001fc  6008              STR      r0,[r1,#0]
;;;223    	LPC_I2C->CONCLR = I2CONCLR_SIC|I2CONCLR_STAC|I2CONCLR_AAC;/* Clear SI flag */ 
0001fe  202c              MOVS     r0,#0x2c
000200  6188              STR      r0,[r1,#0x18]
;;;224    
;;;225    	/*--- Wait for STOP detected ---*/
;;;226    	while( LPC_I2C->CONSET & I2CONSET_STO ){}  
000202  bf00              NOP      
                  |L1.516|
000204  2001              MOVS     r0,#1
000206  0780              LSLS     r0,r0,#30
000208  6800              LDR      r0,[r0,#0]
00020a  2110              MOVS     r1,#0x10
00020c  4208              TST      r0,r1
00020e  d1f9              BNE      |L1.516|
;;;227    }
000210  4770              BX       lr
;;;228    
                          ENDP

                  nsAPI_I2C_Init PROC
;;;238    *****************************************************************************/
;;;239    void nsAPI_I2C_Init(void) 
000212  b510              PUSH     {r4,lr}
;;;240    {
;;;241    	NVIC_DisableIRQ(I2C_IRQn);   
000214  bf00              NOP      
000216  210f              MOVS     r1,#0xf
000218  2001              MOVS     r0,#1
00021a  4088              LSLS     r0,r0,r1
00021c  4951              LDR      r1,|L1.868|
00021e  6008              STR      r0,[r1,#0]
000220  bf00              NOP      
;;;242    
;;;243    	g_I2C_Setting.I2CMasterState = I2C_IDLE;
000222  2000              MOVS     r0,#0
000224  494d              LDR      r1,|L1.860|
000226  7008              STRB     r0,[r1,#0]
;;;244    	g_I2C_Setting.I2CBusState = I2C_BUS_IDLE;
000228  7088              STRB     r0,[r1,#2]
;;;245    	g_I2C_Setting.I2CReadLength = 0;
00022a  72c8              STRB     r0,[r1,#0xb]
;;;246    	g_I2C_Setting.I2CWriteLength = 0;
00022c  7308              STRB     r0,[r1,#0xc]
;;;247    	g_I2C_Setting.RdIndex = 0;
00022e  7348              STRB     r0,[r1,#0xd]
;;;248    	g_I2C_Setting.WrIndex = 0;
000230  7388              STRB     r0,[r1,#0xe]
;;;249    	
;;;250    	/* It seems to be bit0 is for I2C, different from
;;;251    	UM. To be retested along with SSP reset. SSP and I2C
;;;252    	reset are overlapped, a known bug, for now, both SSP 
;;;253    	and I2C use bit 0 for reset enable. Once the problem
;;;254    	is fixed, change to "#if 1". */
;;;255    #if 1
;;;256    	LPC_SYSCON->PRESETCTRL |= BIT1;
000232  484d              LDR      r0,|L1.872|
000234  6840              LDR      r0,[r0,#4]
000236  2102              MOVS     r1,#2
000238  4308              ORRS     r0,r0,r1
00023a  494b              LDR      r1,|L1.872|
00023c  6048              STR      r0,[r1,#4]
;;;257    #else
;;;258    	LPC_SYSCON->PRESETCTRL |= BIT0;
;;;259    #endif
;;;260    	LPC_SYSCON->SYSAHBCLKCTRL |= BIT5;
00023e  484a              LDR      r0,|L1.872|
000240  3080              ADDS     r0,r0,#0x80
000242  6800              LDR      r0,[r0,#0]
000244  2120              MOVS     r1,#0x20
000246  4308              ORRS     r0,r0,r1
000248  4947              LDR      r1,|L1.872|
00024a  3180              ADDS     r1,r1,#0x80
00024c  6008              STR      r0,[r1,#0]
;;;261    	LPC_IOCON->PIO0_4 &= ~0x3F;/* I2C I/O config */
00024e  4847              LDR      r0,|L1.876|
000250  6900              LDR      r0,[r0,#0x10]
000252  0980              LSRS     r0,r0,#6
000254  0180              LSLS     r0,r0,#6
000256  4945              LDR      r1,|L1.876|
000258  6108              STR      r0,[r1,#0x10]
;;;262    	LPC_IOCON->PIO0_4 |= BIT0;/*  I2C SCL */
00025a  4608              MOV      r0,r1
00025c  6900              LDR      r0,[r0,#0x10]
00025e  2101              MOVS     r1,#1
000260  4308              ORRS     r0,r0,r1
000262  4942              LDR      r1,|L1.876|
000264  6108              STR      r0,[r1,#0x10]
;;;263    	LPC_IOCON->PIO0_5 &= ~0x3F;	
000266  4608              MOV      r0,r1
000268  6940              LDR      r0,[r0,#0x14]
00026a  0980              LSRS     r0,r0,#6
00026c  0180              LSLS     r0,r0,#6
00026e  6148              STR      r0,[r1,#0x14]
;;;264    	LPC_IOCON->PIO0_5 |= BIT0;/* I2C SDA */
000270  4608              MOV      r0,r1
000272  6940              LDR      r0,[r0,#0x14]
000274  2101              MOVS     r1,#1
000276  4308              ORRS     r0,r0,r1
000278  493c              LDR      r1,|L1.876|
00027a  6148              STR      r0,[r1,#0x14]
;;;265    	
;;;266    	/*--- Clear flags ---*/
;;;267    	LPC_I2C->CONCLR = I2CONCLR_AAC | I2CONCLR_SIC | I2CONCLR_STAC | I2CONCLR_I2ENC; 
00027c  206c              MOVS     r0,#0x6c
00027e  0409              LSLS     r1,r1,#16
000280  6188              STR      r0,[r1,#0x18]
;;;268    	LPC_I2C->SCLL = I2SCLL_SCLL;
000282  493b              LDR      r1,|L1.880|
000284  483b              LDR      r0,|L1.884|
000286  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000288  f7fffffe          BL       __aeabi_uidivmod
00028c  0840              LSRS     r0,r0,#1
00028e  2101              MOVS     r1,#1
000290  0789              LSLS     r1,r1,#30
000292  6148              STR      r0,[r1,#0x14]
;;;269    	LPC_I2C->SCLH = I2SCLH_SCLH;
000294  4936              LDR      r1,|L1.880|
000296  4837              LDR      r0,|L1.884|
000298  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00029a  f7fffffe          BL       __aeabi_uidivmod
00029e  0840              LSRS     r0,r0,#1
0002a0  2101              MOVS     r1,#1
0002a2  0789              LSLS     r1,r1,#30
0002a4  6108              STR      r0,[r1,#0x10]
;;;270    	LPC_I2C->ADR0 = AT24C512_ADDR; 
0002a6  20a0              MOVS     r0,#0xa0
0002a8  60c8              STR      r0,[r1,#0xc]
;;;271    	/* Enable the I2C Interrupt */
;;;272    	NVIC_EnableIRQ(I2C_IRQn);
0002aa  bf00              NOP      
0002ac  210f              MOVS     r1,#0xf
0002ae  2001              MOVS     r0,#1
0002b0  4088              LSLS     r0,r0,r1
0002b2  492c              LDR      r1,|L1.868|
0002b4  3980              SUBS     r1,r1,#0x80
0002b6  6008              STR      r0,[r1,#0]
0002b8  bf00              NOP      
;;;273    	
;;;274    }
0002ba  bd10              POP      {r4,pc}
;;;275    
                          ENDP

                  nsAPI_I2C_Write PROC
;;;276    
;;;277    void nsAPI_I2C_Write(void)
0002bc  b510              PUSH     {r4,lr}
;;;278    {
;;;279          U8 u8Brk = 1; 
0002be  2401              MOVS     r4,#1
;;;280     
;;;281    	g_I2C_Setting.I2CDeviceAdr = AT24C512_ADDR;     
0002c0  20a0              MOVS     r0,#0xa0
0002c2  4926              LDR      r1,|L1.860|
0002c4  7048              STRB     r0,[r1,#1]
;;;282    	g_I2C_Setting.I2CMasterState = I2C_IDLE;		
0002c6  2000              MOVS     r0,#0
0002c8  7008              STRB     r0,[r1,#0]
;;;283    
;;;284    	if(NDrv_API_I2C_Start() != TRUE)
0002ca  f7fffffe          BL       NDrv_API_I2C_Start
0002ce  2801              CMP      r0,#1
0002d0  d002              BEQ      |L1.728|
;;;285    	{	   
;;;286    		NDrv_API_I2C_Stop();
0002d2  f7fffffe          BL       NDrv_API_I2C_Stop
                  |L1.726|
;;;287    		return;
;;;288    	}
;;;289    
;;;290    	while(u8Brk)
;;;291    	{	 
;;;292    		if(g_I2C_Setting.I2CMasterState == DATA_NACK)
;;;293    		{	
;;;294    			u8Brk = 0;
;;;295    			NDrv_API_I2C_Stop();			
;;;296    		}
;;;297    	} 
;;;298    }
0002d6  bd10              POP      {r4,pc}
                  |L1.728|
0002d8  e006              B        |L1.744|
                  |L1.730|
0002da  4820              LDR      r0,|L1.860|
0002dc  7800              LDRB     r0,[r0,#0]            ;292  ; g_I2C_Setting
0002de  2807              CMP      r0,#7                 ;292
0002e0  d102              BNE      |L1.744|
0002e2  2400              MOVS     r4,#0                 ;294
0002e4  f7fffffe          BL       NDrv_API_I2C_Stop
                  |L1.744|
0002e8  2c00              CMP      r4,#0                 ;290
0002ea  d1f6              BNE      |L1.730|
0002ec  e7f3              B        |L1.726|
;;;299    
                          ENDP

                  nsAPI_I2C_Read PROC
;;;300    void nsAPI_I2C_Read(void)
0002ee  b500              PUSH     {lr}
;;;301    {
;;;302    	g_I2C_Setting.I2CDeviceAdr = AT24C512_ADDR|READ_STATUS;  
0002f0  20a1              MOVS     r0,#0xa1
0002f2  491a              LDR      r1,|L1.860|
0002f4  7048              STRB     r0,[r1,#1]
;;;303    	g_I2C_Setting.I2CMasterState = I2C_IDLE;	
0002f6  2000              MOVS     r0,#0
0002f8  7008              STRB     r0,[r1,#0]
;;;304    	g_I2C_Setting.RdIndex = 0;		
0002fa  7348              STRB     r0,[r1,#0xd]
;;;305    
;;;306    	if(NDrv_API_I2C_Start() != TRUE)
0002fc  f7fffffe          BL       NDrv_API_I2C_Start
000300  2801              CMP      r0,#1
000302  d002              BEQ      |L1.778|
;;;307    	{	   
;;;308    		NDrv_API_I2C_Stop();
000304  f7fffffe          BL       NDrv_API_I2C_Stop
                  |L1.776|
;;;309    		return;
;;;310    	}
;;;311    
;;;312    	while(1)
;;;313    	{	 
;;;314    		if(g_I2C_Setting.I2CMasterState == DATA_NACK)
;;;315    		{		
;;;316    			NDrv_API_I2C_Stop();
;;;317    			break;
;;;318    		}
;;;319    	} 
;;;320    }
000308  bd00              POP      {pc}
                  |L1.778|
00030a  e006              B        |L1.794|
                  |L1.780|
00030c  4813              LDR      r0,|L1.860|
00030e  7800              LDRB     r0,[r0,#0]            ;314  ; g_I2C_Setting
000310  2807              CMP      r0,#7                 ;314
000312  d102              BNE      |L1.794|
000314  f7fffffe          BL       NDrv_API_I2C_Stop
000318  e000              B        |L1.796|
                  |L1.794|
00031a  e7f7              B        |L1.780|
                  |L1.796|
00031c  bf00              NOP                            ;317
00031e  e7f3              B        |L1.776|
;;;321    
                          ENDP

                  nsAPI_I2C_Write_Database PROC
;;;322    void nsAPI_I2C_Write_Database(U16 u16Adr,U8 *pBuf)
000320  b530              PUSH     {r4,r5,lr}
;;;323    {	
000322  4604              MOV      r4,r0
000324  460d              MOV      r5,r1
;;;324    	g_I2C_Setting.I2CWordAdr = u16Adr;/*Word Address*/  
000326  480d              LDR      r0,|L1.860|
000328  8204              STRH     r4,[r0,#0x10]
;;;325    	g_I2C_Setting.I2CBusState = I2C_BUS_WRITE;
00032a  2001              MOVS     r0,#1
00032c  490b              LDR      r1,|L1.860|
00032e  7088              STRB     r0,[r1,#2]
;;;326    	g_I2C_Setting.I2CMasterBuffer[GIdx0] = *pBuf;/*Data*/ 
000330  7828              LDRB     r0,[r5,#0]
000332  70c8              STRB     r0,[r1,#3]
;;;327    
;;;328    	g_I2C_Setting.I2CWriteLength = GIdx1;
000334  2001              MOVS     r0,#1
000336  7308              STRB     r0,[r1,#0xc]
;;;329    
;;;330    	nsAPI_I2C_Write();
000338  f7fffffe          BL       nsAPI_I2C_Write
;;;331    }
00033c  bd30              POP      {r4,r5,pc}
;;;332    
                          ENDP

                  nsAPI_I2C_Read_Database PROC
;;;333    RetU8 nsAPI_I2C_Read_Database(U16 u16Adr)
00033e  b510              PUSH     {r4,lr}
;;;334    {	
000340  4604              MOV      r4,r0
;;;335    	g_I2C_Setting.I2CWordAdr = u16Adr;/*Word Address*/ 	
000342  4806              LDR      r0,|L1.860|
000344  8204              STRH     r4,[r0,#0x10]
;;;336    	g_I2C_Setting.I2CBusState = I2C_BUS_READ;		
000346  2002              MOVS     r0,#2
000348  4904              LDR      r1,|L1.860|
00034a  7088              STRB     r0,[r1,#2]
;;;337    	g_I2C_Setting.I2CWriteLength = GIdx0;
00034c  2000              MOVS     r0,#0
00034e  7308              STRB     r0,[r1,#0xc]
;;;338    
;;;339    	nsAPI_I2C_Write();	
000350  f7fffffe          BL       nsAPI_I2C_Write
;;;340    	//nsAPI_SSP_ADNS9500_Delsy1us(1000);/*1ms*/	
;;;341    
;;;342    	_DEBUG_I2C_(xprintf("\r\n buf=%x",g_I2C_Setting.I2CSlaveBuffer[0]));	
;;;343    
;;;344    	return (g_I2C_Setting.I2CSlaveBuffer[0]);
000354  4801              LDR      r0,|L1.860|
000356  79c0              LDRB     r0,[r0,#7]  ; g_I2C_Setting
;;;345    }
000358  bd10              POP      {r4,pc}
;;;346    
                          ENDP

00035a  0000              DCW      0x0000
                  |L1.860|
                          DCD      g_I2C_Setting
                  |L1.864|
                          DCD      0x00ffffff
                  |L1.868|
                          DCD      0xe000e180
                  |L1.872|
                          DCD      0x40048000
                  |L1.876|
                          DCD      0x40044000
                  |L1.880|
                          DCD      0x00061a80
                  |L1.884|
                          DCD      SystemCoreClock

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  g_I2C_Setting
                          %        18

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L16.16|
00000e  461d              MOV      r5,r3
                  |L16.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "Src\\I2c.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_I2c_c_930b201d____REV16|
#line 112 ".\\Inc\\core_cmInstr.h"
|__asm___5_I2c_c_930b201d____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_I2c_c_930b201d____REVSH|
#line 130
|__asm___5_I2c_c_930b201d____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
