; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\timer32.o --depend=.\Obj\timer32.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\Inc -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\NXP\LPC11Uxx -D__MICROLIB -D__DEBUG_FLASH --omf_browse=.\Obj\timer32.crf Src\timer32.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIMER32_0_IRQHandler PROC
;;;37     ******************************************************************************/
;;;38     void TIMER32_0_IRQHandler(void)
000000  48ff              LDR      r0,|L1.1024|
;;;39     {
;;;40       if ( LPC_CT32B0->IR & (0x01<<0) )
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  0fc0              LSRS     r0,r0,#31
000008  d005              BEQ      |L1.22|
;;;41       { 
;;;42     	LPC_CT32B0->IR |= (0x01<<0);
00000a  48fd              LDR      r0,|L1.1024|
00000c  6800              LDR      r0,[r0,#0]
00000e  2101              MOVS     r1,#1
000010  4308              ORRS     r0,r0,r1
000012  49fb              LDR      r1,|L1.1024|
000014  6008              STR      r0,[r1,#0]
                  |L1.22|
;;;43     
;;;44       }
;;;45       if ( LPC_CT32B0->IR & (0x01<<1) )
000016  48fa              LDR      r0,|L1.1024|
000018  6800              LDR      r0,[r0,#0]
00001a  2102              MOVS     r1,#2
00001c  4208              TST      r0,r1
00001e  d002              BEQ      |L1.38|
;;;46       {  
;;;47     	LPC_CT32B0->IR = 0x1<<1;			/* clear interrupt flag */
000020  2002              MOVS     r0,#2
000022  49f7              LDR      r1,|L1.1024|
000024  6008              STR      r0,[r1,#0]
                  |L1.38|
;;;48       }
;;;49       if ( LPC_CT32B0->IR & (0x01<<2) )
000026  48f6              LDR      r0,|L1.1024|
000028  6800              LDR      r0,[r0,#0]
00002a  2104              MOVS     r1,#4
00002c  4208              TST      r0,r1
00002e  d002              BEQ      |L1.54|
;;;50       {  
;;;51     	LPC_CT32B0->IR = 0x1<<2;			/* clear interrupt flag */
000030  2004              MOVS     r0,#4
000032  49f3              LDR      r1,|L1.1024|
000034  6008              STR      r0,[r1,#0]
                  |L1.54|
;;;52       }
;;;53       if ( LPC_CT32B0->IR & (0x01<<3) )
000036  48f2              LDR      r0,|L1.1024|
000038  6800              LDR      r0,[r0,#0]
00003a  2108              MOVS     r1,#8
00003c  4208              TST      r0,r1
00003e  d002              BEQ      |L1.70|
;;;54       {  
;;;55     	LPC_CT32B0->IR = 0x1<<3;			/* clear interrupt flag */
000040  2008              MOVS     r0,#8
000042  49ef              LDR      r1,|L1.1024|
000044  6008              STR      r0,[r1,#0]
                  |L1.70|
;;;56       }
;;;57       if ( LPC_CT32B0->IR & (0x1<<4) )
000046  48ee              LDR      r0,|L1.1024|
000048  6800              LDR      r0,[r0,#0]
00004a  2110              MOVS     r1,#0x10
00004c  4208              TST      r0,r1
00004e  d002              BEQ      |L1.86|
;;;58       {  
;;;59     	LPC_CT32B0->IR = 0x1<<4;			/* clear interrupt flag */	
000050  2010              MOVS     r0,#0x10
000052  49eb              LDR      r1,|L1.1024|
000054  6008              STR      r0,[r1,#0]
                  |L1.86|
;;;60       }
;;;61       if ( LPC_CT32B0->IR & (0x1<<5) )
000056  48ea              LDR      r0,|L1.1024|
000058  6800              LDR      r0,[r0,#0]
00005a  2120              MOVS     r1,#0x20
00005c  4208              TST      r0,r1
00005e  d002              BEQ      |L1.102|
;;;62       {  
;;;63     	LPC_CT32B0->IR = 0x1<<5;			/* clear interrupt flag */
000060  2020              MOVS     r0,#0x20
000062  49e7              LDR      r1,|L1.1024|
000064  6008              STR      r0,[r1,#0]
                  |L1.102|
;;;64       }
;;;65       if ( LPC_CT32B0->IR & (0x1<<6) )
000066  48e6              LDR      r0,|L1.1024|
000068  6800              LDR      r0,[r0,#0]
00006a  2140              MOVS     r1,#0x40
00006c  4208              TST      r0,r1
00006e  d002              BEQ      |L1.118|
;;;66       {  
;;;67     	LPC_CT32B0->IR = 0x1<<6;			/* clear interrupt flag */
000070  2040              MOVS     r0,#0x40
000072  49e3              LDR      r1,|L1.1024|
000074  6008              STR      r0,[r1,#0]
                  |L1.118|
;;;68       }
;;;69       if ( LPC_CT32B0->IR & (0x1<<7) )
000076  48e2              LDR      r0,|L1.1024|
000078  6800              LDR      r0,[r0,#0]
00007a  2180              MOVS     r1,#0x80
00007c  4208              TST      r0,r1
00007e  d002              BEQ      |L1.134|
;;;70       {  
;;;71     	LPC_CT32B0->IR = 0x1<<7;			/* clear interrupt flag */
000080  2080              MOVS     r0,#0x80
000082  49df              LDR      r1,|L1.1024|
000084  6008              STR      r0,[r1,#0]
                  |L1.134|
;;;72       }
;;;73      
;;;74     }
000086  4770              BX       lr
;;;75     
                          ENDP

                  TIMER32_1_IRQHandler PROC
;;;84     ******************************************************************************/
;;;85     void TIMER32_1_IRQHandler(void)
000088  48de              LDR      r0,|L1.1028|
;;;86     {
;;;87       if ( LPC_CT32B1->IR & (0x01<<0) )
00008a  6800              LDR      r0,[r0,#0]
00008c  07c0              LSLS     r0,r0,#31
00008e  0fc0              LSRS     r0,r0,#31
000090  d002              BEQ      |L1.152|
;;;88       {  
;;;89     	LPC_CT32B1->IR = 0x1<<0;			/* clear interrupt flag */
000092  2001              MOVS     r0,#1
000094  49db              LDR      r1,|L1.1028|
000096  6008              STR      r0,[r1,#0]
                  |L1.152|
;;;90       }
;;;91       if ( LPC_CT32B1->IR & (0x01<<1) )
000098  48da              LDR      r0,|L1.1028|
00009a  6800              LDR      r0,[r0,#0]
00009c  2102              MOVS     r1,#2
00009e  4208              TST      r0,r1
0000a0  d002              BEQ      |L1.168|
;;;92       {  
;;;93     	LPC_CT32B1->IR = 0x1<<1;			/* clear interrupt flag */
0000a2  2002              MOVS     r0,#2
0000a4  49d7              LDR      r1,|L1.1028|
0000a6  6008              STR      r0,[r1,#0]
                  |L1.168|
;;;94       }
;;;95       if ( LPC_CT32B1->IR & (0x01<<2) )
0000a8  48d6              LDR      r0,|L1.1028|
0000aa  6800              LDR      r0,[r0,#0]
0000ac  2104              MOVS     r1,#4
0000ae  4208              TST      r0,r1
0000b0  d002              BEQ      |L1.184|
;;;96       {  
;;;97     	LPC_CT32B1->IR = 0x1<<2;			/* clear interrupt flag */
0000b2  2004              MOVS     r0,#4
0000b4  49d3              LDR      r1,|L1.1028|
0000b6  6008              STR      r0,[r1,#0]
                  |L1.184|
;;;98       }
;;;99       if ( LPC_CT32B1->IR & (0x01<<3) )
0000b8  48d2              LDR      r0,|L1.1028|
0000ba  6800              LDR      r0,[r0,#0]
0000bc  2108              MOVS     r1,#8
0000be  4208              TST      r0,r1
0000c0  d002              BEQ      |L1.200|
;;;100      {  
;;;101    	LPC_CT32B1->IR = 0x1<<3;			/* clear interrupt flag */
0000c2  2008              MOVS     r0,#8
0000c4  49cf              LDR      r1,|L1.1028|
0000c6  6008              STR      r0,[r1,#0]
                  |L1.200|
;;;102      }
;;;103      if ( LPC_CT32B1->IR & (0x1<<4) )
0000c8  48ce              LDR      r0,|L1.1028|
0000ca  6800              LDR      r0,[r0,#0]
0000cc  2110              MOVS     r1,#0x10
0000ce  4208              TST      r0,r1
0000d0  d002              BEQ      |L1.216|
;;;104      {  
;;;105    	LPC_CT32B1->IR = 0x1<<4;			/* clear interrupt flag */
0000d2  2010              MOVS     r0,#0x10
0000d4  49cb              LDR      r1,|L1.1028|
0000d6  6008              STR      r0,[r1,#0]
                  |L1.216|
;;;106      }
;;;107      if ( LPC_CT32B1->IR & (0x1<<5) )
0000d8  48ca              LDR      r0,|L1.1028|
0000da  6800              LDR      r0,[r0,#0]
0000dc  2120              MOVS     r1,#0x20
0000de  4208              TST      r0,r1
0000e0  d002              BEQ      |L1.232|
;;;108      {  
;;;109    	LPC_CT32B1->IR = 0x1<<5;			/* clear interrupt flag */
0000e2  2020              MOVS     r0,#0x20
0000e4  49c7              LDR      r1,|L1.1028|
0000e6  6008              STR      r0,[r1,#0]
                  |L1.232|
;;;110    	
;;;111      }
;;;112      if ( LPC_CT32B1->IR & (0x1<<6) )
0000e8  48c6              LDR      r0,|L1.1028|
0000ea  6800              LDR      r0,[r0,#0]
0000ec  2140              MOVS     r1,#0x40
0000ee  4208              TST      r0,r1
0000f0  d002              BEQ      |L1.248|
;;;113      {  
;;;114    	LPC_CT32B1->IR = 0x1<<6;			/* clear interrupt flag */
0000f2  2040              MOVS     r0,#0x40
0000f4  49c3              LDR      r1,|L1.1028|
0000f6  6008              STR      r0,[r1,#0]
                  |L1.248|
;;;115      }
;;;116      if ( LPC_CT32B1->IR & (0x1<<7) )
0000f8  48c2              LDR      r0,|L1.1028|
0000fa  6800              LDR      r0,[r0,#0]
0000fc  2180              MOVS     r1,#0x80
0000fe  4208              TST      r0,r1
000100  d002              BEQ      |L1.264|
;;;117      {  
;;;118    	LPC_CT32B1->IR = 0x1<<7;			/* clear interrupt flag */
000102  2080              MOVS     r0,#0x80
000104  49bf              LDR      r1,|L1.1028|
000106  6008              STR      r0,[r1,#0]
                  |L1.264|
;;;119      }
;;;120     
;;;121    }
000108  4770              BX       lr
;;;122    
                          ENDP

                  NDrv_Timer32_Enable PROC
;;;131    ******************************************************************************/
;;;132    void NDrv_Timer32_Enable(U8 timer_num)
00010a  2800              CMP      r0,#0
;;;133    {
;;;134    	if(timer_num == 0)  
00010c  d103              BNE      |L1.278|
;;;135    	LPC_CT32B0->TCR = 1;  
00010e  2101              MOVS     r1,#1
000110  4abb              LDR      r2,|L1.1024|
000112  6051              STR      r1,[r2,#4]
000114  e002              B        |L1.284|
                  |L1.278|
;;;136    	else  
;;;137    	LPC_CT32B1->TCR = 1; 
000116  2101              MOVS     r1,#1
000118  4aba              LDR      r2,|L1.1028|
00011a  6051              STR      r1,[r2,#4]
                  |L1.284|
;;;138    }
00011c  4770              BX       lr
;;;139    
                          ENDP

                  NDrv_Timer32_Disable PROC
;;;148    ******************************************************************************/
;;;149    void NDrv_Timer32_Disable(U8 timer_num)
00011e  2800              CMP      r0,#0
;;;150    {
;;;151    	if(timer_num == 0)  
000120  d103              BNE      |L1.298|
;;;152    	LPC_CT32B0->TCR = 0;  
000122  2100              MOVS     r1,#0
000124  4ab6              LDR      r2,|L1.1024|
000126  6051              STR      r1,[r2,#4]
000128  e002              B        |L1.304|
                  |L1.298|
;;;153    	else  
;;;154    	LPC_CT32B1->TCR = 0;  
00012a  2100              MOVS     r1,#0
00012c  4ab5              LDR      r2,|L1.1028|
00012e  6051              STR      r1,[r2,#4]
                  |L1.304|
;;;155    }
000130  4770              BX       lr
;;;156    
                          ENDP

                  NDrv_Timer32_Reset PROC
;;;165    ******************************************************************************/
;;;166    void NDrv_Timer32_Reset(U8 timer_num)
000132  2800              CMP      r0,#0
;;;167    {
;;;168    	U32 regVal;
;;;169    
;;;170    	if(timer_num == 0)
000134  d106              BNE      |L1.324|
;;;171    	{
;;;172    		regVal = LPC_CT32B0->TCR;
000136  4ab2              LDR      r2,|L1.1024|
000138  6851              LDR      r1,[r2,#4]
;;;173    		regVal |= BIT1;
00013a  2202              MOVS     r2,#2
00013c  4311              ORRS     r1,r1,r2
;;;174    		LPC_CT32B0->TCR = regVal;
00013e  4ab0              LDR      r2,|L1.1024|
000140  6051              STR      r1,[r2,#4]
000142  e005              B        |L1.336|
                  |L1.324|
;;;175    	}
;;;176    	else
;;;177    	{
;;;178    		regVal = LPC_CT32B1->TCR;
000144  4aaf              LDR      r2,|L1.1028|
000146  6851              LDR      r1,[r2,#4]
;;;179    		regVal |= BIT1;
000148  2202              MOVS     r2,#2
00014a  4311              ORRS     r1,r1,r2
;;;180    		LPC_CT32B1->TCR = regVal;
00014c  4aad              LDR      r2,|L1.1028|
00014e  6051              STR      r1,[r2,#4]
                  |L1.336|
;;;181    	}  
;;;182    }
000150  4770              BX       lr
;;;183    
                          ENDP

                  nsAPI_Timer32_Setting_MatchFunction PROC
;;;192    ******************************************************************************/
;;;193    void nsAPI_Timer32_Setting_MatchFunction(U8 timer_num, U8 match_enable, U8 location)
000152  b510              PUSH     {r4,lr}
;;;194    {
;;;195    	if(timer_num == 0)
000154  2800              CMP      r0,#0
000156  d165              BNE      |L1.548|
;;;196    	{
;;;197    		if(match_enable & BIT0)
000158  07cb              LSLS     r3,r1,#31
00015a  0fdb              LSRS     r3,r3,#31
00015c  d01f              BEQ      |L1.414|
;;;198    		{
;;;199    			if(location == 0)
00015e  2a00              CMP      r2,#0
000160  d10c              BNE      |L1.380|
;;;200    			{
;;;201    				LPC_IOCON->PIO0_18 &= ~(BIT2|BIT1|BIT0);	
000162  4ba9              LDR      r3,|L1.1032|
000164  689b              LDR      r3,[r3,#8]
000166  08db              LSRS     r3,r3,#3
000168  00db              LSLS     r3,r3,#3
00016a  4ca7              LDR      r4,|L1.1032|
00016c  60a3              STR      r3,[r4,#8]
;;;202    				LPC_IOCON->PIO0_18 |= BIT1;/* Timer0_32 MAT0 */
00016e  4623              MOV      r3,r4
000170  689b              LDR      r3,[r3,#8]
000172  2402              MOVS     r4,#2
000174  4323              ORRS     r3,r3,r4
000176  4ca4              LDR      r4,|L1.1032|
000178  60a3              STR      r3,[r4,#8]
00017a  e010              B        |L1.414|
                  |L1.380|
;;;203    			}
;;;204    			else if(location == 1)
00017c  2a01              CMP      r2,#1
00017e  d10e              BNE      |L1.414|
;;;205    			{
;;;206    				LPC_IOCON->PIO1_24 &= ~(BIT2|BIT1|BIT0);
000180  4ba1              LDR      r3,|L1.1032|
000182  3380              ADDS     r3,r3,#0x80
000184  681b              LDR      r3,[r3,#0]
000186  08db              LSRS     r3,r3,#3
000188  00db              LSLS     r3,r3,#3
00018a  4c9f              LDR      r4,|L1.1032|
00018c  3480              ADDS     r4,r4,#0x80
00018e  6023              STR      r3,[r4,#0]
;;;207    				LPC_IOCON->PIO1_24 |= BIT0;/* Timer0_32 MAT0 */
000190  4623              MOV      r3,r4
000192  681b              LDR      r3,[r3,#0]
000194  2401              MOVS     r4,#1
000196  4323              ORRS     r3,r3,r4
000198  4c9b              LDR      r4,|L1.1032|
00019a  3480              ADDS     r4,r4,#0x80
00019c  6023              STR      r3,[r4,#0]
                  |L1.414|
;;;208    			}
;;;209    		}
;;;210    		
;;;211    		if(match_enable & BIT1)
00019e  2302              MOVS     r3,#2
0001a0  4219              TST      r1,r3
0001a2  d002              BEQ      |L1.426|
;;;212    		{
;;;213    			if ( location == 0 )
0001a4  2a00              CMP      r2,#0
0001a6  d000              BEQ      |L1.426|
;;;214    			{
;;;215    				//LPC_IOCON->PIO0_19 &= ~(BIT2|BIT1|BIT0);
;;;216    				//LPC_IOCON->PIO0_19 |= BIT1;/* Timer0_32 MAT1 */
;;;217    			}
;;;218    			else if ( location == 1 )
0001a8  bf00              NOP      
                  |L1.426|
;;;219    			{
;;;220    				//LPC_IOCON->PIO1_25 &= ~(BIT2|BIT1|BIT0);
;;;221    				//LPC_IOCON->PIO1_25 |= BIT0;/* Timer0_32 MAT1 */
;;;222    			}
;;;223    		}
;;;224    		
;;;225    		if(match_enable & BIT2)
0001aa  2304              MOVS     r3,#4
0001ac  4219              TST      r1,r3
0001ae  d012              BEQ      |L1.470|
;;;226    		{
;;;227    			if ( location == 0 )
0001b0  2a00              CMP      r2,#0
0001b2  d10f              BNE      |L1.468|
;;;228    			{
;;;229    				LPC_IOCON->PIO0_1 &= ~(BIT2|BIT1|BIT0);
0001b4  4b94              LDR      r3,|L1.1032|
0001b6  3b40              SUBS     r3,r3,#0x40
0001b8  685b              LDR      r3,[r3,#4]
0001ba  08db              LSRS     r3,r3,#3
0001bc  00db              LSLS     r3,r3,#3
0001be  4c92              LDR      r4,|L1.1032|
0001c0  3c40              SUBS     r4,r4,#0x40
0001c2  6063              STR      r3,[r4,#4]
;;;230    				LPC_IOCON->PIO0_1 |= BIT1;/* Timer0_32 MAT2 */
0001c4  4623              MOV      r3,r4
0001c6  685b              LDR      r3,[r3,#4]
0001c8  2402              MOVS     r4,#2
0001ca  4323              ORRS     r3,r3,r4
0001cc  4c8e              LDR      r4,|L1.1032|
0001ce  3c40              SUBS     r4,r4,#0x40
0001d0  6063              STR      r3,[r4,#4]
0001d2  e000              B        |L1.470|
                  |L1.468|
;;;231    			}
;;;232    			else if ( location == 1 )
0001d4  bf00              NOP      
                  |L1.470|
;;;233    			{
;;;234    			//	LPC_IOCON->PIO1_26 &= ~(BIT2|BIT1|BIT0);
;;;235    			//	LPC_IOCON->PIO1_26 |= BIT0;/* Timer0_32 MAT2 */
;;;236    			}
;;;237    		}
;;;238    	
;;;239    		if(match_enable & BIT3)
0001d6  2308              MOVS     r3,#8
0001d8  4219              TST      r1,r3
0001da  d05a              BEQ      |L1.658|
;;;240    		{
;;;241    			if ( location == 0 )
0001dc  2a00              CMP      r2,#0
0001de  d10f              BNE      |L1.512|
;;;242    			{
;;;243    				LPC_IOCON->TDI_PIO0_11 &= ~(BIT2|BIT1|BIT0);
0001e0  4b89              LDR      r3,|L1.1032|
0001e2  3b40              SUBS     r3,r3,#0x40
0001e4  6adb              LDR      r3,[r3,#0x2c]
0001e6  08db              LSRS     r3,r3,#3
0001e8  00db              LSLS     r3,r3,#3
0001ea  4c87              LDR      r4,|L1.1032|
0001ec  3c40              SUBS     r4,r4,#0x40
0001ee  62e3              STR      r3,[r4,#0x2c]
;;;244    				LPC_IOCON->TDI_PIO0_11 |= (BIT1|BIT0);/* Timer0_32 MAT3 */
0001f0  4623              MOV      r3,r4
0001f2  6adb              LDR      r3,[r3,#0x2c]
0001f4  2403              MOVS     r4,#3
0001f6  4323              ORRS     r3,r3,r4
0001f8  4c83              LDR      r4,|L1.1032|
0001fa  3c40              SUBS     r4,r4,#0x40
0001fc  62e3              STR      r3,[r4,#0x2c]
0001fe  e048              B        |L1.658|
                  |L1.512|
;;;245    			}
;;;246    			else if ( location == 1 )
000200  2a01              CMP      r2,#1
000202  d146              BNE      |L1.658|
;;;247    			{
;;;248    				LPC_IOCON->PIO1_27 &= ~(BIT2|BIT1|BIT0);
000204  4b80              LDR      r3,|L1.1032|
000206  3380              ADDS     r3,r3,#0x80
000208  68db              LDR      r3,[r3,#0xc]
00020a  08db              LSRS     r3,r3,#3
00020c  00db              LSLS     r3,r3,#3
00020e  4c7e              LDR      r4,|L1.1032|
000210  3480              ADDS     r4,r4,#0x80
000212  60e3              STR      r3,[r4,#0xc]
;;;249    				LPC_IOCON->PIO1_27 |= BIT0;/* Timer0_32 MAT3 */
000214  4623              MOV      r3,r4
000216  68db              LDR      r3,[r3,#0xc]
000218  2401              MOVS     r4,#1
00021a  4323              ORRS     r3,r3,r4
00021c  4c7a              LDR      r4,|L1.1032|
00021e  3480              ADDS     r4,r4,#0x80
000220  60e3              STR      r3,[r4,#0xc]
000222  e036              B        |L1.658|
                  |L1.548|
;;;250    			}
;;;251    		}
;;;252    	}
;;;253    	else if(timer_num == 1)
000224  2801              CMP      r0,#1
000226  d134              BNE      |L1.658|
;;;254    	{
;;;255    		if(match_enable & BIT0)
000228  07cb              LSLS     r3,r1,#31
00022a  0fdb              LSRS     r3,r3,#31
00022c  d012              BEQ      |L1.596|
;;;256    		{
;;;257    			if(location == 0)
00022e  2a00              CMP      r2,#0
000230  d010              BEQ      |L1.596|
;;;258    			{
;;;259    				//LPC_IOCON->PIO1_0 &= ~0x07;
;;;260    				//LPC_IOCON->PIO1_0 |= 0x01;/* Timer1_32 MAT0 */
;;;261    			}
;;;262    			else if(location == 1)
000232  2a01              CMP      r2,#1
000234  d10e              BNE      |L1.596|
;;;263    			{
;;;264    				LPC_IOCON->TDO_PIO0_13 &= ~(BIT2|BIT1|BIT0);
000236  4b74              LDR      r3,|L1.1032|
000238  3b40              SUBS     r3,r3,#0x40
00023a  6b5b              LDR      r3,[r3,#0x34]
00023c  08db              LSRS     r3,r3,#3
00023e  00db              LSLS     r3,r3,#3
000240  4c71              LDR      r4,|L1.1032|
000242  3c40              SUBS     r4,r4,#0x40
000244  6363              STR      r3,[r4,#0x34]
;;;265    				LPC_IOCON->TDO_PIO0_13 |= (BIT1|BIT0);/* Timer1_32 MAT0 */
000246  4623              MOV      r3,r4
000248  6b5b              LDR      r3,[r3,#0x34]
00024a  2403              MOVS     r4,#3
00024c  4323              ORRS     r3,r3,r4
00024e  4c6e              LDR      r4,|L1.1032|
000250  3c40              SUBS     r4,r4,#0x40
000252  6363              STR      r3,[r4,#0x34]
                  |L1.596|
;;;266    			}
;;;267    		}
;;;268     
;;;269    		if(match_enable & BIT1)
000254  2302              MOVS     r3,#2
000256  4219              TST      r1,r3
000258  d002              BEQ      |L1.608|
;;;270    		{
;;;271    			if(location == 0)
00025a  2a00              CMP      r2,#0
00025c  d000              BEQ      |L1.608|
;;;272    			{
;;;273    				//LPC_IOCON->PIO1_1 &= ~0x07;
;;;274    				//LPC_IOCON->PIO1_1 |= 0x01;/* Timer1_32 MAT1 */
;;;275    			}
;;;276    			else if(location == 1)
00025e  bf00              NOP      
                  |L1.608|
;;;277    			{
;;;278    				//LPC_IOCON->TRST_PIO0_14 &= ~(BIT2|BIT1|BIT0);
;;;279    				//LPC_IOCON->TRST_PIO0_14 |= (BIT1|BIT0);/* Timer1_32 MAT1 */
;;;280    			}
;;;281    		}
;;;282    	
;;;283    		if(match_enable & BIT2)
000260  2304              MOVS     r3,#4
000262  4219              TST      r1,r3
000264  d002              BEQ      |L1.620|
;;;284    		{
;;;285    			if(location == 0)
000266  2a00              CMP      r2,#0
000268  d000              BEQ      |L1.620|
;;;286    			{
;;;287    				//LPC_IOCON->PIO1_2 &= ~0x07;
;;;288    				//LPC_IOCON->PIO1_2 |= 0x01;/* Timer1_32 MAT2 */
;;;289    			}
;;;290    			else if ( location == 1 )
00026a  bf00              NOP      
                  |L1.620|
;;;291    			{
;;;292    #if __SWD_DISABLED
;;;293    				LPC_IOCON->SWDIO_PIO0_15 &= ~(BIT2|BIT1|BIT0);
;;;294    				LPC_IOCON->SWDIO_PIO0_15 |= (BIT1|BIT0);/* Timer1_32 MAT2 */
;;;295    #endif
;;;296    			}
;;;297    		}
;;;298    	
;;;299    		if(match_enable & BIT3)
00026c  2308              MOVS     r3,#8
00026e  4219              TST      r1,r3
000270  d00f              BEQ      |L1.658|
;;;300    		{
;;;301    			if(location == 0)
000272  2a00              CMP      r2,#0
000274  d00d              BEQ      |L1.658|
;;;302    			{
;;;303    				//LPC_IOCON->PIO1_3 &= ~0x07;
;;;304    				//LPC_IOCON->PIO1_3 |= 0x01;/* Timer1_32 MAT3 */
;;;305    			}
;;;306    			else if(location == 1)
000276  2a01              CMP      r2,#1
000278  d10b              BNE      |L1.658|
;;;307    			{
;;;308    				LPC_IOCON->PIO0_16 &= ~(BIT2|BIT1|BIT0);
00027a  4b63              LDR      r3,|L1.1032|
00027c  681b              LDR      r3,[r3,#0]
00027e  08db              LSRS     r3,r3,#3
000280  00db              LSLS     r3,r3,#3
000282  4c61              LDR      r4,|L1.1032|
000284  6023              STR      r3,[r4,#0]
;;;309    				LPC_IOCON->PIO0_16 |= BIT1;/* Timer1_32 MAT3 */
000286  4623              MOV      r3,r4
000288  681b              LDR      r3,[r3,#0]
00028a  2402              MOVS     r4,#2
00028c  4323              ORRS     r3,r3,r4
00028e  4c5e              LDR      r4,|L1.1032|
000290  6023              STR      r3,[r4,#0]
                  |L1.658|
;;;310    			}
;;;311    		}
;;;312    	}	
;;;313    }
000292  bd10              POP      {r4,pc}
;;;314    
                          ENDP

                  nsAPI_Timer32PWM_Breathing_ReSetting PROC
;;;315    void nsAPI_Timer32PWM_Breathing_ReSetting(U8 u8Breathing)
000294  2101              MOVS     r1,#1
;;;316    {
;;;317    	g_Timer32_LED_Setting.LEDStatusType = LED_BREATHING;
000296  4a5d              LDR      r2,|L1.1036|
000298  7011              STRB     r1,[r2,#0]
;;;318    	g_Timer32_LED_Setting.BreathingStatusType = 0;
00029a  2100              MOVS     r1,#0
00029c  7051              STRB     r1,[r2,#1]
;;;319    	g_Timer32_LED_Setting.BreathingDelayCount = 0;
00029e  6051              STR      r1,[r2,#4]  ; g_Timer32_LED_Setting
;;;320    	g_Timer32_LED_Setting.BreathingStepStatus &= ~BREATHING_STEP_RESETTING;
0002a0  4611              MOV      r1,r2
0002a2  78c9              LDRB     r1,[r1,#3]  ; g_Timer32_LED_Setting
0002a4  0849              LSRS     r1,r1,#1
0002a6  0049              LSLS     r1,r1,#1
0002a8  70d1              STRB     r1,[r2,#3]
;;;321    	g_Timer32_LED_Setting.BreathingStep = BREATHING_STEP*u8Breathing;
0002aa  0641              LSLS     r1,r0,#25
0002ac  0e09              LSRS     r1,r1,#24
0002ae  7091              STRB     r1,[r2,#2]
;;;322    }
0002b0  4770              BX       lr
;;;323    
                          ENDP

                  nsAPI_Timer32PWM_Init PROC
;;;335    ******************************************************************************/
;;;336    void nsAPI_Timer32PWM_Init(U8 timer_num, U32 period, U8 match_enable)
0002b2  b5f8              PUSH     {r3-r7,lr}
;;;337    {
0002b4  4604              MOV      r4,r0
0002b6  460d              MOV      r5,r1
0002b8  4616              MOV      r6,r2
;;;338    	NDrv_Timer32_Disable(timer_num);
0002ba  4620              MOV      r0,r4
0002bc  f7fffffe          BL       NDrv_Timer32_Disable
;;;339    	
;;;340    	nsAPI_Timer32PWM_Breathing_ReSetting(1);
0002c0  2001              MOVS     r0,#1
0002c2  f7fffffe          BL       nsAPI_Timer32PWM_Breathing_ReSetting
;;;341    
;;;342    	if(timer_num == 1)
0002c6  2c01              CMP      r4,#1
0002c8  d126              BNE      |L1.792|
;;;343    	{
;;;344    		U32 u32Timer32_1_period; 
;;;345    
;;;346    		LPC_SYSCON->SYSAHBCLKCTRL |= BIT10;
0002ca  4851              LDR      r0,|L1.1040|
0002cc  6800              LDR      r0,[r0,#0]
0002ce  02a1              LSLS     r1,r4,#10
0002d0  4308              ORRS     r0,r0,r1
0002d2  494f              LDR      r1,|L1.1040|
0002d4  6008              STR      r0,[r1,#0]
;;;347    
;;;348    		/* Setup the external match register */
;;;349    		LPC_CT32B1->EMR = (1 << EMC2)|(2 << EMC1)|(1 << EMC0);
0002d6  20ff              MOVS     r0,#0xff
0002d8  3091              ADDS     r0,r0,#0x91
0002da  494a              LDR      r1,|L1.1028|
0002dc  63c8              STR      r0,[r1,#0x3c]
;;;350    
;;;351    		/* Setup the outputs */
;;;352    		/* If match0 is enabled, set the output, use location 0 for test. */
;;;353    		nsAPI_Timer32_Setting_MatchFunction(timer_num,match_enable,1);
0002de  2201              MOVS     r2,#1
0002e0  4631              MOV      r1,r6
0002e2  4620              MOV      r0,r4
0002e4  f7fffffe          BL       nsAPI_Timer32_Setting_MatchFunction
;;;354    		
;;;355    		LPC_CT32B1->PWMC |= match_enable;
0002e8  4846              LDR      r0,|L1.1028|
0002ea  3040              ADDS     r0,r0,#0x40
0002ec  6b40              LDR      r0,[r0,#0x34]
0002ee  4330              ORRS     r0,r0,r6
0002f0  4944              LDR      r1,|L1.1028|
0002f2  3140              ADDS     r1,r1,#0x40
0002f4  6348              STR      r0,[r1,#0x34]
;;;356    		/* Setup the match registers */
;;;357    		/* set the period value to a global variable */
;;;358    		u32Timer32_1_period = period*Timer32_IntervalmS;		
0002f6  207d              MOVS     r0,#0x7d
0002f8  00c0              LSLS     r0,r0,#3
0002fa  4368              MULS     r0,r5,r0
0002fc  4607              MOV      r7,r0
;;;359    		
;;;360    		LPC_CT32B1->MR0 = u32Timer32_1_period / 2;
0002fe  0878              LSRS     r0,r7,#1
000300  4940              LDR      r1,|L1.1028|
000302  6188              STR      r0,[r1,#0x18]
;;;361    		LPC_CT32B1->MR1 = u32Timer32_1_period / 2;
000304  0879              LSRS     r1,r7,#1
000306  483f              LDR      r0,|L1.1028|
000308  61c1              STR      r1,[r0,#0x1c]
;;;362    		LPC_CT32B1->MR2 = u32Timer32_1_period / 2;
00030a  0879              LSRS     r1,r7,#1
00030c  6201              STR      r1,[r0,#0x20]
;;;363    		LPC_CT32B1->MR3 = u32Timer32_1_period;		
00030e  6247              STR      r7,[r0,#0x24]
;;;364    		LPC_CT32B1->MCR = BIT10;/* Reset on MR3 */
000310  1500              ASRS     r0,r0,#20
000312  493c              LDR      r1,|L1.1028|
000314  6148              STR      r0,[r1,#0x14]
;;;365    	}
000316  e032              B        |L1.894|
                  |L1.792|
;;;366    	else
;;;367    	{
;;;368    		U32 u32Timer32_0_period;
;;;369    		/* Some of the I/O pins need to be clearfully planned if
;;;370    		you use below module because JTAG and TIMER CAP/MAT pins are muxed. */
;;;371    		LPC_SYSCON->SYSAHBCLKCTRL |= BIT9;
000318  483d              LDR      r0,|L1.1040|
00031a  6800              LDR      r0,[r0,#0]
00031c  2101              MOVS     r1,#1
00031e  0249              LSLS     r1,r1,#9
000320  4308              ORRS     r0,r0,r1
000322  493b              LDR      r1,|L1.1040|
000324  6008              STR      r0,[r1,#0]
;;;372    
;;;373    		LPC_CT32B0->PR = Timer32_MHz_Prescale;
000326  493b              LDR      r1,|L1.1044|
000328  483b              LDR      r0,|L1.1048|
00032a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00032c  f7fffffe          BL       __aeabi_uidivmod
000330  4933              LDR      r1,|L1.1024|
000332  60c8              STR      r0,[r1,#0xc]
;;;374    		
;;;375    		/* Setup the external match register */
;;;376    		LPC_CT32B0->EMR = (3 << EMC2)|(3 << EMC1)|(3 << EMC0);
000334  203f              MOVS     r0,#0x3f
000336  0100              LSLS     r0,r0,#4
000338  63c8              STR      r0,[r1,#0x3c]
;;;377    
;;;378    		/* Setup the outputs */
;;;379    		/* If match0 is enabled, set the output, use location 0 for test. */
;;;380    		nsAPI_Timer32_Setting_MatchFunction(timer_num, match_enable,1);
00033a  2201              MOVS     r2,#1
00033c  4631              MOV      r1,r6
00033e  4620              MOV      r0,r4
000340  f7fffffe          BL       nsAPI_Timer32_Setting_MatchFunction
;;;381    
;;;382    		/* Enable the selected PWMs and enable Match3 */
;;;383    		LPC_CT32B0->PWMC = match_enable;
000344  482e              LDR      r0,|L1.1024|
000346  3040              ADDS     r0,r0,#0x40
000348  6346              STR      r6,[r0,#0x34]
;;;384    
;;;385    		/* Setup the match registers */
;;;386    		/* set the period value to a global variable */
;;;387    		u32Timer32_0_period = period*Timer32_IntervalmS;	
00034a  207d              MOVS     r0,#0x7d
00034c  00c0              LSLS     r0,r0,#3
00034e  4368              MULS     r0,r5,r0
000350  4607              MOV      r7,r0
;;;388    
;;;389    		if(u32Timer32_0_period < BREATHING_FREQ_GAP)
000352  2f64              CMP      r7,#0x64
000354  d200              BCS      |L1.856|
;;;390    		u32Timer32_0_period = BREATHING_FREQ_GAP;	
000356  2764              MOVS     r7,#0x64
                  |L1.856|
;;;391    		
;;;392    		LPC_CT32B0->MR0 = u32Timer32_0_period -BREATHING_FREQ_GAP;
000358  4638              MOV      r0,r7
00035a  3864              SUBS     r0,r0,#0x64
00035c  4928              LDR      r1,|L1.1024|
00035e  6188              STR      r0,[r1,#0x18]
;;;393    		LPC_CT32B0->MR1 = u32Timer32_0_period -BREATHING_FREQ_GAP;
000360  4601              MOV      r1,r0
000362  4827              LDR      r0,|L1.1024|
000364  61c1              STR      r1,[r0,#0x1c]
;;;394    		LPC_CT32B0->MR2 = u32Timer32_0_period -BREATHING_FREQ_GAP;
000366  6201              STR      r1,[r0,#0x20]
;;;395    		LPC_CT32B0->MR3 = u32Timer32_0_period;		
000368  6247              STR      r7,[r0,#0x24]
;;;396    		LPC_CT32B0->MCR = BIT10;	/* Reset on MR3 */	
00036a  1500              ASRS     r0,r0,#20
00036c  4924              LDR      r1,|L1.1024|
00036e  6148              STR      r0,[r1,#0x14]
;;;397    		
;;;398    		g_Timer32_LED_Setting.CurBreathingFreq = u32Timer32_0_period -BREATHING_FREQ_GAP;
000370  4638              MOV      r0,r7
000372  3864              SUBS     r0,r0,#0x64
000374  4925              LDR      r1,|L1.1036|
000376  6088              STR      r0,[r1,#8]  ; g_Timer32_LED_Setting
;;;399    		g_Timer32_LED_Setting.PreBreathingFreq = u32Timer32_0_period;		
000378  4608              MOV      r0,r1
00037a  60c7              STR      r7,[r0,#0xc]  ; g_Timer32_LED_Setting
;;;400    	}
00037c  bf00              NOP      
                  |L1.894|
;;;401    	
;;;402    	NDrv_Timer32_Reset(timer_num);
00037e  4620              MOV      r0,r4
000380  f7fffffe          BL       NDrv_Timer32_Reset
;;;403    	NDrv_Timer32_Enable(timer_num);
000384  4620              MOV      r0,r4
000386  f7fffffe          BL       NDrv_Timer32_Enable
;;;404    }
00038a  bdf8              POP      {r3-r7,pc}
;;;405    
                          ENDP

                  NDrv_Timer32PWM_ReSettingMatch PROC
;;;415    ******************************************************************************/
;;;416    void NDrv_Timer32PWM_ReSettingMatch(U8 timer_num, U32 period)
00038c  b510              PUSH     {r4,lr}
;;;417    {
;;;418    	U32 u32Timer32_period;
;;;419    
;;;420    	u32Timer32_period = period*Timer32_IntervalmS;	
00038e  237d              MOVS     r3,#0x7d
000390  00db              LSLS     r3,r3,#3
000392  434b              MULS     r3,r1,r3
000394  461a              MOV      r2,r3
;;;421    
;;;422    	if(u32Timer32_period == 0)
000396  2a00              CMP      r2,#0
000398  d100              BNE      |L1.924|
;;;423    	u32Timer32_period = 10;	  
00039a  220a              MOVS     r2,#0xa
                  |L1.924|
;;;424    
;;;425    	if(timer_num)
00039c  2800              CMP      r0,#0
00039e  d009              BEQ      |L1.948|
;;;426    	{    
;;;427    		LPC_CT32B1->MR0 = u32Timer32_period / 2;    
0003a0  0853              LSRS     r3,r2,#1
0003a2  4c18              LDR      r4,|L1.1028|
0003a4  61a3              STR      r3,[r4,#0x18]
;;;428    		LPC_CT32B1->MR1 = u32Timer32_period / 2;     
0003a6  0854              LSRS     r4,r2,#1
0003a8  4b16              LDR      r3,|L1.1028|
0003aa  61dc              STR      r4,[r3,#0x1c]
;;;429    		LPC_CT32B1->MR2 = u32Timer32_period / 2;     
0003ac  0854              LSRS     r4,r2,#1
0003ae  621c              STR      r4,[r3,#0x20]
;;;430    		LPC_CT32B1->MR3 = u32Timer32_period;    
0003b0  625a              STR      r2,[r3,#0x24]
0003b2  e008              B        |L1.966|
                  |L1.948|
;;;431    	}
;;;432    	else 
;;;433    	{   
;;;434    		LPC_CT32B0->MR0 = u32Timer32_period / 2;     
0003b4  0853              LSRS     r3,r2,#1
0003b6  4c12              LDR      r4,|L1.1024|
0003b8  61a3              STR      r3,[r4,#0x18]
;;;435    		LPC_CT32B0->MR1 = u32Timer32_period / 2;   
0003ba  0854              LSRS     r4,r2,#1
0003bc  4b10              LDR      r3,|L1.1024|
0003be  61dc              STR      r4,[r3,#0x1c]
;;;436    		LPC_CT32B0->MR2 = u32Timer32_period / 2;   
0003c0  0854              LSRS     r4,r2,#1
0003c2  621c              STR      r4,[r3,#0x20]
;;;437    		LPC_CT32B0->MR3 = u32Timer32_period;    
0003c4  625a              STR      r2,[r3,#0x24]
                  |L1.966|
;;;438    	}
;;;439    	
;;;440    	LPC_CT32B0->MCR = BIT10;	/* Reset on MR3 */
0003c6  2301              MOVS     r3,#1
0003c8  029b              LSLS     r3,r3,#10
0003ca  4c0d              LDR      r4,|L1.1024|
0003cc  6163              STR      r3,[r4,#0x14]
;;;441    }
0003ce  bd10              POP      {r4,pc}
;;;442    
                          ENDP

                  NDrv_Timer32PWM_Breathing PROC
;;;443    void NDrv_Timer32PWM_Breathing(void)
0003d0  490e              LDR      r1,|L1.1036|
;;;444    {
;;;445    	U32 u32Timer32_period = g_Timer32_LED_Setting.CurBreathingFreq;
0003d2  6888              LDR      r0,[r1,#8]  ; g_Timer32_LED_Setting
;;;446    	
;;;447           if(g_Timer32_LED_Setting.BreathingStatusType)
0003d4  7849              LDRB     r1,[r1,#1]  ; g_Timer32_LED_Setting
0003d6  2900              CMP      r1,#0
0003d8  d02e              BEQ      |L1.1080|
;;;448           {        		
;;;449    	   
;;;450    		if(u32Timer32_period <  (g_Timer32_LED_Setting.PreBreathingFreq -BREATHING_FREQ_GAP*2))
0003da  490c              LDR      r1,|L1.1036|
0003dc  68c9              LDR      r1,[r1,#0xc]  ; g_Timer32_LED_Setting
0003de  39c8              SUBS     r1,r1,#0xc8
0003e0  4281              CMP      r1,r0
0003e2  d91b              BLS      |L1.1052|
;;;451    		{
;;;452    			u32Timer32_period += (g_Timer32_LED_Setting.BreathingStep*BREATHING_STEP);			
0003e4  4909              LDR      r1,|L1.1036|
0003e6  7889              LDRB     r1,[r1,#2]  ; g_Timer32_LED_Setting
0003e8  0049              LSLS     r1,r1,#1
0003ea  1808              ADDS     r0,r1,r0
;;;453                       
;;;454    			LPC_CT32B0->MR0 = u32Timer32_period;	 
0003ec  4904              LDR      r1,|L1.1024|
0003ee  6188              STR      r0,[r1,#0x18]
;;;455    			LPC_CT32B0->MR1 = u32Timer32_period;   
0003f0  61c8              STR      r0,[r1,#0x1c]
;;;456    			LPC_CT32B0->MR2 = u32Timer32_period;   
0003f2  6208              STR      r0,[r1,#0x20]
;;;457    
;;;458    			g_Timer32_LED_Setting.CurBreathingFreq = u32Timer32_period; 	
0003f4  4905              LDR      r1,|L1.1036|
0003f6  6088              STR      r0,[r1,#8]  ; g_Timer32_LED_Setting
;;;459    			g_Timer32_LED_Setting.BreathingDelayCount = BREATHING_DELAY_TIMER / 2;
0003f8  2114              MOVS     r1,#0x14
0003fa  4a04              LDR      r2,|L1.1036|
0003fc  6051              STR      r1,[r2,#4]  ; g_Timer32_LED_Setting
0003fe  e03c              B        |L1.1146|
                  |L1.1024|
                          DCD      0x40014000
                  |L1.1028|
                          DCD      0x40018000
                  |L1.1032|
                          DCD      0x40044040
                  |L1.1036|
                          DCD      g_Timer32_LED_Setting
                  |L1.1040|
                          DCD      0x40048080
                  |L1.1044|
                          DCD      0x000f4240
                  |L1.1048|
                          DCD      SystemCoreClock
                  |L1.1052|
;;;460    		}
;;;461    		else
;;;462    		{       
;;;463    			if(g_Timer32_LED_Setting.BreathingDelayCount > 0)
00041c  4931              LDR      r1,|L1.1252|
00041e  6849              LDR      r1,[r1,#4]  ; g_Timer32_LED_Setting
000420  2900              CMP      r1,#0
000422  d005              BEQ      |L1.1072|
;;;464    			g_Timer32_LED_Setting.BreathingDelayCount --;
000424  492f              LDR      r1,|L1.1252|
000426  6849              LDR      r1,[r1,#4]  ; g_Timer32_LED_Setting
000428  1e49              SUBS     r1,r1,#1
00042a  4a2e              LDR      r2,|L1.1252|
00042c  6051              STR      r1,[r2,#4]  ; g_Timer32_LED_Setting
00042e  e024              B        |L1.1146|
                  |L1.1072|
;;;465    			else  
;;;466    			g_Timer32_LED_Setting.BreathingStatusType = 0;						
000430  2100              MOVS     r1,#0
000432  4a2c              LDR      r2,|L1.1252|
000434  7051              STRB     r1,[r2,#1]
000436  e020              B        |L1.1146|
                  |L1.1080|
;;;467    		}	
;;;468           }
;;;469           else
;;;470           { 	 
;;;471            
;;;472                 if((u32Timer32_period - (g_Timer32_LED_Setting.BreathingStep*BREATHING_STEP)) > BREATHING_FREQ_GAP /4)	        
000438  492a              LDR      r1,|L1.1252|
00043a  7889              LDRB     r1,[r1,#2]  ; g_Timer32_LED_Setting
00043c  0049              LSLS     r1,r1,#1
00043e  1a41              SUBS     r1,r0,r1
000440  2919              CMP      r1,#0x19
000442  d90d              BLS      |L1.1120|
;;;473    		{
;;;474    			u32Timer32_period -= (g_Timer32_LED_Setting.BreathingStep*BREATHING_STEP);					
000444  4927              LDR      r1,|L1.1252|
000446  7889              LDRB     r1,[r1,#2]  ; g_Timer32_LED_Setting
000448  0049              LSLS     r1,r1,#1
00044a  1a40              SUBS     r0,r0,r1
;;;475                           
;;;476    			LPC_CT32B0->MR0 = u32Timer32_period;	 
00044c  4926              LDR      r1,|L1.1256|
00044e  6188              STR      r0,[r1,#0x18]
;;;477    			LPC_CT32B0->MR1 = u32Timer32_period;   
000450  61c8              STR      r0,[r1,#0x1c]
;;;478    			LPC_CT32B0->MR2 = u32Timer32_period;
000452  6208              STR      r0,[r1,#0x20]
;;;479    
;;;480    			g_Timer32_LED_Setting.CurBreathingFreq = u32Timer32_period; 	
000454  4923              LDR      r1,|L1.1252|
000456  6088              STR      r0,[r1,#8]  ; g_Timer32_LED_Setting
;;;481    			g_Timer32_LED_Setting.BreathingDelayCount = BREATHING_DELAY_TIMER;
000458  2128              MOVS     r1,#0x28
00045a  4a22              LDR      r2,|L1.1252|
00045c  6051              STR      r1,[r2,#4]  ; g_Timer32_LED_Setting
00045e  e00c              B        |L1.1146|
                  |L1.1120|
;;;482    		}
;;;483    		else
;;;484    		{          
;;;485    			if(g_Timer32_LED_Setting.BreathingDelayCount > 0)
000460  4920              LDR      r1,|L1.1252|
000462  6849              LDR      r1,[r1,#4]  ; g_Timer32_LED_Setting
000464  2900              CMP      r1,#0
000466  d005              BEQ      |L1.1140|
;;;486    			g_Timer32_LED_Setting.BreathingDelayCount --;
000468  491e              LDR      r1,|L1.1252|
00046a  6849              LDR      r1,[r1,#4]  ; g_Timer32_LED_Setting
00046c  1e49              SUBS     r1,r1,#1
00046e  4a1d              LDR      r2,|L1.1252|
000470  6051              STR      r1,[r2,#4]  ; g_Timer32_LED_Setting
000472  e002              B        |L1.1146|
                  |L1.1140|
;;;487    			else  
;;;488    			g_Timer32_LED_Setting.BreathingStatusType = 1;	
000474  2101              MOVS     r1,#1
000476  4a1b              LDR      r2,|L1.1252|
000478  7051              STRB     r1,[r2,#1]
                  |L1.1146|
;;;489    		}	
;;;490           }	
;;;491    }
00047a  4770              BX       lr
;;;492    
                          ENDP

                  init_timer32 PROC
;;;493    void init_timer32( U32 timer )
00047c  b500              PUSH     {lr}
;;;494    {
00047e  4603              MOV      r3,r0
;;;495    //
;;;496    // 48000UL = 1ms
;;;497    // 4800UL  = 100us
;;;498    // 480UL   = 10uS
;;;499    // Notes: <Frequency modulation>: We are using 480UL as default to measure 1000Hz
;;;500    //         for 2ms rising edge to rising edge, readback is 203 => 203 x 10uS = 2.03ms
;;;501    
;;;502    		NVIC_DisableIRQ(TIMER_32_0_IRQn);
000480  bf00              NOP      
000482  2112              MOVS     r1,#0x12
000484  2001              MOVS     r0,#1
000486  4088              LSLS     r0,r0,r1
000488  4918              LDR      r1,|L1.1260|
00048a  6008              STR      r0,[r1,#0]
00048c  bf00              NOP      
;;;503    		NDrv_Timer32_Reset(Timer32_0);
00048e  2000              MOVS     r0,#0
000490  f7fffffe          BL       NDrv_Timer32_Reset
;;;504    
;;;505    	    LPC_SYSCON->SYSAHBCLKCTRL |= BIT9;
000494  4816              LDR      r0,|L1.1264|
000496  6800              LDR      r0,[r0,#0]
000498  2101              MOVS     r1,#1
00049a  0249              LSLS     r1,r1,#9
00049c  4308              ORRS     r0,r0,r1
00049e  4914              LDR      r1,|L1.1264|
0004a0  6008              STR      r0,[r1,#0]
;;;506    		LPC_CT32B0->PR = timer;
0004a2  4811              LDR      r0,|L1.1256|
0004a4  60c3              STR      r3,[r0,#0xc]
;;;507    		
;;;508    		LPC_IOCON->PIO0_17 = (1<<1)|(2<<3);//CT32B0_CAP0;
0004a6  2012              MOVS     r0,#0x12
0004a8  4912              LDR      r1,|L1.1268|
0004aa  6048              STR      r0,[r1,#4]
;;;509    		LPC_CT32B0->CTCR |= 0;//CAP0|CAP_MODE_BOTH_EDGE;	// Timer mode 
0004ac  480e              LDR      r0,|L1.1256|
0004ae  3040              ADDS     r0,r0,#0x40
0004b0  6b00              LDR      r0,[r0,#0x30]
0004b2  490d              LDR      r1,|L1.1256|
0004b4  3140              ADDS     r1,r1,#0x40
0004b6  6308              STR      r0,[r1,#0x30]
;;;510    		LPC_CT32B0->CCR |= 5;//CAP0FE|CAP0RE;				// Capture 0 on rising edge, interrupt enable.
0004b8  480b              LDR      r0,|L1.1256|
0004ba  6a80              LDR      r0,[r0,#0x28]
0004bc  2105              MOVS     r1,#5
0004be  4308              ORRS     r0,r0,r1
0004c0  4909              LDR      r1,|L1.1256|
0004c2  6288              STR      r0,[r1,#0x28]
;;;511    		//LPC_CT32B0->MCR |= MR0I;						// Interrupt on MR0
;;;512    		LPC_CT32B0->TCR |= 1;//CEN;							// Start counting
0004c4  4608              MOV      r0,r1
0004c6  6840              LDR      r0,[r0,#4]
0004c8  2101              MOVS     r1,#1
0004ca  4308              ORRS     r0,r0,r1
0004cc  4906              LDR      r1,|L1.1256|
0004ce  6048              STR      r0,[r1,#4]
;;;513    		
;;;514    		NVIC_EnableIRQ(TIMER_32_0_IRQn); // Enable the TIMER0 Interrupt
0004d0  bf00              NOP      
0004d2  2112              MOVS     r1,#0x12
0004d4  2001              MOVS     r0,#1
0004d6  4088              LSLS     r0,r0,r1
0004d8  4904              LDR      r1,|L1.1260|
0004da  3980              SUBS     r1,r1,#0x80
0004dc  6008              STR      r0,[r1,#0]
0004de  bf00              NOP      
;;;515    
;;;516    //	NDrv_Timer32_Enable(timer_num);
;;;517    }
0004e0  bd00              POP      {pc}
;;;518    
                          ENDP

0004e2  0000              DCW      0x0000
                  |L1.1252|
                          DCD      g_Timer32_LED_Setting
                  |L1.1256|
                          DCD      0x40014000
                  |L1.1260|
                          DCD      0xe000e180
                  |L1.1264|
                          DCD      0x40048080
                  |L1.1268|
                          DCD      0x40044040

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_Timer32_LED_Setting
                          %        16

;*** Start embedded assembler ***

#line 1 "Src\\timer32.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_timer32_c_884c2218____REV16|
#line 112 ".\\Inc\\core_cmInstr.h"
|__asm___9_timer32_c_884c2218____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_timer32_c_884c2218____REVSH|
#line 130
|__asm___9_timer32_c_884c2218____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
