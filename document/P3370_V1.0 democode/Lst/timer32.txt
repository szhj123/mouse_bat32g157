; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\timer32.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\obj\timer32.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\INC\NXP\LPC11Uxx -D__MICROLIB -D__UVISION_VERSION=536 -D__DEBUG_FLASH --omf_browse=.\obj\timer32.crf Src\timer32.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIMER32_0_IRQHandler PROC
;;;37     ******************************************************************************/
;;;38     void TIMER32_0_IRQHandler(void)
000000  48f8              LDR      r0,|L1.996|
;;;39     {
;;;40       if ( LPC_CT32B0->IR & (0x01<<0) )
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  0fc0              LSRS     r0,r0,#31
000008  2800              CMP      r0,#0
00000a  d005              BEQ      |L1.24|
;;;41       { 
;;;42     	LPC_CT32B0->IR |= (0x01<<0);
00000c  48f5              LDR      r0,|L1.996|
00000e  6800              LDR      r0,[r0,#0]
000010  2101              MOVS     r1,#1
000012  4308              ORRS     r0,r0,r1
000014  49f3              LDR      r1,|L1.996|
000016  6008              STR      r0,[r1,#0]
                  |L1.24|
;;;43     
;;;44       }
;;;45       if ( LPC_CT32B0->IR & (0x01<<1) )
000018  48f2              LDR      r0,|L1.996|
00001a  6800              LDR      r0,[r0,#0]
00001c  2102              MOVS     r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  2800              CMP      r0,#0
000022  d002              BEQ      |L1.42|
;;;46       {  
;;;47     	LPC_CT32B0->IR = 0x1<<1;			/* clear interrupt flag */
000024  2002              MOVS     r0,#2
000026  49ef              LDR      r1,|L1.996|
000028  6008              STR      r0,[r1,#0]
                  |L1.42|
;;;48       }
;;;49       if ( LPC_CT32B0->IR & (0x01<<2) )
00002a  48ee              LDR      r0,|L1.996|
00002c  6800              LDR      r0,[r0,#0]
00002e  2104              MOVS     r1,#4
000030  4008              ANDS     r0,r0,r1
000032  2800              CMP      r0,#0
000034  d002              BEQ      |L1.60|
;;;50       {  
;;;51     	LPC_CT32B0->IR = 0x1<<2;			/* clear interrupt flag */
000036  2004              MOVS     r0,#4
000038  49ea              LDR      r1,|L1.996|
00003a  6008              STR      r0,[r1,#0]
                  |L1.60|
;;;52       }
;;;53       if ( LPC_CT32B0->IR & (0x01<<3) )
00003c  48e9              LDR      r0,|L1.996|
00003e  6800              LDR      r0,[r0,#0]
000040  2108              MOVS     r1,#8
000042  4008              ANDS     r0,r0,r1
000044  2800              CMP      r0,#0
000046  d002              BEQ      |L1.78|
;;;54       {  
;;;55     	LPC_CT32B0->IR = 0x1<<3;			/* clear interrupt flag */
000048  2008              MOVS     r0,#8
00004a  49e6              LDR      r1,|L1.996|
00004c  6008              STR      r0,[r1,#0]
                  |L1.78|
;;;56       }
;;;57       if ( LPC_CT32B0->IR & (0x1<<4) )
00004e  48e5              LDR      r0,|L1.996|
000050  6800              LDR      r0,[r0,#0]
000052  2110              MOVS     r1,#0x10
000054  4008              ANDS     r0,r0,r1
000056  2800              CMP      r0,#0
000058  d002              BEQ      |L1.96|
;;;58       {  
;;;59     	LPC_CT32B0->IR = 0x1<<4;			/* clear interrupt flag */	
00005a  2010              MOVS     r0,#0x10
00005c  49e1              LDR      r1,|L1.996|
00005e  6008              STR      r0,[r1,#0]
                  |L1.96|
;;;60       }
;;;61       if ( LPC_CT32B0->IR & (0x1<<5) )
000060  48e0              LDR      r0,|L1.996|
000062  6800              LDR      r0,[r0,#0]
000064  2120              MOVS     r1,#0x20
000066  4008              ANDS     r0,r0,r1
000068  2800              CMP      r0,#0
00006a  d002              BEQ      |L1.114|
;;;62       {  
;;;63     	LPC_CT32B0->IR = 0x1<<5;			/* clear interrupt flag */
00006c  2020              MOVS     r0,#0x20
00006e  49dd              LDR      r1,|L1.996|
000070  6008              STR      r0,[r1,#0]
                  |L1.114|
;;;64       }
;;;65       if ( LPC_CT32B0->IR & (0x1<<6) )
000072  48dc              LDR      r0,|L1.996|
000074  6800              LDR      r0,[r0,#0]
000076  2140              MOVS     r1,#0x40
000078  4008              ANDS     r0,r0,r1
00007a  2800              CMP      r0,#0
00007c  d002              BEQ      |L1.132|
;;;66       {  
;;;67     	LPC_CT32B0->IR = 0x1<<6;			/* clear interrupt flag */
00007e  2040              MOVS     r0,#0x40
000080  49d8              LDR      r1,|L1.996|
000082  6008              STR      r0,[r1,#0]
                  |L1.132|
;;;68       }
;;;69       if ( LPC_CT32B0->IR & (0x1<<7) )
000084  48d7              LDR      r0,|L1.996|
000086  6800              LDR      r0,[r0,#0]
000088  2180              MOVS     r1,#0x80
00008a  4008              ANDS     r0,r0,r1
00008c  2800              CMP      r0,#0
00008e  d002              BEQ      |L1.150|
;;;70       {  
;;;71     	LPC_CT32B0->IR = 0x1<<7;			/* clear interrupt flag */
000090  2080              MOVS     r0,#0x80
000092  49d4              LDR      r1,|L1.996|
000094  6008              STR      r0,[r1,#0]
                  |L1.150|
;;;72       }
;;;73      
;;;74     }
000096  4770              BX       lr
;;;75     
                          ENDP

                  TIMER32_1_IRQHandler PROC
;;;84     ******************************************************************************/
;;;85     void TIMER32_1_IRQHandler(void)
000098  48d3              LDR      r0,|L1.1000|
;;;86     {
;;;87       if ( LPC_CT32B1->IR & (0x01<<0) )
00009a  6800              LDR      r0,[r0,#0]
00009c  07c0              LSLS     r0,r0,#31
00009e  0fc0              LSRS     r0,r0,#31
0000a0  2800              CMP      r0,#0
0000a2  d002              BEQ      |L1.170|
;;;88       {  
;;;89     	LPC_CT32B1->IR = 0x1<<0;			/* clear interrupt flag */
0000a4  2001              MOVS     r0,#1
0000a6  49d0              LDR      r1,|L1.1000|
0000a8  6008              STR      r0,[r1,#0]
                  |L1.170|
;;;90       }
;;;91       if ( LPC_CT32B1->IR & (0x01<<1) )
0000aa  48cf              LDR      r0,|L1.1000|
0000ac  6800              LDR      r0,[r0,#0]
0000ae  2102              MOVS     r1,#2
0000b0  4008              ANDS     r0,r0,r1
0000b2  2800              CMP      r0,#0
0000b4  d002              BEQ      |L1.188|
;;;92       {  
;;;93     	LPC_CT32B1->IR = 0x1<<1;			/* clear interrupt flag */
0000b6  2002              MOVS     r0,#2
0000b8  49cb              LDR      r1,|L1.1000|
0000ba  6008              STR      r0,[r1,#0]
                  |L1.188|
;;;94       }
;;;95       if ( LPC_CT32B1->IR & (0x01<<2) )
0000bc  48ca              LDR      r0,|L1.1000|
0000be  6800              LDR      r0,[r0,#0]
0000c0  2104              MOVS     r1,#4
0000c2  4008              ANDS     r0,r0,r1
0000c4  2800              CMP      r0,#0
0000c6  d002              BEQ      |L1.206|
;;;96       {  
;;;97     	LPC_CT32B1->IR = 0x1<<2;			/* clear interrupt flag */
0000c8  2004              MOVS     r0,#4
0000ca  49c7              LDR      r1,|L1.1000|
0000cc  6008              STR      r0,[r1,#0]
                  |L1.206|
;;;98       }
;;;99       if ( LPC_CT32B1->IR & (0x01<<3) )
0000ce  48c6              LDR      r0,|L1.1000|
0000d0  6800              LDR      r0,[r0,#0]
0000d2  2108              MOVS     r1,#8
0000d4  4008              ANDS     r0,r0,r1
0000d6  2800              CMP      r0,#0
0000d8  d002              BEQ      |L1.224|
;;;100      {  
;;;101    	LPC_CT32B1->IR = 0x1<<3;			/* clear interrupt flag */
0000da  2008              MOVS     r0,#8
0000dc  49c2              LDR      r1,|L1.1000|
0000de  6008              STR      r0,[r1,#0]
                  |L1.224|
;;;102      }
;;;103      if ( LPC_CT32B1->IR & (0x1<<4) )
0000e0  48c1              LDR      r0,|L1.1000|
0000e2  6800              LDR      r0,[r0,#0]
0000e4  2110              MOVS     r1,#0x10
0000e6  4008              ANDS     r0,r0,r1
0000e8  2800              CMP      r0,#0
0000ea  d002              BEQ      |L1.242|
;;;104      {  
;;;105    	LPC_CT32B1->IR = 0x1<<4;			/* clear interrupt flag */
0000ec  2010              MOVS     r0,#0x10
0000ee  49be              LDR      r1,|L1.1000|
0000f0  6008              STR      r0,[r1,#0]
                  |L1.242|
;;;106      }
;;;107      if ( LPC_CT32B1->IR & (0x1<<5) )
0000f2  48bd              LDR      r0,|L1.1000|
0000f4  6800              LDR      r0,[r0,#0]
0000f6  2120              MOVS     r1,#0x20
0000f8  4008              ANDS     r0,r0,r1
0000fa  2800              CMP      r0,#0
0000fc  d002              BEQ      |L1.260|
;;;108      {  
;;;109    	LPC_CT32B1->IR = 0x1<<5;			/* clear interrupt flag */
0000fe  2020              MOVS     r0,#0x20
000100  49b9              LDR      r1,|L1.1000|
000102  6008              STR      r0,[r1,#0]
                  |L1.260|
;;;110    	
;;;111      }
;;;112      if ( LPC_CT32B1->IR & (0x1<<6) )
000104  48b8              LDR      r0,|L1.1000|
000106  6800              LDR      r0,[r0,#0]
000108  2140              MOVS     r1,#0x40
00010a  4008              ANDS     r0,r0,r1
00010c  2800              CMP      r0,#0
00010e  d002              BEQ      |L1.278|
;;;113      {  
;;;114    	LPC_CT32B1->IR = 0x1<<6;			/* clear interrupt flag */
000110  2040              MOVS     r0,#0x40
000112  49b5              LDR      r1,|L1.1000|
000114  6008              STR      r0,[r1,#0]
                  |L1.278|
;;;115      }
;;;116      if ( LPC_CT32B1->IR & (0x1<<7) )
000116  48b4              LDR      r0,|L1.1000|
000118  6800              LDR      r0,[r0,#0]
00011a  2180              MOVS     r1,#0x80
00011c  4008              ANDS     r0,r0,r1
00011e  2800              CMP      r0,#0
000120  d002              BEQ      |L1.296|
;;;117      {  
;;;118    	LPC_CT32B1->IR = 0x1<<7;			/* clear interrupt flag */
000122  2080              MOVS     r0,#0x80
000124  49b0              LDR      r1,|L1.1000|
000126  6008              STR      r0,[r1,#0]
                  |L1.296|
;;;119      }
;;;120     
;;;121    }
000128  4770              BX       lr
;;;122    
                          ENDP

                  NDrv_Timer32_Enable PROC
;;;131    ******************************************************************************/
;;;132    void NDrv_Timer32_Enable(U8 timer_num)
00012a  2800              CMP      r0,#0
;;;133    {
;;;134    	if(timer_num == 0)  
00012c  d103              BNE      |L1.310|
;;;135    	LPC_CT32B0->TCR = 1;  
00012e  2101              MOVS     r1,#1
000130  4aac              LDR      r2,|L1.996|
000132  6051              STR      r1,[r2,#4]
000134  e002              B        |L1.316|
                  |L1.310|
;;;136    	else  
;;;137    	LPC_CT32B1->TCR = 1; 
000136  2101              MOVS     r1,#1
000138  4aab              LDR      r2,|L1.1000|
00013a  6051              STR      r1,[r2,#4]
                  |L1.316|
;;;138    }
00013c  4770              BX       lr
;;;139    
                          ENDP

                  NDrv_Timer32_Disable PROC
;;;148    ******************************************************************************/
;;;149    void NDrv_Timer32_Disable(U8 timer_num)
00013e  2800              CMP      r0,#0
;;;150    {
;;;151    	if(timer_num == 0)  
000140  d103              BNE      |L1.330|
;;;152    	LPC_CT32B0->TCR = 0;  
000142  2100              MOVS     r1,#0
000144  4aa7              LDR      r2,|L1.996|
000146  6051              STR      r1,[r2,#4]
000148  e002              B        |L1.336|
                  |L1.330|
;;;153    	else  
;;;154    	LPC_CT32B1->TCR = 0;  
00014a  2100              MOVS     r1,#0
00014c  4aa6              LDR      r2,|L1.1000|
00014e  6051              STR      r1,[r2,#4]
                  |L1.336|
;;;155    }
000150  4770              BX       lr
;;;156    
                          ENDP

                  NDrv_Timer32_Reset PROC
;;;165    ******************************************************************************/
;;;166    void NDrv_Timer32_Reset(U8 timer_num)
000152  4601              MOV      r1,r0
;;;167    {
;;;168    	U32 regVal;
;;;169    
;;;170    	if(timer_num == 0)
000154  2900              CMP      r1,#0
000156  d106              BNE      |L1.358|
;;;171    	{
;;;172    		regVal = LPC_CT32B0->TCR;
000158  4aa2              LDR      r2,|L1.996|
00015a  6850              LDR      r0,[r2,#4]
;;;173    		regVal |= BIT1;
00015c  2202              MOVS     r2,#2
00015e  4310              ORRS     r0,r0,r2
;;;174    		LPC_CT32B0->TCR = regVal;
000160  4aa0              LDR      r2,|L1.996|
000162  6050              STR      r0,[r2,#4]
000164  e005              B        |L1.370|
                  |L1.358|
;;;175    	}
;;;176    	else
;;;177    	{
;;;178    		regVal = LPC_CT32B1->TCR;
000166  4aa0              LDR      r2,|L1.1000|
000168  6850              LDR      r0,[r2,#4]
;;;179    		regVal |= BIT1;
00016a  2202              MOVS     r2,#2
00016c  4310              ORRS     r0,r0,r2
;;;180    		LPC_CT32B1->TCR = regVal;
00016e  4a9e              LDR      r2,|L1.1000|
000170  6050              STR      r0,[r2,#4]
                  |L1.370|
;;;181    	}  
;;;182    }
000172  4770              BX       lr
;;;183    
                          ENDP

                  nsAPI_Timer32_Setting_MatchFunction PROC
;;;192    ******************************************************************************/
;;;193    void nsAPI_Timer32_Setting_MatchFunction(U8 timer_num, U8 match_enable, U8 location)
000174  b510              PUSH     {r4,lr}
;;;194    {
;;;195    	if(timer_num == 0)
000176  2800              CMP      r0,#0
000178  d169              BNE      |L1.590|
;;;196    	{
;;;197    		if(match_enable & BIT0)
00017a  07cb              LSLS     r3,r1,#31
00017c  0fdb              LSRS     r3,r3,#31
00017e  2b00              CMP      r3,#0
000180  d01f              BEQ      |L1.450|
;;;198    		{
;;;199    			if(location == 0)
000182  2a00              CMP      r2,#0
000184  d10c              BNE      |L1.416|
;;;200    			{
;;;201    				LPC_IOCON->PIO0_18 &= ~(BIT2|BIT1|BIT0);	
000186  4b99              LDR      r3,|L1.1004|
000188  689b              LDR      r3,[r3,#8]
00018a  08db              LSRS     r3,r3,#3
00018c  00db              LSLS     r3,r3,#3
00018e  4c97              LDR      r4,|L1.1004|
000190  60a3              STR      r3,[r4,#8]
;;;202    				LPC_IOCON->PIO0_18 |= BIT1;/* Timer0_32 MAT0 */
000192  4623              MOV      r3,r4
000194  689b              LDR      r3,[r3,#8]
000196  2402              MOVS     r4,#2
000198  4323              ORRS     r3,r3,r4
00019a  4c94              LDR      r4,|L1.1004|
00019c  60a3              STR      r3,[r4,#8]
00019e  e010              B        |L1.450|
                  |L1.416|
;;;203    			}
;;;204    			else if(location == 1)
0001a0  2a01              CMP      r2,#1
0001a2  d10e              BNE      |L1.450|
;;;205    			{
;;;206    				LPC_IOCON->PIO1_24 &= ~(BIT2|BIT1|BIT0);
0001a4  4b91              LDR      r3,|L1.1004|
0001a6  3380              ADDS     r3,r3,#0x80
0001a8  681b              LDR      r3,[r3,#0]
0001aa  08db              LSRS     r3,r3,#3
0001ac  00db              LSLS     r3,r3,#3
0001ae  4c8f              LDR      r4,|L1.1004|
0001b0  3480              ADDS     r4,r4,#0x80
0001b2  6023              STR      r3,[r4,#0]
;;;207    				LPC_IOCON->PIO1_24 |= BIT0;/* Timer0_32 MAT0 */
0001b4  4623              MOV      r3,r4
0001b6  681b              LDR      r3,[r3,#0]
0001b8  2401              MOVS     r4,#1
0001ba  4323              ORRS     r3,r3,r4
0001bc  4c8b              LDR      r4,|L1.1004|
0001be  3480              ADDS     r4,r4,#0x80
0001c0  6023              STR      r3,[r4,#0]
                  |L1.450|
;;;208    			}
;;;209    		}
;;;210    		
;;;211    		if(match_enable & BIT1)
0001c2  2302              MOVS     r3,#2
0001c4  400b              ANDS     r3,r3,r1
0001c6  2b00              CMP      r3,#0
0001c8  d002              BEQ      |L1.464|
;;;212    		{
;;;213    			if ( location == 0 )
0001ca  2a00              CMP      r2,#0
0001cc  d000              BEQ      |L1.464|
;;;214    			{
;;;215    				//LPC_IOCON->PIO0_19 &= ~(BIT2|BIT1|BIT0);
;;;216    				//LPC_IOCON->PIO0_19 |= BIT1;/* Timer0_32 MAT1 */
;;;217    			}
;;;218    			else if ( location == 1 )
0001ce  bf00              NOP      
                  |L1.464|
;;;219    			{
;;;220    				//LPC_IOCON->PIO1_25 &= ~(BIT2|BIT1|BIT0);
;;;221    				//LPC_IOCON->PIO1_25 |= BIT0;/* Timer0_32 MAT1 */
;;;222    			}
;;;223    		}
;;;224    		
;;;225    		if(match_enable & BIT2)
0001d0  2304              MOVS     r3,#4
0001d2  400b              ANDS     r3,r3,r1
0001d4  2b00              CMP      r3,#0
0001d6  d012              BEQ      |L1.510|
;;;226    		{
;;;227    			if ( location == 0 )
0001d8  2a00              CMP      r2,#0
0001da  d10f              BNE      |L1.508|
;;;228    			{
;;;229    				LPC_IOCON->PIO0_1 &= ~(BIT2|BIT1|BIT0);
0001dc  4b83              LDR      r3,|L1.1004|
0001de  3b40              SUBS     r3,r3,#0x40
0001e0  685b              LDR      r3,[r3,#4]
0001e2  08db              LSRS     r3,r3,#3
0001e4  00db              LSLS     r3,r3,#3
0001e6  4c81              LDR      r4,|L1.1004|
0001e8  3c40              SUBS     r4,r4,#0x40
0001ea  6063              STR      r3,[r4,#4]
;;;230    				LPC_IOCON->PIO0_1 |= BIT1;/* Timer0_32 MAT2 */
0001ec  4623              MOV      r3,r4
0001ee  685b              LDR      r3,[r3,#4]
0001f0  2402              MOVS     r4,#2
0001f2  4323              ORRS     r3,r3,r4
0001f4  4c7d              LDR      r4,|L1.1004|
0001f6  3c40              SUBS     r4,r4,#0x40
0001f8  6063              STR      r3,[r4,#4]
0001fa  e000              B        |L1.510|
                  |L1.508|
;;;231    			}
;;;232    			else if ( location == 1 )
0001fc  bf00              NOP      
                  |L1.510|
;;;233    			{
;;;234    			//	LPC_IOCON->PIO1_26 &= ~(BIT2|BIT1|BIT0);
;;;235    			//	LPC_IOCON->PIO1_26 |= BIT0;/* Timer0_32 MAT2 */
;;;236    			}
;;;237    		}
;;;238    	
;;;239    		if(match_enable & BIT3)
0001fe  2308              MOVS     r3,#8
000200  400b              ANDS     r3,r3,r1
000202  2b00              CMP      r3,#0
000204  d05e              BEQ      |L1.708|
;;;240    		{
;;;241    			if ( location == 0 )
000206  2a00              CMP      r2,#0
000208  d10f              BNE      |L1.554|
;;;242    			{
;;;243    				LPC_IOCON->TDI_PIO0_11 &= ~(BIT2|BIT1|BIT0);
00020a  4b78              LDR      r3,|L1.1004|
00020c  3b40              SUBS     r3,r3,#0x40
00020e  6adb              LDR      r3,[r3,#0x2c]
000210  08db              LSRS     r3,r3,#3
000212  00db              LSLS     r3,r3,#3
000214  4c75              LDR      r4,|L1.1004|
000216  3c40              SUBS     r4,r4,#0x40
000218  62e3              STR      r3,[r4,#0x2c]
;;;244    				LPC_IOCON->TDI_PIO0_11 |= (BIT1|BIT0);/* Timer0_32 MAT3 */
00021a  4623              MOV      r3,r4
00021c  6adb              LDR      r3,[r3,#0x2c]
00021e  2403              MOVS     r4,#3
000220  4323              ORRS     r3,r3,r4
000222  4c72              LDR      r4,|L1.1004|
000224  3c40              SUBS     r4,r4,#0x40
000226  62e3              STR      r3,[r4,#0x2c]
000228  e04c              B        |L1.708|
                  |L1.554|
;;;245    			}
;;;246    			else if ( location == 1 )
00022a  2a01              CMP      r2,#1
00022c  d14a              BNE      |L1.708|
;;;247    			{
;;;248    				LPC_IOCON->PIO1_27 &= ~(BIT2|BIT1|BIT0);
00022e  4b6f              LDR      r3,|L1.1004|
000230  3380              ADDS     r3,r3,#0x80
000232  68db              LDR      r3,[r3,#0xc]
000234  08db              LSRS     r3,r3,#3
000236  00db              LSLS     r3,r3,#3
000238  4c6c              LDR      r4,|L1.1004|
00023a  3480              ADDS     r4,r4,#0x80
00023c  60e3              STR      r3,[r4,#0xc]
;;;249    				LPC_IOCON->PIO1_27 |= BIT0;/* Timer0_32 MAT3 */
00023e  4623              MOV      r3,r4
000240  68db              LDR      r3,[r3,#0xc]
000242  2401              MOVS     r4,#1
000244  4323              ORRS     r3,r3,r4
000246  4c69              LDR      r4,|L1.1004|
000248  3480              ADDS     r4,r4,#0x80
00024a  60e3              STR      r3,[r4,#0xc]
00024c  e03a              B        |L1.708|
                  |L1.590|
;;;250    			}
;;;251    		}
;;;252    	}
;;;253    	else if(timer_num == 1)
00024e  2801              CMP      r0,#1
000250  d138              BNE      |L1.708|
;;;254    	{
;;;255    		if(match_enable & BIT0)
000252  07cb              LSLS     r3,r1,#31
000254  0fdb              LSRS     r3,r3,#31
000256  2b00              CMP      r3,#0
000258  d012              BEQ      |L1.640|
;;;256    		{
;;;257    			if(location == 0)
00025a  2a00              CMP      r2,#0
00025c  d010              BEQ      |L1.640|
;;;258    			{
;;;259    				//LPC_IOCON->PIO1_0 &= ~0x07;
;;;260    				//LPC_IOCON->PIO1_0 |= 0x01;/* Timer1_32 MAT0 */
;;;261    			}
;;;262    			else if(location == 1)
00025e  2a01              CMP      r2,#1
000260  d10e              BNE      |L1.640|
;;;263    			{
;;;264    				LPC_IOCON->TDO_PIO0_13 &= ~(BIT2|BIT1|BIT0);
000262  4b62              LDR      r3,|L1.1004|
000264  3b40              SUBS     r3,r3,#0x40
000266  6b5b              LDR      r3,[r3,#0x34]
000268  08db              LSRS     r3,r3,#3
00026a  00db              LSLS     r3,r3,#3
00026c  4c5f              LDR      r4,|L1.1004|
00026e  3c40              SUBS     r4,r4,#0x40
000270  6363              STR      r3,[r4,#0x34]
;;;265    				LPC_IOCON->TDO_PIO0_13 |= (BIT1|BIT0);/* Timer1_32 MAT0 */
000272  4623              MOV      r3,r4
000274  6b5b              LDR      r3,[r3,#0x34]
000276  2403              MOVS     r4,#3
000278  4323              ORRS     r3,r3,r4
00027a  4c5c              LDR      r4,|L1.1004|
00027c  3c40              SUBS     r4,r4,#0x40
00027e  6363              STR      r3,[r4,#0x34]
                  |L1.640|
;;;266    			}
;;;267    		}
;;;268     
;;;269    		if(match_enable & BIT1)
000280  2302              MOVS     r3,#2
000282  400b              ANDS     r3,r3,r1
000284  2b00              CMP      r3,#0
000286  d002              BEQ      |L1.654|
;;;270    		{
;;;271    			if(location == 0)
000288  2a00              CMP      r2,#0
00028a  d000              BEQ      |L1.654|
;;;272    			{
;;;273    				//LPC_IOCON->PIO1_1 &= ~0x07;
;;;274    				//LPC_IOCON->PIO1_1 |= 0x01;/* Timer1_32 MAT1 */
;;;275    			}
;;;276    			else if(location == 1)
00028c  bf00              NOP      
                  |L1.654|
;;;277    			{
;;;278    				//LPC_IOCON->TRST_PIO0_14 &= ~(BIT2|BIT1|BIT0);
;;;279    				//LPC_IOCON->TRST_PIO0_14 |= (BIT1|BIT0);/* Timer1_32 MAT1 */
;;;280    			}
;;;281    		}
;;;282    	
;;;283    		if(match_enable & BIT2)
00028e  2304              MOVS     r3,#4
000290  400b              ANDS     r3,r3,r1
000292  2b00              CMP      r3,#0
000294  d002              BEQ      |L1.668|
;;;284    		{
;;;285    			if(location == 0)
000296  2a00              CMP      r2,#0
000298  d000              BEQ      |L1.668|
;;;286    			{
;;;287    				//LPC_IOCON->PIO1_2 &= ~0x07;
;;;288    				//LPC_IOCON->PIO1_2 |= 0x01;/* Timer1_32 MAT2 */
;;;289    			}
;;;290    			else if ( location == 1 )
00029a  bf00              NOP      
                  |L1.668|
;;;291    			{
;;;292    #if __SWD_DISABLED
;;;293    				LPC_IOCON->SWDIO_PIO0_15 &= ~(BIT2|BIT1|BIT0);
;;;294    				LPC_IOCON->SWDIO_PIO0_15 |= (BIT1|BIT0);/* Timer1_32 MAT2 */
;;;295    #endif
;;;296    			}
;;;297    		}
;;;298    	
;;;299    		if(match_enable & BIT3)
00029c  2308              MOVS     r3,#8
00029e  400b              ANDS     r3,r3,r1
0002a0  2b00              CMP      r3,#0
0002a2  d00f              BEQ      |L1.708|
;;;300    		{
;;;301    			if(location == 0)
0002a4  2a00              CMP      r2,#0
0002a6  d00d              BEQ      |L1.708|
;;;302    			{
;;;303    				//LPC_IOCON->PIO1_3 &= ~0x07;
;;;304    				//LPC_IOCON->PIO1_3 |= 0x01;/* Timer1_32 MAT3 */
;;;305    			}
;;;306    			else if(location == 1)
0002a8  2a01              CMP      r2,#1
0002aa  d10b              BNE      |L1.708|
;;;307    			{
;;;308    				LPC_IOCON->PIO0_16 &= ~(BIT2|BIT1|BIT0);
0002ac  4b4f              LDR      r3,|L1.1004|
0002ae  681b              LDR      r3,[r3,#0]
0002b0  08db              LSRS     r3,r3,#3
0002b2  00db              LSLS     r3,r3,#3
0002b4  4c4d              LDR      r4,|L1.1004|
0002b6  6023              STR      r3,[r4,#0]
;;;309    				LPC_IOCON->PIO0_16 |= BIT1;/* Timer1_32 MAT3 */
0002b8  4623              MOV      r3,r4
0002ba  681b              LDR      r3,[r3,#0]
0002bc  2402              MOVS     r4,#2
0002be  4323              ORRS     r3,r3,r4
0002c0  4c4a              LDR      r4,|L1.1004|
0002c2  6023              STR      r3,[r4,#0]
                  |L1.708|
;;;310    			}
;;;311    		}
;;;312    	}	
;;;313    }
0002c4  bd10              POP      {r4,pc}
;;;314    
                          ENDP

                  nsAPI_Timer32PWM_Breathing_ReSetting PROC
;;;315    void nsAPI_Timer32PWM_Breathing_ReSetting(U8 u8Breathing)
0002c6  2101              MOVS     r1,#1
;;;316    {
;;;317    	g_Timer32_LED_Setting.LEDStatusType = LED_BREATHING;
0002c8  4a49              LDR      r2,|L1.1008|
0002ca  7011              STRB     r1,[r2,#0]
;;;318    	g_Timer32_LED_Setting.BreathingStatusType = 0;
0002cc  2100              MOVS     r1,#0
0002ce  7051              STRB     r1,[r2,#1]
;;;319    	g_Timer32_LED_Setting.BreathingDelayCount = 0;
0002d0  6051              STR      r1,[r2,#4]  ; g_Timer32_LED_Setting
;;;320    	g_Timer32_LED_Setting.BreathingStepStatus &= ~BREATHING_STEP_RESETTING;
0002d2  4611              MOV      r1,r2
0002d4  78c9              LDRB     r1,[r1,#3]  ; g_Timer32_LED_Setting
0002d6  0849              LSRS     r1,r1,#1
0002d8  0049              LSLS     r1,r1,#1
0002da  70d1              STRB     r1,[r2,#3]
;;;321    	g_Timer32_LED_Setting.BreathingStep = BREATHING_STEP*u8Breathing;
0002dc  0641              LSLS     r1,r0,#25
0002de  0e09              LSRS     r1,r1,#24
0002e0  7091              STRB     r1,[r2,#2]
;;;322    }
0002e2  4770              BX       lr
;;;323    
                          ENDP

                  nsAPI_Timer32PWM_Init PROC
;;;335    ******************************************************************************/
;;;336    void nsAPI_Timer32PWM_Init(U8 timer_num, U32 period, U8 match_enable)
0002e4  b5f8              PUSH     {r3-r7,lr}
;;;337    {
0002e6  4607              MOV      r7,r0
0002e8  460e              MOV      r6,r1
0002ea  4615              MOV      r5,r2
;;;338    	NDrv_Timer32_Disable(timer_num);
0002ec  4638              MOV      r0,r7
0002ee  f7fffffe          BL       NDrv_Timer32_Disable
;;;339    	
;;;340    	nsAPI_Timer32PWM_Breathing_ReSetting(1);
0002f2  2001              MOVS     r0,#1
0002f4  f7fffffe          BL       nsAPI_Timer32PWM_Breathing_ReSetting
;;;341    
;;;342    	if(timer_num == 1)
0002f8  2f01              CMP      r7,#1
0002fa  d126              BNE      |L1.842|
;;;343    	{
;;;344    		U32 u32Timer32_1_period; 
;;;345    
;;;346    		LPC_SYSCON->SYSAHBCLKCTRL |= BIT10;
0002fc  483d              LDR      r0,|L1.1012|
0002fe  6800              LDR      r0,[r0,#0]
000300  02b9              LSLS     r1,r7,#10
000302  4308              ORRS     r0,r0,r1
000304  493b              LDR      r1,|L1.1012|
000306  6008              STR      r0,[r1,#0]
;;;347    
;;;348    		/* Setup the external match register */
;;;349    		LPC_CT32B1->EMR = (1 << EMC2)|(2 << EMC1)|(1 << EMC0);
000308  20ff              MOVS     r0,#0xff
00030a  3091              ADDS     r0,r0,#0x91
00030c  4936              LDR      r1,|L1.1000|
00030e  63c8              STR      r0,[r1,#0x3c]
;;;350    
;;;351    		/* Setup the outputs */
;;;352    		/* If match0 is enabled, set the output, use location 0 for test. */
;;;353    		nsAPI_Timer32_Setting_MatchFunction(timer_num,match_enable,1);
000310  2201              MOVS     r2,#1
000312  4629              MOV      r1,r5
000314  4638              MOV      r0,r7
000316  f7fffffe          BL       nsAPI_Timer32_Setting_MatchFunction
;;;354    		
;;;355    		LPC_CT32B1->PWMC |= match_enable;
00031a  4833              LDR      r0,|L1.1000|
00031c  3040              ADDS     r0,r0,#0x40
00031e  6b40              LDR      r0,[r0,#0x34]
000320  4328              ORRS     r0,r0,r5
000322  4931              LDR      r1,|L1.1000|
000324  3140              ADDS     r1,r1,#0x40
000326  6348              STR      r0,[r1,#0x34]
;;;356    		/* Setup the match registers */
;;;357    		/* set the period value to a global variable */
;;;358    		u32Timer32_1_period = period*Timer32_IntervalmS;		
000328  207d              MOVS     r0,#0x7d
00032a  00c0              LSLS     r0,r0,#3
00032c  4370              MULS     r0,r6,r0
00032e  4604              MOV      r4,r0
;;;359    		
;;;360    		LPC_CT32B1->MR0 = u32Timer32_1_period / 2;
000330  0860              LSRS     r0,r4,#1
000332  492d              LDR      r1,|L1.1000|
000334  6188              STR      r0,[r1,#0x18]
;;;361    		LPC_CT32B1->MR1 = u32Timer32_1_period / 2;
000336  0861              LSRS     r1,r4,#1
000338  482b              LDR      r0,|L1.1000|
00033a  61c1              STR      r1,[r0,#0x1c]
;;;362    		LPC_CT32B1->MR2 = u32Timer32_1_period / 2;
00033c  0861              LSRS     r1,r4,#1
00033e  6201              STR      r1,[r0,#0x20]
;;;363    		LPC_CT32B1->MR3 = u32Timer32_1_period;		
000340  6244              STR      r4,[r0,#0x24]
;;;364    		LPC_CT32B1->MCR = BIT10;/* Reset on MR3 */
000342  1500              ASRS     r0,r0,#20
000344  4928              LDR      r1,|L1.1000|
000346  6148              STR      r0,[r1,#0x14]
;;;365    	}
000348  e030              B        |L1.940|
                  |L1.842|
;;;366    	else
;;;367    	{
;;;368    		U32 u32Timer32_0_period;
;;;369    		/* Some of the I/O pins need to be clearfully planned if
;;;370    		you use below module because JTAG and TIMER CAP/MAT pins are muxed. */
;;;371    		LPC_SYSCON->SYSAHBCLKCTRL |= BIT9;
00034a  482a              LDR      r0,|L1.1012|
00034c  6800              LDR      r0,[r0,#0]
00034e  2101              MOVS     r1,#1
000350  0249              LSLS     r1,r1,#9
000352  4308              ORRS     r0,r0,r1
000354  4927              LDR      r1,|L1.1012|
000356  6008              STR      r0,[r1,#0]
;;;372    
;;;373    		LPC_CT32B0->PR = Timer32_MHz_Prescale;
000358  4927              LDR      r1,|L1.1016|
00035a  4828              LDR      r0,|L1.1020|
00035c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00035e  f7fffffe          BL       __aeabi_uidivmod
000362  4920              LDR      r1,|L1.996|
000364  60c8              STR      r0,[r1,#0xc]
;;;374    		
;;;375    		/* Setup the external match register */
;;;376    		LPC_CT32B0->EMR = (3 << EMC2)|(3 << EMC1)|(3 << EMC0);
000366  203f              MOVS     r0,#0x3f
000368  0100              LSLS     r0,r0,#4
00036a  63c8              STR      r0,[r1,#0x3c]
;;;377    
;;;378    		/* Setup the outputs */
;;;379    		/* If match0 is enabled, set the output, use location 0 for test. */
;;;380    		nsAPI_Timer32_Setting_MatchFunction(timer_num, match_enable,1);
00036c  2201              MOVS     r2,#1
00036e  4629              MOV      r1,r5
000370  4638              MOV      r0,r7
000372  f7fffffe          BL       nsAPI_Timer32_Setting_MatchFunction
;;;381    
;;;382    		/* Enable the selected PWMs and enable Match3 */
;;;383    		LPC_CT32B0->PWMC = match_enable;
000376  481b              LDR      r0,|L1.996|
000378  3040              ADDS     r0,r0,#0x40
00037a  6345              STR      r5,[r0,#0x34]
;;;384    
;;;385    		/* Setup the match registers */
;;;386    		/* set the period value to a global variable */
;;;387    		u32Timer32_0_period = period*Timer32_IntervalmS;	
00037c  207d              MOVS     r0,#0x7d
00037e  00c0              LSLS     r0,r0,#3
000380  4370              MULS     r0,r6,r0
000382  4604              MOV      r4,r0
;;;388    
;;;389    		if(u32Timer32_0_period < BREATHING_FREQ_GAP)
000384  2c64              CMP      r4,#0x64
000386  d200              BCS      |L1.906|
;;;390    		u32Timer32_0_period = BREATHING_FREQ_GAP;	
000388  2464              MOVS     r4,#0x64
                  |L1.906|
;;;391    		
;;;392    		LPC_CT32B0->MR0 = u32Timer32_0_period -BREATHING_FREQ_GAP;
00038a  4620              MOV      r0,r4
00038c  3864              SUBS     r0,r0,#0x64
00038e  4915              LDR      r1,|L1.996|
000390  6188              STR      r0,[r1,#0x18]
;;;393    		LPC_CT32B0->MR1 = u32Timer32_0_period -BREATHING_FREQ_GAP;
000392  61c8              STR      r0,[r1,#0x1c]
;;;394    		LPC_CT32B0->MR2 = u32Timer32_0_period -BREATHING_FREQ_GAP;
000394  6208              STR      r0,[r1,#0x20]
;;;395    		LPC_CT32B0->MR3 = u32Timer32_0_period;		
000396  4608              MOV      r0,r1
000398  6244              STR      r4,[r0,#0x24]
;;;396    		LPC_CT32B0->MCR = BIT10;	/* Reset on MR3 */	
00039a  1500              ASRS     r0,r0,#20
00039c  6148              STR      r0,[r1,#0x14]
;;;397    		
;;;398    		g_Timer32_LED_Setting.CurBreathingFreq = u32Timer32_0_period -BREATHING_FREQ_GAP;
00039e  4620              MOV      r0,r4
0003a0  3864              SUBS     r0,r0,#0x64
0003a2  4913              LDR      r1,|L1.1008|
0003a4  6088              STR      r0,[r1,#8]  ; g_Timer32_LED_Setting
;;;399    		g_Timer32_LED_Setting.PreBreathingFreq = u32Timer32_0_period;		
0003a6  4608              MOV      r0,r1
0003a8  60c4              STR      r4,[r0,#0xc]  ; g_Timer32_LED_Setting
;;;400    	}
0003aa  bf00              NOP      
                  |L1.940|
;;;401    	
;;;402    	NDrv_Timer32_Reset(timer_num);
0003ac  4638              MOV      r0,r7
0003ae  f7fffffe          BL       NDrv_Timer32_Reset
;;;403    	NDrv_Timer32_Enable(timer_num);
0003b2  4638              MOV      r0,r7
0003b4  f7fffffe          BL       NDrv_Timer32_Enable
;;;404    }
0003b8  bdf8              POP      {r3-r7,pc}
;;;405    
                          ENDP

                  NDrv_Timer32PWM_ReSettingMatch PROC
;;;415    ******************************************************************************/
;;;416    void NDrv_Timer32PWM_ReSettingMatch(U8 timer_num, U32 period)
0003ba  b510              PUSH     {r4,lr}
;;;417    {
0003bc  4602              MOV      r2,r0
;;;418    	U32 u32Timer32_period;
;;;419    
;;;420    	u32Timer32_period = period*Timer32_IntervalmS;	
0003be  237d              MOVS     r3,#0x7d
0003c0  00db              LSLS     r3,r3,#3
0003c2  434b              MULS     r3,r1,r3
0003c4  4618              MOV      r0,r3
;;;421    
;;;422    	if(u32Timer32_period == 0)
0003c6  2800              CMP      r0,#0
0003c8  d100              BNE      |L1.972|
;;;423    	u32Timer32_period = 10;	  
0003ca  200a              MOVS     r0,#0xa
                  |L1.972|
;;;424    
;;;425    	if(timer_num)
0003cc  2a00              CMP      r2,#0
0003ce  d017              BEQ      |L1.1024|
;;;426    	{    
;;;427    		LPC_CT32B1->MR0 = u32Timer32_period / 2;    
0003d0  0843              LSRS     r3,r0,#1
0003d2  4c05              LDR      r4,|L1.1000|
0003d4  61a3              STR      r3,[r4,#0x18]
;;;428    		LPC_CT32B1->MR1 = u32Timer32_period / 2;     
0003d6  0844              LSRS     r4,r0,#1
0003d8  4b03              LDR      r3,|L1.1000|
0003da  61dc              STR      r4,[r3,#0x1c]
;;;429    		LPC_CT32B1->MR2 = u32Timer32_period / 2;     
0003dc  0844              LSRS     r4,r0,#1
0003de  621c              STR      r4,[r3,#0x20]
;;;430    		LPC_CT32B1->MR3 = u32Timer32_period;    
0003e0  6258              STR      r0,[r3,#0x24]
0003e2  e016              B        |L1.1042|
                  |L1.996|
                          DCD      0x40014000
                  |L1.1000|
                          DCD      0x40018000
                  |L1.1004|
                          DCD      0x40044040
                  |L1.1008|
                          DCD      g_Timer32_LED_Setting
                  |L1.1012|
                          DCD      0x40048080
                  |L1.1016|
                          DCD      0x000f4240
                  |L1.1020|
                          DCD      SystemCoreClock
                  |L1.1024|
;;;431    	}
;;;432    	else 
;;;433    	{   
;;;434    		LPC_CT32B0->MR0 = u32Timer32_period / 2;     
000400  0843              LSRS     r3,r0,#1
000402  4c43              LDR      r4,|L1.1296|
000404  61a3              STR      r3,[r4,#0x18]
;;;435    		LPC_CT32B0->MR1 = u32Timer32_period / 2;   
000406  0844              LSRS     r4,r0,#1
000408  4b41              LDR      r3,|L1.1296|
00040a  61dc              STR      r4,[r3,#0x1c]
;;;436    		LPC_CT32B0->MR2 = u32Timer32_period / 2;   
00040c  0844              LSRS     r4,r0,#1
00040e  621c              STR      r4,[r3,#0x20]
;;;437    		LPC_CT32B0->MR3 = u32Timer32_period;    
000410  6258              STR      r0,[r3,#0x24]
                  |L1.1042|
;;;438    	}
;;;439    	
;;;440    	LPC_CT32B0->MCR = BIT10;	/* Reset on MR3 */
000412  2301              MOVS     r3,#1
000414  029b              LSLS     r3,r3,#10
000416  4c3e              LDR      r4,|L1.1296|
000418  6163              STR      r3,[r4,#0x14]
;;;441    }
00041a  bd10              POP      {r4,pc}
;;;442    
                          ENDP

                  NDrv_Timer32PWM_Breathing PROC
;;;443    void NDrv_Timer32PWM_Breathing(void)
00041c  493d              LDR      r1,|L1.1300|
;;;444    {
;;;445    	U32 u32Timer32_period = g_Timer32_LED_Setting.CurBreathingFreq;
00041e  6888              LDR      r0,[r1,#8]  ; g_Timer32_LED_Setting
;;;446    	
;;;447           if(g_Timer32_LED_Setting.BreathingStatusType)
000420  7849              LDRB     r1,[r1,#1]  ; g_Timer32_LED_Setting
000422  2900              CMP      r1,#0
000424  d020              BEQ      |L1.1128|
;;;448           {        		
;;;449    	   
;;;450    		if(u32Timer32_period <  (g_Timer32_LED_Setting.PreBreathingFreq -BREATHING_FREQ_GAP*2))
000426  493b              LDR      r1,|L1.1300|
000428  68c9              LDR      r1,[r1,#0xc]  ; g_Timer32_LED_Setting
00042a  39c8              SUBS     r1,r1,#0xc8
00042c  4281              CMP      r1,r0
00042e  d90d              BLS      |L1.1100|
;;;451    		{
;;;452    			u32Timer32_period += (g_Timer32_LED_Setting.BreathingStep*BREATHING_STEP);			
000430  4938              LDR      r1,|L1.1300|
000432  7889              LDRB     r1,[r1,#2]  ; g_Timer32_LED_Setting
000434  0049              LSLS     r1,r1,#1
000436  1808              ADDS     r0,r1,r0
;;;453                       
;;;454    			LPC_CT32B0->MR0 = u32Timer32_period;	 
000438  4935              LDR      r1,|L1.1296|
00043a  6188              STR      r0,[r1,#0x18]
;;;455    			LPC_CT32B0->MR1 = u32Timer32_period;   
00043c  61c8              STR      r0,[r1,#0x1c]
;;;456    			LPC_CT32B0->MR2 = u32Timer32_period;   
00043e  6208              STR      r0,[r1,#0x20]
;;;457    
;;;458    			g_Timer32_LED_Setting.CurBreathingFreq = u32Timer32_period; 	
000440  4934              LDR      r1,|L1.1300|
000442  6088              STR      r0,[r1,#8]  ; g_Timer32_LED_Setting
;;;459    			g_Timer32_LED_Setting.BreathingDelayCount = BREATHING_DELAY_TIMER / 2;
000444  2114              MOVS     r1,#0x14
000446  4a33              LDR      r2,|L1.1300|
000448  6051              STR      r1,[r2,#4]  ; g_Timer32_LED_Setting
00044a  e02e              B        |L1.1194|
                  |L1.1100|
;;;460    		}
;;;461    		else
;;;462    		{       
;;;463    			if(g_Timer32_LED_Setting.BreathingDelayCount > 0)
00044c  4931              LDR      r1,|L1.1300|
00044e  6849              LDR      r1,[r1,#4]  ; g_Timer32_LED_Setting
000450  2900              CMP      r1,#0
000452  d005              BEQ      |L1.1120|
;;;464    			g_Timer32_LED_Setting.BreathingDelayCount --;
000454  492f              LDR      r1,|L1.1300|
000456  6849              LDR      r1,[r1,#4]  ; g_Timer32_LED_Setting
000458  1e49              SUBS     r1,r1,#1
00045a  4a2e              LDR      r2,|L1.1300|
00045c  6051              STR      r1,[r2,#4]  ; g_Timer32_LED_Setting
00045e  e024              B        |L1.1194|
                  |L1.1120|
;;;465    			else  
;;;466    			g_Timer32_LED_Setting.BreathingStatusType = 0;						
000460  2100              MOVS     r1,#0
000462  4a2c              LDR      r2,|L1.1300|
000464  7051              STRB     r1,[r2,#1]
000466  e020              B        |L1.1194|
                  |L1.1128|
;;;467    		}	
;;;468           }
;;;469           else
;;;470           { 	 
;;;471            
;;;472                 if((u32Timer32_period - (g_Timer32_LED_Setting.BreathingStep*BREATHING_STEP)) > BREATHING_FREQ_GAP /4)	        
000468  492a              LDR      r1,|L1.1300|
00046a  7889              LDRB     r1,[r1,#2]  ; g_Timer32_LED_Setting
00046c  0049              LSLS     r1,r1,#1
00046e  1a41              SUBS     r1,r0,r1
000470  2919              CMP      r1,#0x19
000472  d90d              BLS      |L1.1168|
;;;473    		{
;;;474    			u32Timer32_period -= (g_Timer32_LED_Setting.BreathingStep*BREATHING_STEP);					
000474  4927              LDR      r1,|L1.1300|
000476  7889              LDRB     r1,[r1,#2]  ; g_Timer32_LED_Setting
000478  0049              LSLS     r1,r1,#1
00047a  1a40              SUBS     r0,r0,r1
;;;475                           
;;;476    			LPC_CT32B0->MR0 = u32Timer32_period;	 
00047c  4924              LDR      r1,|L1.1296|
00047e  6188              STR      r0,[r1,#0x18]
;;;477    			LPC_CT32B0->MR1 = u32Timer32_period;   
000480  61c8              STR      r0,[r1,#0x1c]
;;;478    			LPC_CT32B0->MR2 = u32Timer32_period;
000482  6208              STR      r0,[r1,#0x20]
;;;479    
;;;480    			g_Timer32_LED_Setting.CurBreathingFreq = u32Timer32_period; 	
000484  4923              LDR      r1,|L1.1300|
000486  6088              STR      r0,[r1,#8]  ; g_Timer32_LED_Setting
;;;481    			g_Timer32_LED_Setting.BreathingDelayCount = BREATHING_DELAY_TIMER;
000488  2128              MOVS     r1,#0x28
00048a  4a22              LDR      r2,|L1.1300|
00048c  6051              STR      r1,[r2,#4]  ; g_Timer32_LED_Setting
00048e  e00c              B        |L1.1194|
                  |L1.1168|
;;;482    		}
;;;483    		else
;;;484    		{          
;;;485    			if(g_Timer32_LED_Setting.BreathingDelayCount > 0)
000490  4920              LDR      r1,|L1.1300|
000492  6849              LDR      r1,[r1,#4]  ; g_Timer32_LED_Setting
000494  2900              CMP      r1,#0
000496  d005              BEQ      |L1.1188|
;;;486    			g_Timer32_LED_Setting.BreathingDelayCount --;
000498  491e              LDR      r1,|L1.1300|
00049a  6849              LDR      r1,[r1,#4]  ; g_Timer32_LED_Setting
00049c  1e49              SUBS     r1,r1,#1
00049e  4a1d              LDR      r2,|L1.1300|
0004a0  6051              STR      r1,[r2,#4]  ; g_Timer32_LED_Setting
0004a2  e002              B        |L1.1194|
                  |L1.1188|
;;;487    			else  
;;;488    			g_Timer32_LED_Setting.BreathingStatusType = 1;	
0004a4  2101              MOVS     r1,#1
0004a6  4a1b              LDR      r2,|L1.1300|
0004a8  7051              STRB     r1,[r2,#1]
                  |L1.1194|
;;;489    		}	
;;;490           }	
;;;491    }
0004aa  4770              BX       lr
;;;492    
                          ENDP

                  init_timer32 PROC
;;;493    void init_timer32( U32 timer )
0004ac  b500              PUSH     {lr}
;;;494    {
0004ae  4603              MOV      r3,r0
;;;495    //
;;;496    // 48000UL = 1ms
;;;497    // 4800UL  = 100us
;;;498    // 480UL   = 10uS
;;;499    // Notes: <Frequency modulation>: We are using 480UL as default to measure 1000Hz
;;;500    //         for 2ms rising edge to rising edge, readback is 203 => 203 x 10uS = 2.03ms
;;;501    
;;;502    		NVIC_DisableIRQ(TIMER_32_0_IRQn);
0004b0  2012              MOVS     r0,#0x12
0004b2  2101              MOVS     r1,#1
0004b4  4081              LSLS     r1,r1,r0
0004b6  4a18              LDR      r2,|L1.1304|
0004b8  6011              STR      r1,[r2,#0]
0004ba  bf00              NOP      
;;;503    		NDrv_Timer32_Reset(Timer32_0);
0004bc  2000              MOVS     r0,#0
0004be  f7fffffe          BL       NDrv_Timer32_Reset
;;;504    
;;;505    	    LPC_SYSCON->SYSAHBCLKCTRL |= BIT9;
0004c2  4816              LDR      r0,|L1.1308|
0004c4  6800              LDR      r0,[r0,#0]
0004c6  2101              MOVS     r1,#1
0004c8  0249              LSLS     r1,r1,#9
0004ca  4308              ORRS     r0,r0,r1
0004cc  4913              LDR      r1,|L1.1308|
0004ce  6008              STR      r0,[r1,#0]
;;;506    		LPC_CT32B0->PR = timer;
0004d0  480f              LDR      r0,|L1.1296|
0004d2  60c3              STR      r3,[r0,#0xc]
;;;507    		
;;;508    		LPC_IOCON->PIO0_17 = (1<<1)|(2<<3);//CT32B0_CAP0;
0004d4  2012              MOVS     r0,#0x12
0004d6  4912              LDR      r1,|L1.1312|
0004d8  6048              STR      r0,[r1,#4]
;;;509    		LPC_CT32B0->CTCR |= 0;//CAP0|CAP_MODE_BOTH_EDGE;	// Timer mode 
0004da  480d              LDR      r0,|L1.1296|
0004dc  3040              ADDS     r0,r0,#0x40
0004de  6b00              LDR      r0,[r0,#0x30]
0004e0  490b              LDR      r1,|L1.1296|
0004e2  3140              ADDS     r1,r1,#0x40
0004e4  6308              STR      r0,[r1,#0x30]
;;;510    		LPC_CT32B0->CCR |= 5;//CAP0FE|CAP0RE;				// Capture 0 on rising edge, interrupt enable.
0004e6  480a              LDR      r0,|L1.1296|
0004e8  6a80              LDR      r0,[r0,#0x28]
0004ea  2105              MOVS     r1,#5
0004ec  4308              ORRS     r0,r0,r1
0004ee  4908              LDR      r1,|L1.1296|
0004f0  6288              STR      r0,[r1,#0x28]
;;;511    		//LPC_CT32B0->MCR |= MR0I;						// Interrupt on MR0
;;;512    		LPC_CT32B0->TCR |= 1;//CEN;							// Start counting
0004f2  4608              MOV      r0,r1
0004f4  6840              LDR      r0,[r0,#4]
0004f6  2101              MOVS     r1,#1
0004f8  4308              ORRS     r0,r0,r1
0004fa  4905              LDR      r1,|L1.1296|
0004fc  6048              STR      r0,[r1,#4]
;;;513    		
;;;514    		NVIC_EnableIRQ(TIMER_32_0_IRQn); // Enable the TIMER0 Interrupt
0004fe  2012              MOVS     r0,#0x12
000500  2101              MOVS     r1,#1
000502  4081              LSLS     r1,r1,r0
000504  4a04              LDR      r2,|L1.1304|
000506  3a80              SUBS     r2,r2,#0x80
000508  6011              STR      r1,[r2,#0]
00050a  bf00              NOP      
;;;515    
;;;516    //	NDrv_Timer32_Enable(timer_num);
;;;517    }
00050c  bd00              POP      {pc}
;;;518    
                          ENDP

00050e  0000              DCW      0x0000
                  |L1.1296|
                          DCD      0x40014000
                  |L1.1300|
                          DCD      g_Timer32_LED_Setting
                  |L1.1304|
                          DCD      0xe000e180
                  |L1.1308|
                          DCD      0x40048080
                  |L1.1312|
                          DCD      0x40044040

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_Timer32_LED_Setting
                          %        16

;*** Start embedded assembler ***

#line 1 "Src\\timer32.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_timer32_c_884c2218____REV16|
#line 112 ".\\Inc\\core_cmInstr.h"
|__asm___9_timer32_c_884c2218____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_timer32_c_884c2218____REVSH|
#line 130
|__asm___9_timer32_c_884c2218____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
