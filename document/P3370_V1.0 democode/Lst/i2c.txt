; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\i2c.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\obj\i2c.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\INC\NXP\LPC11Uxx -D__MICROLIB -D__UVISION_VERSION=536 -D__DEBUG_FLASH --omf_browse=.\obj\i2c.crf Src\I2c.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_IRQHandler PROC
;;;37     *****************************************************************************/
;;;38     void I2C_IRQHandler(void) 
000000  b500              PUSH     {lr}
;;;39     {
;;;40     	U8 StatValue;
;;;41     
;;;42     	/* this handler deals with master read and master write only */
;;;43     	StatValue = LPC_I2C->STAT;
000002  2101              MOVS     r1,#1
000004  0789              LSLS     r1,r1,#30
000006  6849              LDR      r1,[r1,#4]
000008  b2c8              UXTB     r0,r1
;;;44     	_DEBUG_I2C_(xprintf("\r\n StatValue=%x",StatValue));
;;;45     
;;;46     	switch(StatValue)
00000a  0741              LSLS     r1,r0,#29
00000c  0f49              LSRS     r1,r1,#29
00000e  2900              CMP      r1,#0
000010  d17b              BNE      |L1.266|
000012  10c1              ASRS     r1,r0,#3
000014  000b              MOVS     r3,r1
000016  f7fffffe          BL       __ARM_common_switch8
00001a  0cd1              DCB      0x0c,0xd1
00001c  071521cc          DCB      0x07,0x15,0x21,0xcc
000020  3263d28b          DCB      0x32,0x63,0xd2,0x8b
000024  cd97b7d1          DCB      0xcd,0x97,0xb7,0xd1
;;;47     	{
;;;48     		case 0x08:/* A Start condition is issued. */
;;;49     		g_I2C_Setting.WrIndex = 0;
000028  2100              MOVS     r1,#0
00002a  4acd              LDR      r2,|L1.864|
00002c  7391              STRB     r1,[r2,#0xe]
;;;50     		LPC_I2C->DAT = g_I2C_Setting.I2CDeviceAdr;	
00002e  4611              MOV      r1,r2
000030  7849              LDRB     r1,[r1,#1]  ; g_I2C_Setting
000032  2201              MOVS     r2,#1
000034  0792              LSLS     r2,r2,#30
000036  6091              STR      r1,[r2,#8]
;;;51     		LPC_I2C->CONCLR = I2CONCLR_STAC;		
000038  2120              MOVS     r1,#0x20
00003a  6191              STR      r1,[r2,#0x18]
;;;52     		g_I2C_Setting.I2CMasterState = I2C_DEVICEARD;
00003c  2101              MOVS     r1,#1
00003e  4ac8              LDR      r2,|L1.864|
000040  7011              STRB     r1,[r2,#0]
;;;53     		break;
000042  e0bd              B        |L1.448|
;;;54     	
;;;55     		case 0x10:/* A repeated started is issued */
;;;56     		g_I2C_Setting.RdIndex = 0;
000044  2100              MOVS     r1,#0
000046  4ac6              LDR      r2,|L1.864|
000048  7351              STRB     r1,[r2,#0xd]
;;;57     		/* Send SLA with R bit set, */
;;;58     		LPC_I2C->DAT = AT24C512_ADDR|READ_STATUS;
00004a  21a1              MOVS     r1,#0xa1
00004c  078a              LSLS     r2,r1,#30
00004e  6091              STR      r1,[r2,#8]
;;;59     		LPC_I2C->CONCLR = I2CONCLR_STAC;
000050  2120              MOVS     r1,#0x20
000052  6191              STR      r1,[r2,#0x18]
;;;60     		g_I2C_Setting.I2CMasterState = I2C_RESTARTED;
000054  2104              MOVS     r1,#4
000056  4ac2              LDR      r2,|L1.864|
000058  7011              STRB     r1,[r2,#0]
;;;61     		break;
00005a  e0b1              B        |L1.448|
;;;62     	
;;;63     		case 0x18:/* Regardless, it's a ACK */
;;;64     		if(g_I2C_Setting.I2CMasterState == I2C_DEVICEARD)
00005c  49c0              LDR      r1,|L1.864|
00005e  7809              LDRB     r1,[r1,#0]  ; g_I2C_Setting
000060  2901              CMP      r1,#1
000062  d10b              BNE      |L1.124|
;;;65     		{
;;;66     			g_I2C_Setting.I2CMasterState = I2C_FWORDARD;	
000064  2102              MOVS     r1,#2
000066  4abe              LDR      r2,|L1.864|
000068  7011              STRB     r1,[r2,#0]
;;;67     			LPC_I2C->DAT = (g_I2C_Setting.I2CWordAdr & 0xFF00) >> 8;					
00006a  4611              MOV      r1,r2
00006c  8a09              LDRH     r1,[r1,#0x10]  ; g_I2C_Setting
00006e  22ff              MOVS     r2,#0xff
000070  0212              LSLS     r2,r2,#8
000072  4011              ANDS     r1,r1,r2
000074  1209              ASRS     r1,r1,#8
000076  2201              MOVS     r2,#1
000078  0792              LSLS     r2,r2,#30
00007a  6091              STR      r1,[r2,#8]
                  |L1.124|
;;;68     		}	
;;;69     		break; 
00007c  e0a0              B        |L1.448|
;;;70     
;;;71     		case 0x28:/* Data byte has been transmitted, regardless ACK or NACK */		
;;;72     		if(g_I2C_Setting.I2CMasterState == I2C_FWORDARD)
00007e  49b8              LDR      r1,|L1.864|
000080  7809              LDRB     r1,[r1,#0]  ; g_I2C_Setting
000082  2902              CMP      r1,#2
000084  d108              BNE      |L1.152|
;;;73     		{
;;;74     			LPC_I2C->DAT = (g_I2C_Setting.I2CWordAdr & 0x00FF) >> 0;				
000086  49b6              LDR      r1,|L1.864|
000088  7c09              LDRB     r1,[r1,#0x10]  ; g_I2C_Setting
00008a  2201              MOVS     r2,#1
00008c  0792              LSLS     r2,r2,#30
00008e  6091              STR      r1,[r2,#8]
;;;75     			g_I2C_Setting.I2CMasterState = I2C_SWORDARD; 			
000090  2103              MOVS     r1,#3
000092  4ab3              LDR      r2,|L1.864|
000094  7011              STRB     r1,[r2,#0]
;;;76     			break;
000096  e093              B        |L1.448|
                  |L1.152|
;;;77     		}
;;;78     		
;;;79                  if(g_I2C_Setting.I2CBusState == I2C_BUS_WRITE)
000098  49b1              LDR      r1,|L1.864|
00009a  7889              LDRB     r1,[r1,#2]  ; g_I2C_Setting
00009c  2901              CMP      r1,#1
00009e  d113              BNE      |L1.200|
;;;80     		{
;;;81     			if(g_I2C_Setting.I2CMasterState == I2C_SWORDARD)
0000a0  49af              LDR      r1,|L1.864|
0000a2  7809              LDRB     r1,[r1,#0]  ; g_I2C_Setting
0000a4  2903              CMP      r1,#3
0000a6  d11a              BNE      |L1.222|
;;;82     			{
;;;83     				g_I2C_Setting.I2CMasterState = DATA_ACK; 			
0000a8  2106              MOVS     r1,#6
0000aa  4aad              LDR      r2,|L1.864|
0000ac  7011              STRB     r1,[r2,#0]
;;;84     				LPC_I2C->DAT = g_I2C_Setting.I2CMasterBuffer[g_I2C_Setting.WrIndex];
0000ae  4611              MOV      r1,r2
0000b0  7b8a              LDRB     r2,[r1,#0xe]  ; g_I2C_Setting
0000b2  1cc9              ADDS     r1,r1,#3
0000b4  5c89              LDRB     r1,[r1,r2]
0000b6  2201              MOVS     r2,#1
0000b8  0792              LSLS     r2,r2,#30
0000ba  6091              STR      r1,[r2,#8]
;;;85     				g_I2C_Setting.WrIndex++;			
0000bc  49a8              LDR      r1,|L1.864|
0000be  7b89              LDRB     r1,[r1,#0xe]  ; g_I2C_Setting
0000c0  1c49              ADDS     r1,r1,#1
0000c2  4aa7              LDR      r2,|L1.864|
0000c4  7391              STRB     r1,[r2,#0xe]
;;;86     				break;
0000c6  e07b              B        |L1.448|
                  |L1.200|
;;;87     			}		
;;;88     		}
;;;89     		else
;;;90     		{
;;;91     			if(g_I2C_Setting.I2CBusState == I2C_BUS_READ)
0000c8  49a5              LDR      r1,|L1.864|
0000ca  7889              LDRB     r1,[r1,#2]  ; g_I2C_Setting
0000cc  2902              CMP      r1,#2
0000ce  d106              BNE      |L1.222|
;;;92     			{
;;;93     				LPC_I2C->CONSET = I2CONSET_STA;/* Set Repeated-start flag */
0000d0  2120              MOVS     r1,#0x20
0000d2  064a              LSLS     r2,r1,#25
0000d4  6011              STR      r1,[r2,#0]
;;;94     				g_I2C_Setting.I2CMasterState = I2C_REPEATED_START; 
0000d6  2105              MOVS     r1,#5
0000d8  4aa1              LDR      r2,|L1.864|
0000da  7011              STRB     r1,[r2,#0]
;;;95     				break;
0000dc  e070              B        |L1.448|
                  |L1.222|
;;;96     			}
;;;97     		}
;;;98     			 
;;;99     		case 0x30:
0000de  bf00              NOP      
;;;100    		if(g_I2C_Setting.WrIndex < g_I2C_Setting.I2CWriteLength)
0000e0  499f              LDR      r1,|L1.864|
0000e2  7b89              LDRB     r1,[r1,#0xe]  ; g_I2C_Setting
0000e4  4a9e              LDR      r2,|L1.864|
0000e6  7b12              LDRB     r2,[r2,#0xc]  ; g_I2C_Setting
0000e8  4291              CMP      r1,r2
0000ea  da0f              BGE      |L1.268|
;;;101    		{   
;;;102    			LPC_I2C->DAT = g_I2C_Setting.I2CMasterBuffer[g_I2C_Setting.WrIndex];/* this should be the last one */
0000ec  499c              LDR      r1,|L1.864|
0000ee  7b8a              LDRB     r2,[r1,#0xe]  ; g_I2C_Setting
0000f0  1cc9              ADDS     r1,r1,#3
0000f2  5c89              LDRB     r1,[r1,r2]
0000f4  2201              MOVS     r2,#1
0000f6  0792              LSLS     r2,r2,#30
0000f8  6091              STR      r1,[r2,#8]
;;;103    			g_I2C_Setting.WrIndex++;
0000fa  4999              LDR      r1,|L1.864|
0000fc  7b89              LDRB     r1,[r1,#0xe]  ; g_I2C_Setting
0000fe  1c49              ADDS     r1,r1,#1
000100  4a97              LDR      r2,|L1.864|
000102  7391              STRB     r1,[r2,#0xe]
;;;104    			g_I2C_Setting.I2CMasterState = DATA_ACK; 
000104  2106              MOVS     r1,#6
000106  7011              STRB     r1,[r2,#0]
000108  e011              B        |L1.302|
                  |L1.266|
00010a  e057              B        |L1.444|
                  |L1.268|
;;;105    		}
;;;106    		else
;;;107    		{
;;;108    			if(g_I2C_Setting.I2CReadLength != 0)
00010c  4994              LDR      r1,|L1.864|
00010e  7ac9              LDRB     r1,[r1,#0xb]  ; g_I2C_Setting
000110  2900              CMP      r1,#0
000112  d006              BEQ      |L1.290|
;;;109    			{
;;;110    				LPC_I2C->CONSET = I2CONSET_STA;/* Set Repeated-start flag */
000114  2120              MOVS     r1,#0x20
000116  064a              LSLS     r2,r1,#25
000118  6011              STR      r1,[r2,#0]
;;;111    				g_I2C_Setting.I2CMasterState = I2C_REPEATED_START; 
00011a  2105              MOVS     r1,#5
00011c  4a90              LDR      r2,|L1.864|
00011e  7011              STRB     r1,[r2,#0]
000120  e005              B        |L1.302|
                  |L1.290|
;;;112    			}
;;;113    			else
;;;114    			{
;;;115    				g_I2C_Setting.I2CMasterState = DATA_NACK;
000122  2107              MOVS     r1,#7
000124  4a8e              LDR      r2,|L1.864|
000126  7011              STRB     r1,[r2,#0]
;;;116    				LPC_I2C->CONSET = I2CONSET_STO;/* Set Stop flag */
000128  2110              MOVS     r1,#0x10
00012a  068a              LSLS     r2,r1,#26
00012c  6011              STR      r1,[r2,#0]
                  |L1.302|
;;;117    			}
;;;118    		}		
;;;119    		break;
00012e  e047              B        |L1.448|
;;;120    	
;;;121    		case 0x40:/* Master Receive, SLA_R has been sent */
;;;122    		if(g_I2C_Setting.I2CReadLength == 1)
000130  498b              LDR      r1,|L1.864|
000132  7ac9              LDRB     r1,[r1,#0xb]  ; g_I2C_Setting
000134  2901              CMP      r1,#1
000136  d103              BNE      |L1.320|
;;;123    		{
;;;124    			/* Will go to State 0x58 */
;;;125    			LPC_I2C->CONCLR = I2CONCLR_AAC;/* assert NACK after data is received */
000138  2104              MOVS     r1,#4
00013a  070a              LSLS     r2,r1,#28
00013c  6191              STR      r1,[r2,#0x18]
00013e  e002              B        |L1.326|
                  |L1.320|
;;;126    		}
;;;127    		else
;;;128    		{
;;;129    			/* Will go to State 0x50 */
;;;130    			LPC_I2C->CONSET = I2CONSET_AA;/* assert ACK after data is received */
000140  2104              MOVS     r1,#4
000142  070a              LSLS     r2,r1,#28
000144  6011              STR      r1,[r2,#0]
                  |L1.326|
;;;131    		}		
;;;132    		break;
000146  e03b              B        |L1.448|
;;;133    	
;;;134    		case 0x50:/* Data byte has been received, regardless following ACK or NACK */
;;;135    		g_I2C_Setting.I2CSlaveBuffer[g_I2C_Setting.RdIndex] = LPC_I2C->DAT;
000148  2101              MOVS     r1,#1
00014a  0789              LSLS     r1,r1,#30
00014c  6889              LDR      r1,[r1,#8]
00014e  b2ca              UXTB     r2,r1
000150  4983              LDR      r1,|L1.864|
000152  7b4b              LDRB     r3,[r1,#0xd]  ; g_I2C_Setting
000154  1dc9              ADDS     r1,r1,#7
000156  54ca              STRB     r2,[r1,r3]
;;;136    		g_I2C_Setting.RdIndex++;
000158  1fc9              SUBS     r1,r1,#7
00015a  7b49              LDRB     r1,[r1,#0xd]  ; g_I2C_Setting
00015c  1c49              ADDS     r1,r1,#1
00015e  4a80              LDR      r2,|L1.864|
000160  7351              STRB     r1,[r2,#0xd]
;;;137    		
;;;138    		if(g_I2C_Setting.RdIndex < g_I2C_Setting.I2CReadLength)
000162  4611              MOV      r1,r2
000164  7b49              LDRB     r1,[r1,#0xd]  ; g_I2C_Setting
000166  7ad2              LDRB     r2,[r2,#0xb]  ; g_I2C_Setting
000168  4291              CMP      r1,r2
00016a  da06              BGE      |L1.378|
;;;139    		{   
;;;140    			g_I2C_Setting.I2CMasterState = DATA_ACK;
00016c  2106              MOVS     r1,#6
00016e  4a7c              LDR      r2,|L1.864|
000170  7011              STRB     r1,[r2,#0]
;;;141    			LPC_I2C->CONSET = I2CONSET_AA;/* assert ACK after data is received */
000172  2104              MOVS     r1,#4
000174  070a              LSLS     r2,r1,#28
000176  6011              STR      r1,[r2,#0]
000178  e005              B        |L1.390|
                  |L1.378|
;;;142    		}
;;;143    		else
;;;144    		{
;;;145    			g_I2C_Setting.I2CMasterState = DATA_NACK;
00017a  2107              MOVS     r1,#7
00017c  4a78              LDR      r2,|L1.864|
00017e  7011              STRB     r1,[r2,#0]
;;;146    			LPC_I2C->CONCLR = I2CONCLR_AAC;/* assert NACK on last byte */
000180  2104              MOVS     r1,#4
000182  070a              LSLS     r2,r1,#28
000184  6191              STR      r1,[r2,#0x18]
                  |L1.390|
;;;147    		}		
;;;148    		break;
000186  e01b              B        |L1.448|
;;;149    	
;;;150    		case 0x58:
;;;151    		g_I2C_Setting.I2CSlaveBuffer[g_I2C_Setting.RdIndex] = LPC_I2C->DAT;
000188  2101              MOVS     r1,#1
00018a  0789              LSLS     r1,r1,#30
00018c  6889              LDR      r1,[r1,#8]
00018e  b2ca              UXTB     r2,r1
000190  4973              LDR      r1,|L1.864|
000192  7b4b              LDRB     r3,[r1,#0xd]  ; g_I2C_Setting
000194  1dc9              ADDS     r1,r1,#7
000196  54ca              STRB     r2,[r1,r3]
;;;152    		g_I2C_Setting.RdIndex++;
000198  1fc9              SUBS     r1,r1,#7
00019a  7b49              LDRB     r1,[r1,#0xd]  ; g_I2C_Setting
00019c  1c49              ADDS     r1,r1,#1
00019e  4a70              LDR      r2,|L1.864|
0001a0  7351              STRB     r1,[r2,#0xd]
;;;153    		g_I2C_Setting.I2CMasterState = DATA_NACK;
0001a2  2107              MOVS     r1,#7
0001a4  7011              STRB     r1,[r2,#0]
;;;154    		LPC_I2C->CONSET = I2CONSET_STO;/* Set Stop flag */ 
0001a6  2110              MOVS     r1,#0x10
0001a8  068a              LSLS     r2,r1,#26
0001aa  6011              STR      r1,[r2,#0]
;;;155    		LPC_I2C->CONCLR = I2CONCLR_SIC;/* Clear SI flag */
0001ac  2108              MOVS     r1,#8
0001ae  6191              STR      r1,[r2,#0x18]
;;;156    		break;
0001b0  e006              B        |L1.448|
;;;157    
;;;158    		case 0x20:/* regardless, it's a NACK */
;;;159    		case 0x48:		
0001b2  bf00              NOP      
;;;160    		g_I2C_Setting.I2CMasterState = DATA_NACK;
0001b4  2107              MOVS     r1,#7
0001b6  4a6a              LDR      r2,|L1.864|
0001b8  7011              STRB     r1,[r2,#0]
;;;161    		break;
0001ba  e001              B        |L1.448|
                  |L1.444|
;;;162    	
;;;163    		case 0x38:/* Arbitration lost, in this example, we don't
0001bc  bf00              NOP      
;;;164    		deal with multiple master situation */
;;;165    		default:		
;;;166    		break;
0001be  bf00              NOP      
                  |L1.448|
0001c0  bf00              NOP                            ;53
;;;167    	}
;;;168    
;;;169    	LPC_I2C->CONCLR = I2CONCLR_SIC;	
0001c2  2108              MOVS     r1,#8
0001c4  06ca              LSLS     r2,r1,#27
0001c6  6191              STR      r1,[r2,#0x18]
;;;170    }
0001c8  bd00              POP      {pc}
;;;171    
                          ENDP

                  NDrv_API_I2C_Start PROC
;;;182    *****************************************************************************/
;;;183    Boolean NDrv_API_I2C_Start(void)
0001ca  2100              MOVS     r1,#0
;;;184    {
;;;185    	U32 Timeout = 0;
;;;186    	U8 retVal = FALSE;
0001cc  2000              MOVS     r0,#0
;;;187    
;;;188    	LPC_I2C->CONCLR = I2CONCLR_AAC | I2CONCLR_SIC | I2CONCLR_STAC | I2CONCLR_I2ENC;  
0001ce  226c              MOVS     r2,#0x6c
0001d0  2301              MOVS     r3,#1
0001d2  079b              LSLS     r3,r3,#30
0001d4  619a              STR      r2,[r3,#0x18]
;;;189    	/*--- Issue a start condition ---*/
;;;190    	LPC_I2C->CONSET = I2CONSET_STA|I2CONSET_I2EN;/* Set Start flag */       
0001d6  2260              MOVS     r2,#0x60
0001d8  601a              STR      r2,[r3,#0]
;;;191    	/*--- Wait until START transmitted ---*/
;;;192    	while(1)
0001da  e00b              B        |L1.500|
                  |L1.476|
;;;193    	{
;;;194    		if(g_I2C_Setting.I2CMasterState == I2C_DEVICEARD)
0001dc  4a60              LDR      r2,|L1.864|
0001de  7812              LDRB     r2,[r2,#0]  ; g_I2C_Setting
0001e0  2a01              CMP      r2,#1
0001e2  d101              BNE      |L1.488|
;;;195    		{    
;;;196    			retVal = TRUE;
0001e4  2001              MOVS     r0,#1
;;;197    			break;	
0001e6  e006              B        |L1.502|
                  |L1.488|
;;;198    		}
;;;199    		
;;;200    		if(Timeout >= MAX_TIMEOUT )
0001e8  4a5e              LDR      r2,|L1.868|
0001ea  4291              CMP      r1,r2
0001ec  d301              BCC      |L1.498|
;;;201    		{
;;;202    			retVal = FALSE;
0001ee  2000              MOVS     r0,#0
;;;203    			break;
0001f0  e001              B        |L1.502|
                  |L1.498|
;;;204    		}
;;;205    		Timeout++;
0001f2  1c49              ADDS     r1,r1,#1
                  |L1.500|
0001f4  e7f2              B        |L1.476|
                  |L1.502|
0001f6  bf00              NOP                            ;197
;;;206    	}	
;;;207    	return(retVal);
;;;208    }
0001f8  4770              BX       lr
;;;209    
                          ENDP

                  NDrv_API_I2C_Stop PROC
;;;219    *****************************************************************************/
;;;220    void NDrv_API_I2C_Stop(void)
0001fa  2050              MOVS     r0,#0x50
;;;221    {
;;;222    	LPC_I2C->CONSET = I2CONSET_STO|I2CONSET_I2EN;/* Set Stop flag */ 
0001fc  0681              LSLS     r1,r0,#26
0001fe  6008              STR      r0,[r1,#0]
;;;223    	LPC_I2C->CONCLR = I2CONCLR_SIC|I2CONCLR_STAC|I2CONCLR_AAC;/* Clear SI flag */ 
000200  202c              MOVS     r0,#0x2c
000202  6188              STR      r0,[r1,#0x18]
;;;224    
;;;225    	/*--- Wait for STOP detected ---*/
;;;226    	while( LPC_I2C->CONSET & I2CONSET_STO ){}  
000204  bf00              NOP      
                  |L1.518|
000206  2001              MOVS     r0,#1
000208  0780              LSLS     r0,r0,#30
00020a  6800              LDR      r0,[r0,#0]
00020c  2110              MOVS     r1,#0x10
00020e  4008              ANDS     r0,r0,r1
000210  2800              CMP      r0,#0
000212  d1f8              BNE      |L1.518|
;;;227    }
000214  4770              BX       lr
;;;228    
                          ENDP

                  nsAPI_I2C_Init PROC
;;;238    *****************************************************************************/
;;;239    void nsAPI_I2C_Init(void) 
000216  b510              PUSH     {r4,lr}
;;;240    {
;;;241    	NVIC_DisableIRQ(I2C_IRQn);   
000218  200f              MOVS     r0,#0xf
00021a  2101              MOVS     r1,#1
00021c  4081              LSLS     r1,r1,r0
00021e  4a52              LDR      r2,|L1.872|
000220  6011              STR      r1,[r2,#0]
000222  bf00              NOP      
;;;242    
;;;243    	g_I2C_Setting.I2CMasterState = I2C_IDLE;
000224  2000              MOVS     r0,#0
000226  494e              LDR      r1,|L1.864|
000228  7008              STRB     r0,[r1,#0]
;;;244    	g_I2C_Setting.I2CBusState = I2C_BUS_IDLE;
00022a  7088              STRB     r0,[r1,#2]
;;;245    	g_I2C_Setting.I2CReadLength = 0;
00022c  72c8              STRB     r0,[r1,#0xb]
;;;246    	g_I2C_Setting.I2CWriteLength = 0;
00022e  7308              STRB     r0,[r1,#0xc]
;;;247    	g_I2C_Setting.RdIndex = 0;
000230  7348              STRB     r0,[r1,#0xd]
;;;248    	g_I2C_Setting.WrIndex = 0;
000232  7388              STRB     r0,[r1,#0xe]
;;;249    	
;;;250    	/* It seems to be bit0 is for I2C, different from
;;;251    	UM. To be retested along with SSP reset. SSP and I2C
;;;252    	reset are overlapped, a known bug, for now, both SSP 
;;;253    	and I2C use bit 0 for reset enable. Once the problem
;;;254    	is fixed, change to "#if 1". */
;;;255    #if 1
;;;256    	LPC_SYSCON->PRESETCTRL |= BIT1;
000234  484d              LDR      r0,|L1.876|
000236  6840              LDR      r0,[r0,#4]
000238  2102              MOVS     r1,#2
00023a  4308              ORRS     r0,r0,r1
00023c  494b              LDR      r1,|L1.876|
00023e  6048              STR      r0,[r1,#4]
;;;257    #else
;;;258    	LPC_SYSCON->PRESETCTRL |= BIT0;
;;;259    #endif
;;;260    	LPC_SYSCON->SYSAHBCLKCTRL |= BIT5;
000240  484a              LDR      r0,|L1.876|
000242  3080              ADDS     r0,r0,#0x80
000244  6800              LDR      r0,[r0,#0]
000246  2120              MOVS     r1,#0x20
000248  4308              ORRS     r0,r0,r1
00024a  4948              LDR      r1,|L1.876|
00024c  3180              ADDS     r1,r1,#0x80
00024e  6008              STR      r0,[r1,#0]
;;;261    	LPC_IOCON->PIO0_4 &= ~0x3F;/* I2C I/O config */
000250  4847              LDR      r0,|L1.880|
000252  6900              LDR      r0,[r0,#0x10]
000254  0980              LSRS     r0,r0,#6
000256  0180              LSLS     r0,r0,#6
000258  4945              LDR      r1,|L1.880|
00025a  6108              STR      r0,[r1,#0x10]
;;;262    	LPC_IOCON->PIO0_4 |= BIT0;/*  I2C SCL */
00025c  4608              MOV      r0,r1
00025e  6900              LDR      r0,[r0,#0x10]
000260  2101              MOVS     r1,#1
000262  4308              ORRS     r0,r0,r1
000264  4942              LDR      r1,|L1.880|
000266  6108              STR      r0,[r1,#0x10]
;;;263    	LPC_IOCON->PIO0_5 &= ~0x3F;	
000268  4608              MOV      r0,r1
00026a  6940              LDR      r0,[r0,#0x14]
00026c  0980              LSRS     r0,r0,#6
00026e  0180              LSLS     r0,r0,#6
000270  6148              STR      r0,[r1,#0x14]
;;;264    	LPC_IOCON->PIO0_5 |= BIT0;/* I2C SDA */
000272  4608              MOV      r0,r1
000274  6940              LDR      r0,[r0,#0x14]
000276  2101              MOVS     r1,#1
000278  4308              ORRS     r0,r0,r1
00027a  493d              LDR      r1,|L1.880|
00027c  6148              STR      r0,[r1,#0x14]
;;;265    	
;;;266    	/*--- Clear flags ---*/
;;;267    	LPC_I2C->CONCLR = I2CONCLR_AAC | I2CONCLR_SIC | I2CONCLR_STAC | I2CONCLR_I2ENC; 
00027e  206c              MOVS     r0,#0x6c
000280  0409              LSLS     r1,r1,#16
000282  6188              STR      r0,[r1,#0x18]
;;;268    	LPC_I2C->SCLL = I2SCLL_SCLL;
000284  493b              LDR      r1,|L1.884|
000286  483c              LDR      r0,|L1.888|
000288  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00028a  f7fffffe          BL       __aeabi_uidivmod
00028e  0840              LSRS     r0,r0,#1
000290  2101              MOVS     r1,#1
000292  0789              LSLS     r1,r1,#30
000294  6148              STR      r0,[r1,#0x14]
;;;269    	LPC_I2C->SCLH = I2SCLH_SCLH;
000296  4937              LDR      r1,|L1.884|
000298  4837              LDR      r0,|L1.888|
00029a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00029c  f7fffffe          BL       __aeabi_uidivmod
0002a0  0840              LSRS     r0,r0,#1
0002a2  2101              MOVS     r1,#1
0002a4  0789              LSLS     r1,r1,#30
0002a6  6108              STR      r0,[r1,#0x10]
;;;270    	LPC_I2C->ADR0 = AT24C512_ADDR; 
0002a8  20a0              MOVS     r0,#0xa0
0002aa  60c8              STR      r0,[r1,#0xc]
;;;271    	/* Enable the I2C Interrupt */
;;;272    	NVIC_EnableIRQ(I2C_IRQn);
0002ac  200f              MOVS     r0,#0xf
0002ae  2101              MOVS     r1,#1
0002b0  4081              LSLS     r1,r1,r0
0002b2  4a2d              LDR      r2,|L1.872|
0002b4  3a80              SUBS     r2,r2,#0x80
0002b6  6011              STR      r1,[r2,#0]
0002b8  bf00              NOP      
;;;273    	
;;;274    }
0002ba  bd10              POP      {r4,pc}
;;;275    
                          ENDP

                  nsAPI_I2C_Write PROC
;;;276    
;;;277    void nsAPI_I2C_Write(void)
0002bc  b510              PUSH     {r4,lr}
;;;278    {
;;;279          U8 u8Brk = 1; 
0002be  2401              MOVS     r4,#1
;;;280     
;;;281    	g_I2C_Setting.I2CDeviceAdr = AT24C512_ADDR;     
0002c0  20a0              MOVS     r0,#0xa0
0002c2  4927              LDR      r1,|L1.864|
0002c4  7048              STRB     r0,[r1,#1]
;;;282    	g_I2C_Setting.I2CMasterState = I2C_IDLE;		
0002c6  2000              MOVS     r0,#0
0002c8  7008              STRB     r0,[r1,#0]
;;;283    
;;;284    	if(NDrv_API_I2C_Start() != TRUE)
0002ca  f7fffffe          BL       NDrv_API_I2C_Start
0002ce  2801              CMP      r0,#1
0002d0  d002              BEQ      |L1.728|
;;;285    	{	   
;;;286    		NDrv_API_I2C_Stop();
0002d2  f7fffffe          BL       NDrv_API_I2C_Stop
                  |L1.726|
;;;287    		return;
;;;288    	}
;;;289    
;;;290    	while(u8Brk)
;;;291    	{	 
;;;292    		if(g_I2C_Setting.I2CMasterState == DATA_NACK)
;;;293    		{	
;;;294    			u8Brk = 0;
;;;295    			NDrv_API_I2C_Stop();			
;;;296    		}
;;;297    	} 
;;;298    }
0002d6  bd10              POP      {r4,pc}
                  |L1.728|
0002d8  e006              B        |L1.744|
                  |L1.730|
0002da  4821              LDR      r0,|L1.864|
0002dc  7800              LDRB     r0,[r0,#0]            ;292  ; g_I2C_Setting
0002de  2807              CMP      r0,#7                 ;292
0002e0  d102              BNE      |L1.744|
0002e2  2400              MOVS     r4,#0                 ;294
0002e4  f7fffffe          BL       NDrv_API_I2C_Stop
                  |L1.744|
0002e8  2c00              CMP      r4,#0                 ;290
0002ea  d1f6              BNE      |L1.730|
0002ec  bf00              NOP      
0002ee  e7f2              B        |L1.726|
;;;299    
                          ENDP

                  nsAPI_I2C_Read PROC
;;;300    void nsAPI_I2C_Read(void)
0002f0  b500              PUSH     {lr}
;;;301    {
;;;302    	g_I2C_Setting.I2CDeviceAdr = AT24C512_ADDR|READ_STATUS;  
0002f2  20a1              MOVS     r0,#0xa1
0002f4  491a              LDR      r1,|L1.864|
0002f6  7048              STRB     r0,[r1,#1]
;;;303    	g_I2C_Setting.I2CMasterState = I2C_IDLE;	
0002f8  2000              MOVS     r0,#0
0002fa  7008              STRB     r0,[r1,#0]
;;;304    	g_I2C_Setting.RdIndex = 0;		
0002fc  7348              STRB     r0,[r1,#0xd]
;;;305    
;;;306    	if(NDrv_API_I2C_Start() != TRUE)
0002fe  f7fffffe          BL       NDrv_API_I2C_Start
000302  2801              CMP      r0,#1
000304  d002              BEQ      |L1.780|
;;;307    	{	   
;;;308    		NDrv_API_I2C_Stop();
000306  f7fffffe          BL       NDrv_API_I2C_Stop
                  |L1.778|
;;;309    		return;
;;;310    	}
;;;311    
;;;312    	while(1)
;;;313    	{	 
;;;314    		if(g_I2C_Setting.I2CMasterState == DATA_NACK)
;;;315    		{		
;;;316    			NDrv_API_I2C_Stop();
;;;317    			break;
;;;318    		}
;;;319    	} 
;;;320    }
00030a  bd00              POP      {pc}
                  |L1.780|
00030c  e006              B        |L1.796|
                  |L1.782|
00030e  4814              LDR      r0,|L1.864|
000310  7800              LDRB     r0,[r0,#0]            ;314  ; g_I2C_Setting
000312  2807              CMP      r0,#7                 ;314
000314  d102              BNE      |L1.796|
000316  f7fffffe          BL       NDrv_API_I2C_Stop
00031a  e000              B        |L1.798|
                  |L1.796|
00031c  e7f7              B        |L1.782|
                  |L1.798|
00031e  bf00              NOP                            ;317
000320  bf00              NOP      
000322  e7f2              B        |L1.778|
;;;321    
                          ENDP

                  nsAPI_I2C_Write_Database PROC
;;;322    void nsAPI_I2C_Write_Database(U16 u16Adr,U8 *pBuf)
000324  b530              PUSH     {r4,r5,lr}
;;;323    {	
000326  4605              MOV      r5,r0
000328  460c              MOV      r4,r1
;;;324    	g_I2C_Setting.I2CWordAdr = u16Adr;/*Word Address*/  
00032a  480d              LDR      r0,|L1.864|
00032c  8205              STRH     r5,[r0,#0x10]
;;;325    	g_I2C_Setting.I2CBusState = I2C_BUS_WRITE;
00032e  2001              MOVS     r0,#1
000330  490b              LDR      r1,|L1.864|
000332  7088              STRB     r0,[r1,#2]
;;;326    	g_I2C_Setting.I2CMasterBuffer[GIdx0] = *pBuf;/*Data*/ 
000334  7820              LDRB     r0,[r4,#0]
000336  70c8              STRB     r0,[r1,#3]
;;;327    
;;;328    	g_I2C_Setting.I2CWriteLength = GIdx1;
000338  2001              MOVS     r0,#1
00033a  7308              STRB     r0,[r1,#0xc]
;;;329    
;;;330    	nsAPI_I2C_Write();
00033c  f7fffffe          BL       nsAPI_I2C_Write
;;;331    }
000340  bd30              POP      {r4,r5,pc}
;;;332    
                          ENDP

                  nsAPI_I2C_Read_Database PROC
;;;333    RetU8 nsAPI_I2C_Read_Database(U16 u16Adr)
000342  b510              PUSH     {r4,lr}
;;;334    {	
000344  4604              MOV      r4,r0
;;;335    	g_I2C_Setting.I2CWordAdr = u16Adr;/*Word Address*/ 	
000346  4806              LDR      r0,|L1.864|
000348  8204              STRH     r4,[r0,#0x10]
;;;336    	g_I2C_Setting.I2CBusState = I2C_BUS_READ;		
00034a  2002              MOVS     r0,#2
00034c  4904              LDR      r1,|L1.864|
00034e  7088              STRB     r0,[r1,#2]
;;;337    	g_I2C_Setting.I2CWriteLength = GIdx0;
000350  2000              MOVS     r0,#0
000352  7308              STRB     r0,[r1,#0xc]
;;;338    
;;;339    	nsAPI_I2C_Write();	
000354  f7fffffe          BL       nsAPI_I2C_Write
;;;340    	//nsAPI_SSP_Delsy1us(1000);/*1ms*/	
;;;341    
;;;342    	_DEBUG_I2C_(xprintf("\r\n buf=%x",g_I2C_Setting.I2CSlaveBuffer[0]));	
;;;343    
;;;344    	return (g_I2C_Setting.I2CSlaveBuffer[0]);
000358  4801              LDR      r0,|L1.864|
00035a  79c0              LDRB     r0,[r0,#7]  ; g_I2C_Setting
;;;345    }
00035c  bd10              POP      {r4,pc}
;;;346    
                          ENDP

00035e  0000              DCW      0x0000
                  |L1.864|
                          DCD      g_I2C_Setting
                  |L1.868|
                          DCD      0x00ffffff
                  |L1.872|
                          DCD      0xe000e180
                  |L1.876|
                          DCD      0x40048000
                  |L1.880|
                          DCD      0x40044000
                  |L1.884|
                          DCD      0x00061a80
                  |L1.888|
                          DCD      SystemCoreClock

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  g_I2C_Setting
                          %        18

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L16.24|
                  |L16.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L16.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L16.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "Src\\I2c.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___5_I2c_c_930b201d____REV16|
#line 112 ".\\Inc\\core_cmInstr.h"
|__asm___5_I2c_c_930b201d____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___5_I2c_c_930b201d____REVSH|
#line 130
|__asm___5_I2c_c_930b201d____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
