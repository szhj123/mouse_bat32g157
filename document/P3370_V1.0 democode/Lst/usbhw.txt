; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\usbhw.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\obj\usbhw.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\INC\NXP\LPC11Uxx -D__MICROLIB -D__UVISION_VERSION=536 -D__DEBUG_FLASH --omf_browse=.\obj\usbhw.crf Src\usbhw.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  EPAdr PROC
;;;69      */
;;;70     static RetU32 EPAdr(U32 EPNum)
000000  4601              MOV      r1,r0
;;;71     {
;;;72     	U32 val;
;;;73     
;;;74     	val = (EPNum & 0x0F) << 1;
000002  070a              LSLS     r2,r1,#28
000004  0ed0              LSRS     r0,r2,#27
;;;75     
;;;76     	if(EPNum & 0x80)
000006  2280              MOVS     r2,#0x80
000008  400a              ANDS     r2,r2,r1
00000a  2a00              CMP      r2,#0
00000c  d000              BEQ      |L1.16|
;;;77     	{
;;;78     		val += 1;
00000e  1c40              ADDS     r0,r0,#1
                  |L1.16|
;;;79     	}
;;;80     	return (val);
;;;81     }
000010  4770              BX       lr
;;;82     
                          ENDP

                  NDrv_USB_IOClkConfig PROC
;;;89      */
;;;90     void NDrv_USB_IOClkConfig(void)
000012  48fe              LDR      r0,|L1.1036|
;;;91     {
;;;92     	/* Enable AHB clock to the GPIO domain. */
;;;93     	LPC_SYSCON->SYSAHBCLKCTRL |= BIT6;
000014  6800              LDR      r0,[r0,#0]
000016  2140              MOVS     r1,#0x40
000018  4308              ORRS     r0,r0,r1
00001a  49fc              LDR      r1,|L1.1036|
00001c  6008              STR      r0,[r1,#0]
;;;94     
;;;95     	/* Enable AHB clock to the USB block and USB RAM. */
;;;96     	LPC_SYSCON->SYSAHBCLKCTRL |= (BIT14|BIT27);
00001e  4608              MOV      r0,r1
000020  6800              LDR      r0,[r0,#0]
000022  49fb              LDR      r1,|L1.1040|
000024  4308              ORRS     r0,r0,r1
000026  49f9              LDR      r1,|L1.1036|
000028  6008              STR      r0,[r1,#0]
;;;97     
;;;98     	/* Pull-down is needed, or internally, VBUS will be floating. This is to
;;;99     	address the wrong status in VBUSDebouncing bit in CmdStatus register. It
;;;100    	happens on the NXP Validation Board only that a wrong ESD protection chip is used. */
;;;101    	LPC_IOCON->PIO0_3 &= ~0x1F;
00002a  48fa              LDR      r0,|L1.1044|
00002c  68c0              LDR      r0,[r0,#0xc]
00002e  0940              LSRS     r0,r0,#5
000030  0140              LSLS     r0,r0,#5
000032  49f8              LDR      r1,|L1.1044|
000034  60c8              STR      r0,[r1,#0xc]
;;;102    	LPC_IOCON->PIO0_3 |= (BIT3|BIT0);	/* Secondary function VBUS */
000036  4608              MOV      r0,r1
000038  68c0              LDR      r0,[r0,#0xc]
00003a  2109              MOVS     r1,#9
00003c  4308              ORRS     r0,r0,r1
00003e  49f5              LDR      r1,|L1.1044|
000040  60c8              STR      r0,[r1,#0xc]
;;;103    	//  LPC_IOCON->PIO0_3   |= (0x01<<0);			/* Secondary function VBUS */
;;;104    	LPC_IOCON->PIO0_6 &= ~0x07;
000042  4608              MOV      r0,r1
000044  6980              LDR      r0,[r0,#0x18]
000046  08c0              LSRS     r0,r0,#3
000048  00c0              LSLS     r0,r0,#3
00004a  6188              STR      r0,[r1,#0x18]
;;;105    	LPC_IOCON->PIO0_6 |= BIT0;			/* Secondary function SoftConn */
00004c  4608              MOV      r0,r1
00004e  6980              LDR      r0,[r0,#0x18]
000050  2101              MOVS     r1,#1
000052  4308              ORRS     r0,r0,r1
000054  49ef              LDR      r1,|L1.1044|
000056  6188              STR      r0,[r1,#0x18]
;;;106    
;;;107    #if POWERDOWN_MODE_USB_WAKEUP
;;;108    	LPC_USB->DEVCMDSTAT &= ~USB_PLL_ON;	/* NeedClk normal mode(not ALWAYS ON) */
;;;109    	LPC_SYSCON->USBCLKCTRL = 0x1<<1;  /* USB wakeup interrupt on rising edge of Needclk. */
;;;110    #endif
;;;111    }
000058  4770              BX       lr
;;;112    
                          ENDP

                  USB_GetEPCmdStatusPtr PROC
;;;155     */
;;;156    RetU32 USB_GetEPCmdStatusPtr(U32 EPNum)
00005a  b570              PUSH     {r4-r6,lr}
;;;157    {
00005c  4605              MOV      r5,r0
;;;158    	U32 addr;
;;;159    
;;;160    	addr = (U32)USB_EPLIST_ADDR;
00005e  4cee              LDR      r4,|L1.1048|
;;;161    	addr += ((EPAdr(EPNum)*2) << 2);/* Based on EPCommand/Status List, all EPs are double buffered except CTRL EP 0, size is 32-bit. */
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       EPAdr
000066  00c0              LSLS     r0,r0,#3
000068  1904              ADDS     r4,r0,r4
;;;162    	return (addr);
00006a  4620              MOV      r0,r4
;;;163    }
00006c  bd70              POP      {r4-r6,pc}
;;;164    
                          ENDP

                  NDrv_USB_EPInit PROC
;;;174     */
;;;175    void NDrv_USB_EPInit(void)
00006e  b570              PUSH     {r4-r6,lr}
;;;176    {
;;;177    	U32 *addr, data_ptr,i, j = 0;
000070  2100              MOVS     r1,#0
;;;178    
;;;179    	addr = (U32 *)USB_EPLIST_ADDR;
000072  4ae9              LDR      r2,|L1.1048|
;;;180    	LPC_USB->EPLISTSTART = USB_EPLIST_ADDR;
000074  4614              MOV      r4,r2
000076  4de9              LDR      r5,|L1.1052|
000078  60ac              STR      r4,[r5,#8]
;;;181    	data_ptr = USB_EPDATA_ADDR;
00007a  48e9              LDR      r0,|L1.1056|
;;;182    	LPC_USB->DATABUFSTART = USB_EPDATA_PAGE;
00007c  026c              LSLS     r4,r5,#9
00007e  60ec              STR      r4,[r5,#0xc]
;;;183    
;;;184    	/* CTRL, BULK or Interrupt IN/OUT EPs, max EP size is 64 */
;;;185    	/* For EP0, double buffer doesn't apply to CTRL EPs, but, EP0OUTBuf0 is
;;;186    	for EP0OUT, EP0OUTBuf1 is for SETUP, EP0INBuf0 is for EP0IN, EP0INTBuf1 is
;;;187    	reserved. Also note: ACTIVE bit doesn't apply to SETUP and Reserved EP buffer. */
;;;188    	*addr++ = (USB_MAX_PACKET0 << 16)|((U16)(data_ptr >> 6));
000080  0284              LSLS     r4,r0,#10
000082  0c24              LSRS     r4,r4,#16
000084  00ed              LSLS     r5,r5,#3
000086  432c              ORRS     r4,r4,r5
000088  c210              STM      r2!,{r4}
;;;189    	g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
00008a  00cd              LSLS     r5,r1,#3
00008c  4ce5              LDR      r4,|L1.1060|
00008e  5160              STR      r0,[r4,r5]
;;;190    	g_USBHW_Setting.EPList[j++].buf_length = USB_MAX_PACKET0;
000090  2640              MOVS     r6,#0x40
000092  460c              MOV      r4,r1
000094  1c49              ADDS     r1,r1,#1
000096  00e5              LSLS     r5,r4,#3
000098  4ce2              LDR      r4,|L1.1060|
00009a  192c              ADDS     r4,r5,r4
00009c  6066              STR      r6,[r4,#4]
;;;191    	data_ptr += USB_MAX_PACKET0;
00009e  3040              ADDS     r0,r0,#0x40
;;;192    
;;;193    	*addr++ = ((U16)(data_ptr >> 6));/* No length field for SETUP */
0000a0  0284              LSLS     r4,r0,#10
0000a2  0c24              LSRS     r4,r4,#16
0000a4  c210              STM      r2!,{r4}
;;;194    	g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
0000a6  00cd              LSLS     r5,r1,#3
0000a8  4cde              LDR      r4,|L1.1060|
0000aa  5160              STR      r0,[r4,r5]
;;;195    	g_USBHW_Setting.EPList[j++].buf_length = USB_SETUP_PACKET_SIZE;
0000ac  2608              MOVS     r6,#8
0000ae  460d              MOV      r5,r1
0000b0  1c49              ADDS     r1,r1,#1
0000b2  00ed              LSLS     r5,r5,#3
0000b4  192c              ADDS     r4,r5,r4
0000b6  6066              STR      r6,[r4,#4]
;;;196    	/* For easier alignment, the data field is aligned to 64 bytes for all EPs. */
;;;197    	data_ptr += USB_MAX_PACKET0;
0000b8  3040              ADDS     r0,r0,#0x40
;;;198    
;;;199    	*addr++ = (USB_MAX_PACKET0 << 16)|((U16)(data_ptr >> 6));
0000ba  0284              LSLS     r4,r0,#10
0000bc  0c24              LSRS     r4,r4,#16
0000be  054d              LSLS     r5,r1,#21
0000c0  432c              ORRS     r4,r4,r5
0000c2  c210              STM      r2!,{r4}
;;;200    	g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
0000c4  00cd              LSLS     r5,r1,#3
0000c6  4cd7              LDR      r4,|L1.1060|
0000c8  5160              STR      r0,[r4,r5]
;;;201    	g_USBHW_Setting.EPList[j++].buf_length = USB_MAX_PACKET0;
0000ca  2640              MOVS     r6,#0x40
0000cc  460d              MOV      r5,r1
0000ce  1c49              ADDS     r1,r1,#1
0000d0  00ed              LSLS     r5,r5,#3
0000d2  192c              ADDS     r4,r5,r4
0000d4  6066              STR      r6,[r4,#4]
;;;202    	data_ptr += USB_MAX_PACKET0;
0000d6  3040              ADDS     r0,r0,#0x40
;;;203    
;;;204    #if 0
;;;205    	/* EP0 IN second buffer(buffer1) is reserved. */
;;;206    	*addr++ = (USB_MAX_PACKET0<<16)|((uint16_t)(data_ptr>>6));
;;;207    #else
;;;208    	addr++;
0000d8  1d12              ADDS     r2,r2,#4
;;;209    #endif
;;;210    
;;;211    	g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
0000da  00cd              LSLS     r5,r1,#3
0000dc  4cd1              LDR      r4,|L1.1060|
0000de  5160              STR      r0,[r4,r5]
;;;212    	g_USBHW_Setting.EPList[j++].buf_length = USB_MAX_PACKET0;
0000e0  460d              MOV      r5,r1
0000e2  1c49              ADDS     r1,r1,#1
0000e4  00ed              LSLS     r5,r5,#3
0000e6  192c              ADDS     r4,r5,r4
0000e8  6066              STR      r6,[r4,#4]
;;;213    	data_ptr += USB_MAX_PACKET0;
0000ea  3040              ADDS     r0,r0,#0x40
;;;214    
;;;215    	for(i = 2; i < USB_EP_NUM; i++)
0000ec  2302              MOVS     r3,#2
0000ee  e01e              B        |L1.302|
                  |L1.240|
;;;216    	{
;;;217    		/* Buffer 0 */
;;;218    #if USB_ISO_COMMUNICATION
;;;219    		*addr++ = EP_DISABLED|EP_ISO_TYPE|(USB_MAX_ISO_SIZE << 16)|((U16)(data_ptr >> 6));
;;;220    		g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
;;;221    		g_USBHW_Setting.EPList[j++].buf_length = USB_MAX_ISO_SIZE;
;;;222    		data_ptr += USB_MAX_ISO_SIZE;
;;;223    #else
;;;224    		*addr++ = EP_DISABLED|(USB_MAX_NON_ISO_SIZE << 16)|((U16)(data_ptr >> 6));
0000f0  0284              LSLS     r4,r0,#10
0000f2  0c24              LSRS     r4,r4,#16
0000f4  4dcc              LDR      r5,|L1.1064|
0000f6  432c              ORRS     r4,r4,r5
0000f8  c210              STM      r2!,{r4}
;;;225    		g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
0000fa  00cd              LSLS     r5,r1,#3
0000fc  4cc9              LDR      r4,|L1.1060|
0000fe  5160              STR      r0,[r4,r5]
;;;226    		g_USBHW_Setting.EPList[j++].buf_length = USB_MAX_NON_ISO_SIZE;
000100  2640              MOVS     r6,#0x40
000102  460d              MOV      r5,r1
000104  1c49              ADDS     r1,r1,#1
000106  00ed              LSLS     r5,r5,#3
000108  192c              ADDS     r4,r5,r4
00010a  6066              STR      r6,[r4,#4]
;;;227    		data_ptr += USB_MAX_NON_ISO_SIZE;
00010c  3040              ADDS     r0,r0,#0x40
;;;228    #endif
;;;229    		/* Buffer 1 */
;;;230    #if USB_ISO_COMMUNICATION
;;;231    		*addr++ = EP_DISABLED|EP_ISO_TYPE|(USB_MAX_ISO_SIZE << 16)|((U16)(data_ptr >> 6));
;;;232    		g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
;;;233    		g_USBHW_Setting.EPList[j++].buf_length = USB_MAX_ISO_SIZE;
;;;234    		data_ptr += USB_MAX_ISO_SIZE;
;;;235    #else
;;;236    		*addr++ = EP_DISABLED|(USB_MAX_NON_ISO_SIZE << 16)|((U16)(data_ptr >> 6));
00010e  0284              LSLS     r4,r0,#10
000110  0c24              LSRS     r4,r4,#16
000112  4dc5              LDR      r5,|L1.1064|
000114  432c              ORRS     r4,r4,r5
000116  c210              STM      r2!,{r4}
;;;237    		g_USBHW_Setting.EPList[j].buf_ptr = data_ptr;
000118  00cd              LSLS     r5,r1,#3
00011a  4cc2              LDR      r4,|L1.1060|
00011c  5160              STR      r0,[r4,r5]
;;;238    		g_USBHW_Setting.EPList[j++].buf_length = USB_MAX_NON_ISO_SIZE;
00011e  460c              MOV      r4,r1
000120  1c49              ADDS     r1,r1,#1
000122  00e5              LSLS     r5,r4,#3
000124  4cbf              LDR      r4,|L1.1060|
000126  192c              ADDS     r4,r5,r4
000128  6066              STR      r6,[r4,#4]
;;;239    		data_ptr += USB_MAX_NON_ISO_SIZE;
00012a  3040              ADDS     r0,r0,#0x40
00012c  1c5b              ADDS     r3,r3,#1              ;215
                  |L1.302|
00012e  2b04              CMP      r3,#4                 ;215
000130  d3de              BCC      |L1.240|
;;;240    #endif
;;;241    	}
;;;242    }
000132  bd70              POP      {r4-r6,pc}
;;;243    
                          ENDP

                  NDrv_USB_Connect PROC
;;;288    
;;;289    void NDrv_USB_Connect(U8 con)
000134  2800              CMP      r0,#0
;;;290    {
;;;291    	if(con)
000136  d007              BEQ      |L1.328|
;;;292    	LPC_USB->DEVCMDSTAT |= USB_DCON;
000138  49b8              LDR      r1,|L1.1052|
00013a  6809              LDR      r1,[r1,#0]
00013c  2201              MOVS     r2,#1
00013e  0412              LSLS     r2,r2,#16
000140  4311              ORRS     r1,r1,r2
000142  4ab6              LDR      r2,|L1.1052|
000144  6011              STR      r1,[r2,#0]
000146  e006              B        |L1.342|
                  |L1.328|
;;;293    	else
;;;294    	LPC_USB->DEVCMDSTAT &= ~USB_DCON;
000148  49b4              LDR      r1,|L1.1052|
00014a  6809              LDR      r1,[r1,#0]
00014c  2201              MOVS     r2,#1
00014e  0412              LSLS     r2,r2,#16
000150  4391              BICS     r1,r1,r2
000152  4ab2              LDR      r2,|L1.1052|
000154  6011              STR      r1,[r2,#0]
                  |L1.342|
;;;295    }
000156  4770              BX       lr
;;;296    
                          ENDP

                  NDrv_USB_Reset PROC
;;;304    
;;;305    void NDrv_USB_Reset(void)
000158  b500              PUSH     {lr}
;;;306    {
;;;307    	g_USBHW_Setting.BufferUsed = 0;
00015a  2000              MOVS     r0,#0
00015c  49b1              LDR      r1,|L1.1060|
00015e  3908              SUBS     r1,r1,#8
000160  6008              STR      r0,[r1,#0]  ; g_USBHW_Setting
;;;308    	g_USBHW_Setting.EPActiveFlag = 0;
000162  6048              STR      r0,[r1,#4]  ; g_USBHW_Setting
;;;309    
;;;310    	/* Initialize EP Command/Status List. */
;;;311    	NDrv_USB_EPInit();
000164  f7fffffe          BL       NDrv_USB_EPInit
;;;312    
;;;313    	LPC_USB->DEVCMDSTAT |= USB_EN;
000168  48ac              LDR      r0,|L1.1052|
00016a  6800              LDR      r0,[r0,#0]
00016c  2180              MOVS     r1,#0x80
00016e  4308              ORRS     r0,r0,r1
000170  49aa              LDR      r1,|L1.1052|
000172  6008              STR      r0,[r1,#0]
;;;314    	/* Clear all EP interrupts, device status, and SOF interrupts. */
;;;315    	LPC_USB->INTSTAT = 0xC00003FF;
000174  48ad              LDR      r0,|L1.1068|
000176  6208              STR      r0,[r1,#0x20]
;;;316    	/* Enable all ten(10) EPs interrupts including EP0, note: EP won't be
;;;317    	ready until it's configured/enabled when device sending SetEPStatus command
;;;318    	to the command engine. */
;;;319    	LPC_USB->INTEN  = DEV_STAT_INT | 0x3FF | (USB_SOF_EVENT ? FRAME_INT : 0);
000178  48ad              LDR      r0,|L1.1072|
00017a  6248              STR      r0,[r1,#0x24]
;;;320    }
00017c  bd00              POP      {pc}
;;;321    
                          ENDP

                  nsAPI_USB_Init PROC
;;;250    
;;;251    void nsAPI_USB_Init (void)
00017e  b500              PUSH     {lr}
;;;252    {
;;;253    	NVIC_DisableIRQ(USB_IRQn);
000180  2016              MOVS     r0,#0x16
000182  2101              MOVS     r1,#1
000184  4081              LSLS     r1,r1,r0
000186  4aab              LDR      r2,|L1.1076|
000188  6011              STR      r1,[r2,#0]
00018a  bf00              NOP      
;;;254    	/* Initialize clock and I/O pins for USB. */
;;;255    	NDrv_USB_IOClkConfig();
00018c  f7fffffe          BL       NDrv_USB_IOClkConfig
;;;256    
;;;257    #if LPM_SUPPORT
;;;258    	/* Link Power Management is supported. */
;;;259    	LPC_USB->DEVCMDSTAT |= USB_LPM;
;;;260    	LPC_USB->LPM |= (0x2 << 4);		/* RESUME duration. */
;;;261    #endif
;;;262    
;;;263    #if USB_FIQ_EVENT
;;;264    	/* At present, only FRAME(ISO) is routed to FIQ. */
;;;265    	LPC_USB->IntRouting = FRAME_INT;		/* SOF uses FIQ */
;;;266    
;;;267    	/* Enable the USB FIQ Interrupt */
;;;268    	NVIC_EnableIRQ(USB_FIQn);
;;;269    #endif
;;;270    
;;;271    #if USE_DOUBLE_BUFFER
;;;272    	LPC_USB->EPBUFCFG = 0x3FC;
;;;273    #endif
;;;274    	/* Enable the USB Interrupt */
;;;275    	NVIC_EnableIRQ(USB_IRQn);
000190  2016              MOVS     r0,#0x16
000192  2101              MOVS     r1,#1
000194  4081              LSLS     r1,r1,r0
000196  4aa7              LDR      r2,|L1.1076|
000198  3a80              SUBS     r2,r2,#0x80
00019a  6011              STR      r1,[r2,#0]
00019c  bf00              NOP      
;;;276    
;;;277    	NDrv_USB_Reset();
00019e  f7fffffe          BL       NDrv_USB_Reset
;;;278    	NDrv_USB_Connect(TRUE);/* USB Connect */
0001a2  2001              MOVS     r0,#1
0001a4  f7fffffe          BL       NDrv_USB_Connect
;;;279    }
0001a8  bd00              POP      {pc}
;;;280    
                          ENDP

                  USB_Suspend PROC
;;;329    
;;;330    void USB_Suspend (void) {
0001aa  4770              BX       lr
;;;331      /* Performed by Hardware */
;;;332    #if POWERDOWN_MODE_USB_WAKEUP
;;;333      timer16_0_counter = 0;
;;;334      NDrv_Timer16_Enable( 0 );
;;;335    
;;;336      if ( SuspendFlag == 0 ) {
;;;337    	SuspendFlag = 1;
;;;338      }
;;;339    #endif
;;;340    }
;;;341    
                          ENDP

                  USB_Resume PROC
;;;349    
;;;350    void USB_Resume (void) {
0001ac  4770              BX       lr
;;;351      /* Performed by Hardware */
;;;352    #if POWERDOWN_MODE_USB_WAKEUP
;;;353      NDrv_Timer16_Disable( 0 );
;;;354      timer16_0_counter = 0;
;;;355      if ( SuspendFlag == 1 ) {
;;;356    	SuspendFlag = 0;
;;;357      }
;;;358    #endif
;;;359    }
;;;360    
                          ENDP

                  USB_WakeUp PROC
;;;368    
;;;369    void USB_WakeUp (void) {
0001ae  48a2              LDR      r0,|L1.1080|
;;;370    
;;;371      if (g_USBCore_Setting.USB_DeviceStatus & USB_GETSTATUS_REMOTE_WAKEUP) {
0001b0  8800              LDRH     r0,[r0,#0]  ; g_USBCore_Setting
0001b2  2102              MOVS     r1,#2
0001b4  4008              ANDS     r0,r0,r1
0001b6  2800              CMP      r0,#0
0001b8  d005              BEQ      |L1.454|
;;;372    	LPC_USB->DEVCMDSTAT &= ~USB_DSUS;
0001ba  4898              LDR      r0,|L1.1052|
0001bc  6800              LDR      r0,[r0,#0]
0001be  0409              LSLS     r1,r1,#16
0001c0  4388              BICS     r0,r0,r1
0001c2  4996              LDR      r1,|L1.1052|
0001c4  6008              STR      r0,[r1,#0]
                  |L1.454|
;;;373      }
;;;374    }
0001c6  4770              BX       lr
;;;375    
                          ENDP

                  NDrv_USB_WakeUpCfg PROC
;;;382    
;;;383    void NDrv_USB_WakeUpCfg(U8 cfg)
0001c8  bf00              NOP      
;;;384    {
;;;385    #if REMOTE_WAKEUP_ENABLE
;;;386    	if(cfg == TRUE)
;;;387    	{
;;;388    		LPC_USB->DEVCMDSTAT &= ~USB_PLL_ON;/* NeedClk functional */
;;;389    		LPC_SYSCON->USBCLKCTRL = 1;
;;;390    	}
;;;391    	else
;;;392    	{
;;;393    		LPC_USB->DEVCMDSTAT |= USB_PLL_ON;/* NeedClk always "1" */
;;;394    		LPC_SYSCON->USBCLKCTRL = 0;
;;;395    	}
;;;396    #else
;;;397    	cfg = cfg;  /* Not needed */
;;;398    #endif
;;;399    }
0001ca  4770              BX       lr
;;;400    
                          ENDP

                  nsAPI_USB_SetAddress PROC
;;;407    
;;;408    void nsAPI_USB_SetAddress(U32 adr)
0001cc  4993              LDR      r1,|L1.1052|
;;;409    {
;;;410    	LPC_USB->DEVCMDSTAT &= ~0x7F;
0001ce  6809              LDR      r1,[r1,#0]
0001d0  09c9              LSRS     r1,r1,#7
0001d2  01c9              LSLS     r1,r1,#7
0001d4  4a91              LDR      r2,|L1.1052|
0001d6  6011              STR      r1,[r2,#0]
;;;411    	LPC_USB->DEVCMDSTAT |= (USB_EN | adr);
0001d8  4611              MOV      r1,r2
0001da  6809              LDR      r1,[r1,#0]
0001dc  2280              MOVS     r2,#0x80
0001de  4302              ORRS     r2,r2,r0
0001e0  4311              ORRS     r1,r1,r2
0001e2  4a8e              LDR      r2,|L1.1052|
0001e4  6011              STR      r1,[r2,#0]
;;;412    }
0001e6  4770              BX       lr
;;;413    
                          ENDP

                  NDrv_USB_Configure PROC
;;;420    
;;;421    void NDrv_USB_Configure(U8 cfg)
0001e8  2800              CMP      r0,#0
;;;422    {
;;;423    	if(cfg)
0001ea  d003              BEQ      |L1.500|
;;;424    	{
;;;425    		/* All the non-zero EPs are configured and enabled per configuration
;;;426    		descriptor. Enable all interrupts. */
;;;427    		LPC_USB->INTEN  = DEV_STAT_INT | 0x3FF | (USB_SOF_EVENT ? FRAME_INT : 0);
0001ec  4990              LDR      r1,|L1.1072|
0001ee  4a8b              LDR      r2,|L1.1052|
0001f0  6251              STR      r1,[r2,#0x24]
0001f2  e002              B        |L1.506|
                  |L1.500|
;;;428    	}
;;;429    	else
;;;430    	{
;;;431    		/* TBD. if the configuration is FALSE, turn off all the non-zero EPs. Only
;;;432    		CTRL EP interrupts are enabled. */
;;;433    		LPC_USB->INTEN  = DEV_STAT_INT | 0x03 | (USB_SOF_EVENT ? FRAME_INT : 0);
0001f4  4991              LDR      r1,|L1.1084|
0001f6  4a89              LDR      r2,|L1.1052|
0001f8  6251              STR      r1,[r2,#0x24]
                  |L1.506|
;;;434    	}
;;;435    }
0001fa  4770              BX       lr
;;;436    
                          ENDP

                  nsAPI_USB_DeactivateEP PROC
;;;471    
;;;472    void nsAPI_USB_DeactivateEP(U32 EPNum)
0001fc  b570              PUSH     {r4-r6,lr}
;;;473    {
0001fe  4605              MOV      r5,r0
;;;474    	U32 epbit;
;;;475    
;;;476    	epbit = 0x1U << EPAdr(EPNum);
000200  4628              MOV      r0,r5
000202  f7fffffe          BL       EPAdr
000206  2101              MOVS     r1,#1
000208  4081              LSLS     r1,r1,r0
00020a  460c              MOV      r4,r1
;;;477    	LPC_USB->EPSKIP |= epbit;
00020c  4883              LDR      r0,|L1.1052|
00020e  6940              LDR      r0,[r0,#0x14]
000210  4320              ORRS     r0,r0,r4
000212  4982              LDR      r1,|L1.1052|
000214  6148              STR      r0,[r1,#0x14]
;;;478    
;;;479    	while(LPC_USB->EPSKIP & epbit){}
000216  bf00              NOP      
                  |L1.536|
000218  4880              LDR      r0,|L1.1052|
00021a  6940              LDR      r0,[r0,#0x14]
00021c  4020              ANDS     r0,r0,r4
00021e  2800              CMP      r0,#0
000220  d1fa              BNE      |L1.536|
;;;480    
;;;481    	LPC_USB->INTSTAT = epbit;/* Clear EP interrupt(s). */
000222  487e              LDR      r0,|L1.1052|
000224  6204              STR      r4,[r0,#0x20]
;;;482    }
000226  bd70              POP      {r4-r6,pc}
;;;483    
                          ENDP

                  nsAPI_USB_EnableEP PROC
;;;491    
;;;492    void nsAPI_USB_EnableEP(U32 EPNum)
000228  b570              PUSH     {r4-r6,lr}
;;;493    {
00022a  4605              MOV      r5,r0
;;;494    	U32 *addr;
;;;495    
;;;496    	addr = (U32 *)USB_GetEPCmdStatusPtr(EPNum);
00022c  4628              MOV      r0,r5
00022e  f7fffffe          BL       USB_GetEPCmdStatusPtr
000232  4604              MOV      r4,r0
;;;497    	*addr &= ~EP_DISABLED;
000234  2101              MOVS     r1,#1
000236  0789              LSLS     r1,r1,#30
000238  6820              LDR      r0,[r4,#0]
00023a  4388              BICS     r0,r0,r1
00023c  6020              STR      r0,[r4,#0]
;;;498    
;;;499    	if(EPNum & 0x0F)/* Non-zero EPs */
00023e  0728              LSLS     r0,r5,#28
000240  0f00              LSRS     r0,r0,#28
000242  2800              CMP      r0,#0
000244  d02f              BEQ      |L1.678|
;;;500    	{
;;;501    		if(EPNum & 0x80)/* For non-zero IN */
000246  2080              MOVS     r0,#0x80
000248  4028              ANDS     r0,r0,r5
00024a  2800              CMP      r0,#0
00024c  d011              BEQ      |L1.626|
;;;502    		{
;;;503    			if( LPC_USB->EPBUFCFG & (0x1U << EPAdr(EPNum)))
00024e  4628              MOV      r0,r5
000250  f7fffffe          BL       EPAdr
000254  4601              MOV      r1,r0
000256  2001              MOVS     r0,#1
000258  4088              LSLS     r0,r0,r1
00025a  4970              LDR      r1,|L1.1052|
00025c  69c9              LDR      r1,[r1,#0x1c]
00025e  4008              ANDS     r0,r0,r1
000260  2800              CMP      r0,#0
000262  d020              BEQ      |L1.678|
;;;504    			{
;;;505    				/* For non-zero double buffer EPs, clear EP_DISABLED to both buffer. */
;;;506    				addr++;
000264  1d24              ADDS     r4,r4,#4
;;;507    				*addr &= ~EP_DISABLED;
000266  2101              MOVS     r1,#1
000268  0789              LSLS     r1,r1,#30
00026a  6820              LDR      r0,[r4,#0]
00026c  4388              BICS     r0,r0,r1
00026e  6020              STR      r0,[r4,#0]
000270  e019              B        |L1.678|
                  |L1.626|
;;;508    			}
;;;509    		}
;;;510    		else
;;;511    		{
;;;512    			/* For non-zero EP OUT, in addition to clear EP_DISABLED bits,
;;;513    			set the ACTIVE bit indicating that EP is ready to read. For
;;;514    			double buffered EPs, set ACTIVE bit and clear EP_DISABLED bit
;;;515    			for both buffer0 and 1. */
;;;516    			*addr |= BUF_ACTIVE;
000272  2101              MOVS     r1,#1
000274  07c9              LSLS     r1,r1,#31
000276  6820              LDR      r0,[r4,#0]
000278  4308              ORRS     r0,r0,r1
00027a  6020              STR      r0,[r4,#0]
;;;517    
;;;518    			if( LPC_USB->EPBUFCFG & (0x1U << EPAdr(EPNum)) )
00027c  4628              MOV      r0,r5
00027e  f7fffffe          BL       EPAdr
000282  4601              MOV      r1,r0
000284  2001              MOVS     r0,#1
000286  4088              LSLS     r0,r0,r1
000288  4964              LDR      r1,|L1.1052|
00028a  69c9              LDR      r1,[r1,#0x1c]
00028c  4008              ANDS     r0,r0,r1
00028e  2800              CMP      r0,#0
000290  d009              BEQ      |L1.678|
;;;519    			{
;;;520    				/* For double buffer. */
;;;521    				addr++;
000292  1d24              ADDS     r4,r4,#4
;;;522    				*addr &= ~EP_DISABLED;
000294  2101              MOVS     r1,#1
000296  0789              LSLS     r1,r1,#30
000298  6820              LDR      r0,[r4,#0]
00029a  4388              BICS     r0,r0,r1
00029c  6020              STR      r0,[r4,#0]
;;;523    				*addr |= BUF_ACTIVE;
00029e  0049              LSLS     r1,r1,#1
0002a0  6820              LDR      r0,[r4,#0]
0002a2  4308              ORRS     r0,r0,r1
0002a4  6020              STR      r0,[r4,#0]
                  |L1.678|
;;;524    			}
;;;525    		}
;;;526    	}
;;;527    }
0002a6  bd70              POP      {r4-r6,pc}
;;;528    
                          ENDP

                  nsAPI_USB_DisableEP PROC
;;;537    
;;;538    void nsAPI_USB_DisableEP(U32 EPNum)
0002a8  b570              PUSH     {r4-r6,lr}
;;;539    {
0002aa  4605              MOV      r5,r0
;;;540    	U32 *addr;
;;;541    
;;;542    	addr = (U32 *)USB_GetEPCmdStatusPtr(EPNum);
0002ac  4628              MOV      r0,r5
0002ae  f7fffffe          BL       USB_GetEPCmdStatusPtr
0002b2  4604              MOV      r4,r0
;;;543    
;;;544    	if(EPNum & 0x0F)	/* Non-zero EPs only, EP0 should never be disabled. */
0002b4  0728              LSLS     r0,r5,#28
0002b6  0f00              LSRS     r0,r0,#28
0002b8  2800              CMP      r0,#0
0002ba  d015              BEQ      |L1.744|
;;;545    	{
;;;546    		*addr |= EP_DISABLED;
0002bc  2101              MOVS     r1,#1
0002be  0789              LSLS     r1,r1,#30
0002c0  6820              LDR      r0,[r4,#0]
0002c2  4308              ORRS     r0,r0,r1
0002c4  6020              STR      r0,[r4,#0]
;;;547    		/* For non-zero EPs, if double buffer is used, disable both EP buffers. */
;;;548    		if(LPC_USB->EPBUFCFG & (0x1U << EPAdr(EPNum)))
0002c6  4628              MOV      r0,r5
0002c8  f7fffffe          BL       EPAdr
0002cc  4601              MOV      r1,r0
0002ce  2001              MOVS     r0,#1
0002d0  4088              LSLS     r0,r0,r1
0002d2  4952              LDR      r1,|L1.1052|
0002d4  69c9              LDR      r1,[r1,#0x1c]
0002d6  4008              ANDS     r0,r0,r1
0002d8  2800              CMP      r0,#0
0002da  d005              BEQ      |L1.744|
;;;549    		{
;;;550    			addr++;
0002dc  1d24              ADDS     r4,r4,#4
;;;551    			*addr |= EP_DISABLED;
0002de  2101              MOVS     r1,#1
0002e0  0789              LSLS     r1,r1,#30
0002e2  6820              LDR      r0,[r4,#0]
0002e4  4308              ORRS     r0,r0,r1
0002e6  6020              STR      r0,[r4,#0]
                  |L1.744|
;;;552    		}
;;;553    	}
;;;554    }
0002e8  bd70              POP      {r4-r6,pc}
;;;555    
                          ENDP

                  nsAPI_USB_ResetEP PROC
;;;564    
;;;565    void nsAPI_USB_ResetEP(U32 EPNum)
0002ea  b570              PUSH     {r4-r6,lr}
;;;566    {
0002ec  4605              MOV      r5,r0
;;;567    	U32 *addr;
;;;568    
;;;569    	addr = (U32 *)USB_GetEPCmdStatusPtr( EPNum );
0002ee  4628              MOV      r0,r5
0002f0  f7fffffe          BL       USB_GetEPCmdStatusPtr
0002f4  4604              MOV      r4,r0
;;;570    	/* Based on EPInUse register to decide which buffer needs to toggle
;;;571    	reset. When this happens, the STALL bits need to be cleared for both
;;;572    	buffer 0 and 1. */
;;;573    	*addr &= ~EP_STALL;
0002f6  2101              MOVS     r1,#1
0002f8  0749              LSLS     r1,r1,#29
0002fa  6820              LDR      r0,[r4,#0]
0002fc  4388              BICS     r0,r0,r1
0002fe  6020              STR      r0,[r4,#0]
;;;574    	*(addr+2) &= ~EP_STALL;
000300  68a0              LDR      r0,[r4,#8]
000302  4388              BICS     r0,r0,r1
000304  60a0              STR      r0,[r4,#8]
;;;575    
;;;576    	if(LPC_USB->EPINUSE & (0x1U << EPAdr(EPNum)) )
000306  4628              MOV      r0,r5
000308  f7fffffe          BL       EPAdr
00030c  4601              MOV      r1,r0
00030e  2001              MOVS     r0,#1
000310  4088              LSLS     r0,r0,r1
000312  4942              LDR      r1,|L1.1052|
000314  6989              LDR      r1,[r1,#0x18]
000316  4008              ANDS     r0,r0,r1
000318  2800              CMP      r0,#0
00031a  d000              BEQ      |L1.798|
;;;577    	{
;;;578    	addr++;
00031c  1d24              ADDS     r4,r4,#4
                  |L1.798|
;;;579    	}
;;;580    	*addr |= EP_RESET;
00031e  2101              MOVS     r1,#1
000320  0709              LSLS     r1,r1,#28
000322  6820              LDR      r0,[r4,#0]
000324  4308              ORRS     r0,r0,r1
000326  6020              STR      r0,[r4,#0]
;;;581    }
000328  bd70              POP      {r4-r6,pc}
;;;582    
                          ENDP

                  nsAPI_USB_SetStallEP PROC
;;;592    
;;;593    void nsAPI_USB_SetStallEP(U32 EPNum)
00032a  b570              PUSH     {r4-r6,lr}
;;;594    {
00032c  4605              MOV      r5,r0
;;;595    	U32 *addr;
;;;596    
;;;597    	if((EPNum & 0x0F) == 0)
00032e  0728              LSLS     r0,r5,#28
000330  0f00              LSRS     r0,r0,#28
000332  2800              CMP      r0,#0
000334  d112              BNE      |L1.860|
;;;598    	{
;;;599    		/* For EP0 IN or OUT, simply clear the ACTIVE and set the STALL bit. */
;;;600    		addr = (U32 *)USB_GetEPCmdStatusPtr(EPNum);
000336  4628              MOV      r0,r5
000338  f7fffffe          BL       USB_GetEPCmdStatusPtr
00033c  4604              MOV      r4,r0
;;;601    		/* STALL bit can't be set until ACTIVE bit is gone. For EP0,
;;;602    		SKIP register won't do. Force ACTIVE bit to low if it's set. */
;;;603    		if(*addr & BUF_ACTIVE)
00033e  6820              LDR      r0,[r4,#0]
000340  0fc0              LSRS     r0,r0,#31
000342  07c0              LSLS     r0,r0,#31
000344  2800              CMP      r0,#0
000346  d003              BEQ      |L1.848|
;;;604    		{
;;;605    			*addr &= ~BUF_ACTIVE;
000348  6820              LDR      r0,[r4,#0]
00034a  0040              LSLS     r0,r0,#1
00034c  0840              LSRS     r0,r0,#1
00034e  6020              STR      r0,[r4,#0]
                  |L1.848|
;;;606    		}
;;;607    		*addr |= EP_STALL;
000350  2101              MOVS     r1,#1
000352  0749              LSLS     r1,r1,#29
000354  6820              LDR      r0,[r4,#0]
000356  4308              ORRS     r0,r0,r1
000358  6020              STR      r0,[r4,#0]
00035a  e02e              B        |L1.954|
                  |L1.860|
;;;608    	}
;;;609    	else
;;;610    	{
;;;611    		/* For non-zero EPs, deactivate the EP first, clear the ACTIVE bit
;;;612    		before setting the STALL bit. It applies to both buffer 0 and 1 if
;;;613    		double buffer is enabled. */
;;;614    		nsAPI_USB_DeactivateEP(EPNum);
00035c  4628              MOV      r0,r5
00035e  f7fffffe          BL       nsAPI_USB_DeactivateEP
;;;615    		addr = (U32 *)USB_GetEPCmdStatusPtr(EPNum);
000362  4628              MOV      r0,r5
000364  f7fffffe          BL       USB_GetEPCmdStatusPtr
000368  4604              MOV      r4,r0
;;;616    
;;;617    		if(*addr & BUF_ACTIVE)
00036a  6820              LDR      r0,[r4,#0]
00036c  0fc0              LSRS     r0,r0,#31
00036e  07c0              LSLS     r0,r0,#31
000370  2800              CMP      r0,#0
000372  d003              BEQ      |L1.892|
;;;618    		{
;;;619    			*addr &= ~BUF_ACTIVE;
000374  6820              LDR      r0,[r4,#0]
000376  0040              LSLS     r0,r0,#1
000378  0840              LSRS     r0,r0,#1
00037a  6020              STR      r0,[r4,#0]
                  |L1.892|
;;;620    		}
;;;621    
;;;622    		*addr |= EP_STALL;/* STALL on buffer 0. */
00037c  2101              MOVS     r1,#1
00037e  0749              LSLS     r1,r1,#29
000380  6820              LDR      r0,[r4,#0]
000382  4308              ORRS     r0,r0,r1
000384  6020              STR      r0,[r4,#0]
;;;623    
;;;624    		if(LPC_USB->EPBUFCFG & (0x1U << EPAdr(EPNum)))
000386  4628              MOV      r0,r5
000388  f7fffffe          BL       EPAdr
00038c  4601              MOV      r1,r0
00038e  2001              MOVS     r0,#1
000390  4088              LSLS     r0,r0,r1
000392  4922              LDR      r1,|L1.1052|
000394  69c9              LDR      r1,[r1,#0x1c]
000396  4008              ANDS     r0,r0,r1
000398  2800              CMP      r0,#0
00039a  d00e              BEQ      |L1.954|
;;;625    		{
;;;626    			/* If double buffer is enabled, STALL on buffer 1. */
;;;627    			addr++;
00039c  1d24              ADDS     r4,r4,#4
;;;628    			if(*addr & BUF_ACTIVE)
00039e  6820              LDR      r0,[r4,#0]
0003a0  0fc0              LSRS     r0,r0,#31
0003a2  07c0              LSLS     r0,r0,#31
0003a4  2800              CMP      r0,#0
0003a6  d003              BEQ      |L1.944|
;;;629    			{
;;;630    				*addr &= ~BUF_ACTIVE;
0003a8  6820              LDR      r0,[r4,#0]
0003aa  0040              LSLS     r0,r0,#1
0003ac  0840              LSRS     r0,r0,#1
0003ae  6020              STR      r0,[r4,#0]
                  |L1.944|
;;;631    			}
;;;632    			*addr |= EP_STALL;
0003b0  2101              MOVS     r1,#1
0003b2  0749              LSLS     r1,r1,#29
0003b4  6820              LDR      r0,[r4,#0]
0003b6  4308              ORRS     r0,r0,r1
0003b8  6020              STR      r0,[r4,#0]
                  |L1.954|
;;;633    		}
;;;634    	}
;;;635    }
0003ba  bd70              POP      {r4-r6,pc}
;;;636    
                          ENDP

                  nsAPI_USB_ClrStallEP PROC
;;;652    
;;;653    void nsAPI_USB_ClrStallEP(U32 EPNum)
0003bc  b570              PUSH     {r4-r6,lr}
;;;654    {
0003be  4605              MOV      r5,r0
;;;655    	U32 *addr,index;
;;;656    	index = EPAdr(EPNum);
0003c0  4628              MOV      r0,r5
0003c2  f7fffffe          BL       EPAdr
0003c6  4606              MOV      r6,r0
;;;657    
;;;658    	if((EPNum & 0x0F) == 0)
0003c8  0728              LSLS     r0,r5,#28
0003ca  0f00              LSRS     r0,r0,#28
0003cc  2800              CMP      r0,#0
0003ce  d109              BNE      |L1.996|
;;;659    	{
;;;660    		/* For EP0 IN and OUT, simply clear the STALL bit. */
;;;661    		addr = (U32 *)USB_GetEPCmdStatusPtr(EPNum);
0003d0  4628              MOV      r0,r5
0003d2  f7fffffe          BL       USB_GetEPCmdStatusPtr
0003d6  4604              MOV      r4,r0
;;;662    		*addr &= ~EP_STALL;
0003d8  2101              MOVS     r1,#1
0003da  0749              LSLS     r1,r1,#29
0003dc  6820              LDR      r0,[r4,#0]
0003de  4388              BICS     r0,r0,r1
0003e0  6020              STR      r0,[r4,#0]
0003e2  e053              B        |L1.1164|
                  |L1.996|
;;;663    	}
;;;664    	else
;;;665    	{
;;;666    		addr = (U32 *)USB_GetEPCmdStatusPtr(EPNum);
0003e4  4628              MOV      r0,r5
0003e6  f7fffffe          BL       USB_GetEPCmdStatusPtr
0003ea  4604              MOV      r4,r0
;;;667    		/* For non-zero EPs if double buffer, both STALL bits should be cleared. */
;;;668    		*addr &= ~EP_STALL;
0003ec  2101              MOVS     r1,#1
0003ee  0749              LSLS     r1,r1,#29
0003f0  6820              LDR      r0,[r4,#0]
0003f2  4388              BICS     r0,r0,r1
0003f4  6020              STR      r0,[r4,#0]
;;;669    		*(addr+1) &= ~EP_STALL;
0003f6  6860              LDR      r0,[r4,#4]
0003f8  4388              BICS     r0,r0,r1
0003fa  6060              STR      r0,[r4,#4]
;;;670    
;;;671    		/* Based on EPInUse register to decide which buffer needs to toggle reset. */
;;;672    		if(LPC_USB->EPINUSE & (0x1U << index))
0003fc  4807              LDR      r0,|L1.1052|
0003fe  6980              LDR      r0,[r0,#0x18]
000400  2101              MOVS     r1,#1
000402  40b1              LSLS     r1,r1,r6
000404  4008              ANDS     r0,r0,r1
000406  2800              CMP      r0,#0
000408  d01b              BEQ      |L1.1090|
;;;673    		{
;;;674    			/* Buffer 1 is in use. Toggle Reset Buffer 1, otherwise, toggle Reset
;;;675    			buffer 0. */
;;;676    			addr++;
00040a  e019              B        |L1.1088|
                  |L1.1036|
                          DCD      0x40048080
                  |L1.1040|
                          DCD      0x08004000
                  |L1.1044|
                          DCD      0x40044000
                  |L1.1048|
                          DCD      0x10001800
                  |L1.1052|
                          DCD      0x40080000
                  |L1.1056|
                          DCD      0x10001900
                  |L1.1060|
                          DCD      g_USBHW_Setting+0x8
                  |L1.1064|
                          DCD      0x40400000
                  |L1.1068|
                          DCD      0xc00003ff
                  |L1.1072|
                          DCD      0x800003ff
                  |L1.1076|
                          DCD      0xe000e180
                  |L1.1080|
                          DCD      g_USBCore_Setting
                  |L1.1084|
                          DCD      0x80000003
                  |L1.1088|
000440  1d24              ADDS     r4,r4,#4
                  |L1.1090|
;;;677    		}
;;;678    
;;;679    		*addr |= EP_RESET;
000442  2101              MOVS     r1,#1
000444  0709              LSLS     r1,r1,#28
000446  6820              LDR      r0,[r4,#0]
000448  4308              ORRS     r0,r0,r1
00044a  6020              STR      r0,[r4,#0]
;;;680    		if(!(EPNum & 0x80))
00044c  2080              MOVS     r0,#0x80
00044e  4028              ANDS     r0,r0,r5
000450  2800              CMP      r0,#0
000452  d108              BNE      |L1.1126|
;;;681    		{
;;;682    			/* For non-zero EP OUT, ACTIVE bit and length field need to
;;;683    			be set again after clearing STALL. */
;;;684    			*addr &= ~(PKT_LNGTH_MASK << 16);
000454  49f6              LDR      r1,|L1.2096|
000456  6820              LDR      r0,[r4,#0]
000458  4008              ANDS     r0,r0,r1
00045a  6020              STR      r0,[r4,#0]
;;;685    #if USB_ISO_COMMUNICATION
;;;686    			*addr |= ((USB_MAX_ISO_SIZE << 16) | BUF_ACTIVE);
;;;687    #else
;;;688    			*addr |= ((USB_MAX_NON_ISO_SIZE << 16) | BUF_ACTIVE);
00045c  49f5              LDR      r1,|L1.2100|
00045e  6820              LDR      r0,[r4,#0]
000460  4308              ORRS     r0,r0,r1
000462  6020              STR      r0,[r4,#0]
000464  e012              B        |L1.1164|
                  |L1.1126|
;;;689    #endif
;;;690    		}
;;;691    		else
;;;692    		{
;;;693    			/* For non-zero EP IN, the EPActiveFlag will be set when WriteEP() happens
;;;694    			while STALL is set. If so, when ClearSTALL happens, set the ACTIVE bit that
;;;695    			data buffer is ready to write data to the EPs. */
;;;696    			if(g_USBHW_Setting.EPActiveFlag & (0x1U << index))
000466  48f4              LDR      r0,|L1.2104|
000468  6840              LDR      r0,[r0,#4]  ; g_USBHW_Setting
00046a  2101              MOVS     r1,#1
00046c  40b1              LSLS     r1,r1,r6
00046e  4008              ANDS     r0,r0,r1
000470  2800              CMP      r0,#0
000472  d00b              BEQ      |L1.1164|
;;;697    			{
;;;698    				*addr |= BUF_ACTIVE;
000474  2101              MOVS     r1,#1
000476  07c9              LSLS     r1,r1,#31
000478  6820              LDR      r0,[r4,#0]
00047a  4308              ORRS     r0,r0,r1
00047c  6020              STR      r0,[r4,#0]
;;;699    				g_USBHW_Setting.EPActiveFlag &= ~(0x1U << index);
00047e  48ee              LDR      r0,|L1.2104|
000480  6840              LDR      r0,[r0,#4]  ; g_USBHW_Setting
000482  2101              MOVS     r1,#1
000484  40b1              LSLS     r1,r1,r6
000486  4388              BICS     r0,r0,r1
000488  49eb              LDR      r1,|L1.2104|
00048a  6048              STR      r0,[r1,#4]  ; g_USBHW_Setting
                  |L1.1164|
;;;700    			}
;;;701    		}
;;;702    	}
;;;703    }
00048c  bd70              POP      {r4-r6,pc}
;;;704    
                          ENDP

                  nsAPI_USB_ReadSetupEP PROC
;;;713    
;;;714    void nsAPI_USB_ReadSetupEP(U32 EPNum, U8 *pData)
00048e  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;715    {
000490  b081              SUB      sp,sp,#4
000492  460f              MOV      r7,r1
;;;716    	U32 cnt, n,*addr,*dataptr;
;;;717    
;;;718    
;;;719    	addr = (U32 *)USB_GetEPCmdStatusPtr( EPNum );
000494  9801              LDR      r0,[sp,#4]
000496  f7fffffe          BL       USB_GetEPCmdStatusPtr
00049a  4604              MOV      r4,r0
;;;720    
;;;721    	/* Check/Clear STALL on both EP0 IN and OUT when SETUP is received. */
;;;722    	if((*addr & EP_STALL) || ((*addr+2) & EP_STALL))
00049c  2101              MOVS     r1,#1
00049e  0749              LSLS     r1,r1,#29
0004a0  6820              LDR      r0,[r4,#0]
0004a2  4008              ANDS     r0,r0,r1
0004a4  2800              CMP      r0,#0
0004a6  d104              BNE      |L1.1202|
0004a8  6820              LDR      r0,[r4,#0]
0004aa  1c80              ADDS     r0,r0,#2
0004ac  4008              ANDS     r0,r0,r1
0004ae  2800              CMP      r0,#0
0004b0  d007              BEQ      |L1.1218|
                  |L1.1202|
;;;723    	{
;;;724    		*addr &= ~EP_STALL;
0004b2  2101              MOVS     r1,#1
0004b4  0749              LSLS     r1,r1,#29
0004b6  6820              LDR      r0,[r4,#0]
0004b8  4388              BICS     r0,r0,r1
0004ba  6020              STR      r0,[r4,#0]
;;;725    		*(addr+2) &= ~EP_STALL;
0004bc  68a0              LDR      r0,[r4,#8]
0004be  4388              BICS     r0,r0,r1
0004c0  60a0              STR      r0,[r4,#8]
                  |L1.1218|
;;;726    	}
;;;727    
;;;728    	cnt = USB_SETUP_PACKET_SIZE;
0004c2  2008              MOVS     r0,#8
0004c4  9000              STR      r0,[sp,#0]
;;;729    	dataptr = (U32 *)g_USBHW_Setting.EPList[1].buf_ptr;
0004c6  48dc              LDR      r0,|L1.2104|
0004c8  6906              LDR      r6,[r0,#0x10]
;;;730    
;;;731    	for (n = 0; n < (cnt + 3) / 4; n++)
0004ca  2500              MOVS     r5,#0
0004cc  e006              B        |L1.1244|
                  |L1.1230|
;;;732    	{
;;;733    		*((__packed U32 *)pData) = *((__packed U32 *)dataptr);
0004ce  4639              MOV      r1,r7
0004d0  6830              LDR      r0,[r6,#0]
0004d2  f7fffffe          BL       __aeabi_uwrite4
;;;734    		pData += 4;
0004d6  1d3f              ADDS     r7,r7,#4
;;;735    		dataptr++;
0004d8  1d36              ADDS     r6,r6,#4
0004da  1c6d              ADDS     r5,r5,#1              ;731
                  |L1.1244|
0004dc  9800              LDR      r0,[sp,#0]            ;731
0004de  1cc0              ADDS     r0,r0,#3              ;731
0004e0  0880              LSRS     r0,r0,#2              ;731
0004e2  42a8              CMP      r0,r5                 ;731
0004e4  d8f3              BHI      |L1.1230|
;;;736    	}
;;;737    
;;;738    	addr++;		/* Use EP0 buffer 1 for SETUP packet */
0004e6  1d24              ADDS     r4,r4,#4
;;;739    	/* Fixed Command/Status location(EPList[1] for SETUP. Reset buffer pointer
;;;740    	field, SETUP length is fixed with eight bytes. */
;;;741    	*addr &= ~0x3FFFFFF;
0004e8  6820              LDR      r0,[r4,#0]
0004ea  0e80              LSRS     r0,r0,#26
0004ec  0680              LSLS     r0,r0,#26
0004ee  6020              STR      r0,[r4,#0]
;;;742    	*addr |= (U16)((g_USBHW_Setting.EPList[1].buf_ptr) >> 6);
0004f0  49d1              LDR      r1,|L1.2104|
0004f2  6820              LDR      r0,[r4,#0]
0004f4  6909              LDR      r1,[r1,#0x10]
0004f6  0289              LSLS     r1,r1,#10
0004f8  0c09              LSRS     r1,r1,#16
0004fa  4308              ORRS     r0,r0,r1
0004fc  6020              STR      r0,[r4,#0]
;;;743    
;;;744    	//return (cnt);
;;;745    }
0004fe  bdfe              POP      {r1-r7,pc}
;;;746    
                          ENDP

                  nsAPI_USB_ReadEP PROC
;;;755    
;;;756    RetU32 nsAPI_USB_ReadEP(U32 EPNum, U8 *pData)
000500  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;757    {
000502  b085              SUB      sp,sp,#0x14
000504  4605              MOV      r5,r0
;;;758    	U32 cnt, n,*addr,buf_flag,*dataptr,index[2] = {0};
000506  2000              MOVS     r0,#0
000508  9001              STR      r0,[sp,#4]
00050a  9002              STR      r0,[sp,#8]
;;;759    
;;;760    	addr = (U32 *)USB_GetEPCmdStatusPtr(EPNum);
00050c  4628              MOV      r0,r5
00050e  f7fffffe          BL       USB_GetEPCmdStatusPtr
000512  4604              MOV      r4,r0
;;;761    	index[0] = EPAdr(EPNum);
000514  4628              MOV      r0,r5
000516  f7fffffe          BL       EPAdr
00051a  9001              STR      r0,[sp,#4]
;;;762    	index[1] = EPAdr(EPNum) * 2;/* Double buffer is considered. */
00051c  4628              MOV      r0,r5
00051e  f7fffffe          BL       EPAdr
000522  0040              LSLS     r0,r0,#1
000524  9002              STR      r0,[sp,#8]
;;;763    	if(EPNum & 0x0F)
000526  0728              LSLS     r0,r5,#28
000528  0f00              LSRS     r0,r0,#28
00052a  2800              CMP      r0,#0
00052c  d00d              BEQ      |L1.1354|
;;;764    	{
;;;765    		/* For EP0 IN/OUT, there is no double buffer. For non-zero
;;;766    		EP, double buffer is considered. If BufferUsed bit mask is set,
;;;767    		buffer0 is used, switch to buffer 1, index needs to be changed
;;;768    		accordingly too. */
;;;769    		buf_flag = g_USBHW_Setting.BufferUsed & (0x1U << index[0]);
00052e  48c2              LDR      r0,|L1.2104|
000530  6800              LDR      r0,[r0,#0]  ; g_USBHW_Setting
000532  2101              MOVS     r1,#1
000534  9a01              LDR      r2,[sp,#4]
000536  4091              LSLS     r1,r1,r2
000538  4008              ANDS     r0,r0,r1
00053a  9004              STR      r0,[sp,#0x10]
;;;770    
;;;771    		if(buf_flag != 0)
00053c  9804              LDR      r0,[sp,#0x10]
00053e  2800              CMP      r0,#0
000540  d003              BEQ      |L1.1354|
;;;772    		{
;;;773    			addr++;/* Use buffer 1 */
000542  1d24              ADDS     r4,r4,#4
;;;774    			index[1]++;
000544  9802              LDR      r0,[sp,#8]
000546  1c40              ADDS     r0,r0,#1
000548  9002              STR      r0,[sp,#8]
                  |L1.1354|
;;;775    		}
;;;776    	}
;;;777    
;;;778    	cnt = (*addr >> 16) & PKT_LNGTH_MASK;
00054a  6820              LDR      r0,[r4,#0]
00054c  0180              LSLS     r0,r0,#6
00054e  0d86              LSRS     r6,r0,#22
;;;779    	/* The NBytes field decrements by H/W with the packet byte each time. */
;;;780    	cnt = g_USBHW_Setting.EPList[index[1]].buf_length - cnt;
000550  9802              LDR      r0,[sp,#8]
000552  00c1              LSLS     r1,r0,#3
000554  48b8              LDR      r0,|L1.2104|
000556  3008              ADDS     r0,r0,#8
000558  1808              ADDS     r0,r1,r0
00055a  6840              LDR      r0,[r0,#4]
00055c  1b86              SUBS     r6,r0,r6
;;;781    	dataptr = (uint32_t *)g_USBHW_Setting.EPList[index[1]].buf_ptr;
00055e  9802              LDR      r0,[sp,#8]
000560  00c1              LSLS     r1,r0,#3
000562  48b5              LDR      r0,|L1.2104|
000564  3008              ADDS     r0,r0,#8
000566  5840              LDR      r0,[r0,r1]
000568  9003              STR      r0,[sp,#0xc]
;;;782    	for(n = 0; n < (cnt + 3) / 4; n++)
00056a  2700              MOVS     r7,#0
00056c  e00b              B        |L1.1414|
                  |L1.1390|
;;;783    	{
;;;784    		*((__packed uint32_t *)pData) = *((__packed uint32_t *)dataptr);
00056e  9903              LDR      r1,[sp,#0xc]
000570  6808              LDR      r0,[r1,#0]
000572  9906              LDR      r1,[sp,#0x18]
000574  f7fffffe          BL       __aeabi_uwrite4
;;;785    		pData += 4;
000578  9806              LDR      r0,[sp,#0x18]
00057a  1d00              ADDS     r0,r0,#4
00057c  9006              STR      r0,[sp,#0x18]
;;;786    		dataptr++;
00057e  9803              LDR      r0,[sp,#0xc]
000580  1d00              ADDS     r0,r0,#4
000582  9003              STR      r0,[sp,#0xc]
000584  1c7f              ADDS     r7,r7,#1              ;782
                  |L1.1414|
000586  1cf0              ADDS     r0,r6,#3              ;782
000588  0880              LSRS     r0,r0,#2              ;782
00058a  42b8              CMP      r0,r7                 ;782
00058c  d8ef              BHI      |L1.1390|
;;;787    	}
;;;788    
;;;789    	/* Clear buffer after EP read, reset EP length and buffer pointer field */
;;;790    	*addr &= ~0x3FFFFFF;
00058e  6820              LDR      r0,[r4,#0]
000590  0e80              LSRS     r0,r0,#26
000592  0680              LSLS     r0,r0,#26
000594  6020              STR      r0,[r4,#0]
;;;791    	if((EPNum & 0x0F) == 0)
000596  0728              LSLS     r0,r5,#28
000598  0f00              LSRS     r0,r0,#28
00059a  2800              CMP      r0,#0
00059c  d115              BNE      |L1.1482|
;;;792    	{
;;;793    		/* EP0 is single buffer only. */
;;;794    		*addr |= ((g_USBHW_Setting.EPList[index[1]].buf_length << 16)
00059e  9802              LDR      r0,[sp,#8]
0005a0  00c1              LSLS     r1,r0,#3
0005a2  48a5              LDR      r0,|L1.2104|
0005a4  3008              ADDS     r0,r0,#8
0005a6  1808              ADDS     r0,r1,r0
0005a8  6840              LDR      r0,[r0,#4]
0005aa  0400              LSLS     r0,r0,#16
0005ac  9902              LDR      r1,[sp,#8]
0005ae  00ca              LSLS     r2,r1,#3
0005b0  49a1              LDR      r1,|L1.2104|
0005b2  3108              ADDS     r1,r1,#8
0005b4  5889              LDR      r1,[r1,r2]
0005b6  0289              LSLS     r1,r1,#10
0005b8  0c09              LSRS     r1,r1,#16
0005ba  4308              ORRS     r0,r0,r1
0005bc  2101              MOVS     r1,#1
0005be  07c9              LSLS     r1,r1,#31
0005c0  4308              ORRS     r0,r0,r1
0005c2  6821              LDR      r1,[r4,#0]
0005c4  4308              ORRS     r0,r0,r1
0005c6  6020              STR      r0,[r4,#0]
0005c8  e03c              B        |L1.1604|
                  |L1.1482|
;;;795    		| (uint16_t)((g_USBHW_Setting.EPList[index[1]].buf_ptr) >> 6) | BUF_ACTIVE);
;;;796    	}
;;;797    	else
;;;798    	{
;;;799    		/* Toggle buffer if double buffer is used for non-zero EPs.  */
;;;800    		g_USBHW_Setting.BufferUsed ^= (0x1U << index[0]);
0005ca  489b              LDR      r0,|L1.2104|
0005cc  6800              LDR      r0,[r0,#0]  ; g_USBHW_Setting
0005ce  2101              MOVS     r1,#1
0005d0  9a01              LDR      r2,[sp,#4]
0005d2  4091              LSLS     r1,r1,r2
0005d4  4048              EORS     r0,r0,r1
0005d6  4998              LDR      r1,|L1.2104|
0005d8  6008              STR      r0,[r1,#0]  ; g_USBHW_Setting
;;;801    		g_USBHW_Setting.BufferUsed &= LPC_USB->EPBUFCFG;
0005da  4608              MOV      r0,r1
0005dc  6800              LDR      r0,[r0,#0]  ; g_USBHW_Setting
0005de  4997              LDR      r1,|L1.2108|
0005e0  69c9              LDR      r1,[r1,#0x1c]
0005e2  4008              ANDS     r0,r0,r1
0005e4  4994              LDR      r1,|L1.2104|
0005e6  6008              STR      r0,[r1,#0]  ; g_USBHW_Setting
;;;802    
;;;803    		if(LPC_USB->EPBUFCFG & (0x1U << index[0]))
0005e8  4894              LDR      r0,|L1.2108|
0005ea  69c0              LDR      r0,[r0,#0x1c]
0005ec  2101              MOVS     r1,#1
0005ee  9a01              LDR      r2,[sp,#4]
0005f0  4091              LSLS     r1,r1,r2
0005f2  4008              ANDS     r0,r0,r1
0005f4  2800              CMP      r0,#0
0005f6  d010              BEQ      |L1.1562|
;;;804    		{
;;;805    			if(g_USBHW_Setting.BufferUsed & (0x1U << index[0]))
0005f8  488f              LDR      r0,|L1.2104|
0005fa  6800              LDR      r0,[r0,#0]  ; g_USBHW_Setting
0005fc  2101              MOVS     r1,#1
0005fe  9a01              LDR      r2,[sp,#4]
000600  4091              LSLS     r1,r1,r2
000602  4008              ANDS     r0,r0,r1
000604  2800              CMP      r0,#0
000606  d004              BEQ      |L1.1554|
;;;806    			{
;;;807    				addr++;/* Set buffer 1 ACTIVE */
000608  1d24              ADDS     r4,r4,#4
;;;808    				index[1]++;
00060a  9802              LDR      r0,[sp,#8]
00060c  1c40              ADDS     r0,r0,#1
00060e  9002              STR      r0,[sp,#8]
000610  e003              B        |L1.1562|
                  |L1.1554|
;;;809    			}
;;;810    			else
;;;811    			{
;;;812    				addr--;/* Set buffer 0 ACTIVE */
000612  1f24              SUBS     r4,r4,#4
;;;813    				index[1]--;
000614  9802              LDR      r0,[sp,#8]
000616  1e40              SUBS     r0,r0,#1
000618  9002              STR      r0,[sp,#8]
                  |L1.1562|
;;;814    			}
;;;815    		}
;;;816    		*addr |= ((g_USBHW_Setting.EPList[index[1]].buf_length << 16)
00061a  9802              LDR      r0,[sp,#8]
00061c  00c1              LSLS     r1,r0,#3
00061e  4886              LDR      r0,|L1.2104|
000620  3008              ADDS     r0,r0,#8
000622  1808              ADDS     r0,r1,r0
000624  6840              LDR      r0,[r0,#4]
000626  0400              LSLS     r0,r0,#16
000628  9902              LDR      r1,[sp,#8]
00062a  00ca              LSLS     r2,r1,#3
00062c  4982              LDR      r1,|L1.2104|
00062e  3108              ADDS     r1,r1,#8
000630  5889              LDR      r1,[r1,r2]
000632  0289              LSLS     r1,r1,#10
000634  0c09              LSRS     r1,r1,#16
000636  4308              ORRS     r0,r0,r1
000638  2101              MOVS     r1,#1
00063a  07c9              LSLS     r1,r1,#31
00063c  4308              ORRS     r0,r0,r1
00063e  6821              LDR      r1,[r4,#0]
000640  4308              ORRS     r0,r0,r1
000642  6020              STR      r0,[r4,#0]
                  |L1.1604|
;;;817    		| (U16)((g_USBHW_Setting.EPList[index[1]].buf_ptr) >> 6) | BUF_ACTIVE);
;;;818    	}
;;;819    	return (cnt);
000644  4630              MOV      r0,r6
;;;820    }
000646  b007              ADD      sp,sp,#0x1c
000648  bdf0              POP      {r4-r7,pc}
;;;821    
                          ENDP

                  nsAPI_USB_WriteEP PROC
;;;834    
;;;835    RetU32 nsAPI_USB_WriteEP(U32 EPNum,U8 *pData,U32 cnt)
00064a  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;836    {
00064c  b084              SUB      sp,sp,#0x10
00064e  4606              MOV      r6,r0
000650  4615              MOV      r5,r2
;;;837    	U32 n, index[2],*addr,*dataptr;
;;;838    
;;;839    	addr = (U32*)USB_GetEPCmdStatusPtr( EPNum );
000652  4630              MOV      r0,r6
000654  f7fffffe          BL       USB_GetEPCmdStatusPtr
000658  4604              MOV      r4,r0
;;;840    
;;;841    	index[0] = EPAdr(EPNum);
00065a  4630              MOV      r0,r6
00065c  f7fffffe          BL       EPAdr
000660  9002              STR      r0,[sp,#8]
;;;842    	index[1] = index[0] * 2;/* Double buffer is considered. */
000662  9802              LDR      r0,[sp,#8]
000664  0040              LSLS     r0,r0,#1
000666  9003              STR      r0,[sp,#0xc]
;;;843    
;;;844    	if(!(EPNum & 0x0F))
000668  0730              LSLS     r0,r6,#28
00066a  0f00              LSRS     r0,r0,#28
00066c  2800              CMP      r0,#0
00066e  d10d              BNE      |L1.1676|
;;;845    	{
;;;846    		/* When EP0 IN is received, set ACTIVE bit on both EP0 IN
;;;847    		and OUT. */
;;;848    		*addr &= ~EP_STALL;
000670  2101              MOVS     r1,#1
000672  0749              LSLS     r1,r1,#29
000674  6820              LDR      r0,[r4,#0]
000676  4388              BICS     r0,r0,r1
000678  6020              STR      r0,[r4,#0]
;;;849    		*(addr-2) |= BUF_ACTIVE;	/* Set ACTIVE bit on EP0 OUT */
00067a  4620              MOV      r0,r4
00067c  3880              SUBS     r0,r0,#0x80
00067e  6f80              LDR      r0,[r0,#0x78]
000680  0089              LSLS     r1,r1,#2
000682  4308              ORRS     r0,r0,r1
000684  4621              MOV      r1,r4
000686  3980              SUBS     r1,r1,#0x80
000688  6788              STR      r0,[r1,#0x78]
00068a  e013              B        |L1.1716|
                  |L1.1676|
;;;850    	}
;;;851    	else
;;;852    	{
;;;853    		/* For non-zero EPs, if double buffer is used and EPInUse is set, buffer0
;;;854    		is used, otherwise, buffer1 is used. */
;;;855    		if(LPC_USB->EPBUFCFG & (0x1U << index[0]) )
00068c  486b              LDR      r0,|L1.2108|
00068e  69c0              LDR      r0,[r0,#0x1c]
000690  2101              MOVS     r1,#1
000692  9a02              LDR      r2,[sp,#8]
000694  4091              LSLS     r1,r1,r2
000696  4008              ANDS     r0,r0,r1
000698  2800              CMP      r0,#0
00069a  d00b              BEQ      |L1.1716|
;;;856    		{
;;;857    			if(LPC_USB->EPINUSE & (0x1U << index[0]) )
00069c  4867              LDR      r0,|L1.2108|
00069e  6980              LDR      r0,[r0,#0x18]
0006a0  2101              MOVS     r1,#1
0006a2  9a02              LDR      r2,[sp,#8]
0006a4  4091              LSLS     r1,r1,r2
0006a6  4008              ANDS     r0,r0,r1
0006a8  2800              CMP      r0,#0
0006aa  d003              BEQ      |L1.1716|
;;;858    			{
;;;859    				addr++;/* move to buffer1 address in EP command/status list. */
0006ac  1d24              ADDS     r4,r4,#4
;;;860    				index[1]++;
0006ae  9803              LDR      r0,[sp,#0xc]
0006b0  1c40              ADDS     r0,r0,#1
0006b2  9003              STR      r0,[sp,#0xc]
                  |L1.1716|
;;;861    			}
;;;862    		}
;;;863    	}
;;;864    
;;;865    	/* Get EP command/status List, update the length field and data pointer. */
;;;866    	*addr &= ~0x3FFFFFF;
0006b4  6820              LDR      r0,[r4,#0]
0006b6  0e80              LSRS     r0,r0,#26
0006b8  0680              LSLS     r0,r0,#26
0006ba  6020              STR      r0,[r4,#0]
;;;867    	cnt &= PKT_LNGTH_MASK;
0006bc  05ad              LSLS     r5,r5,#22
0006be  0dad              LSRS     r5,r5,#22
;;;868    	*addr |= (cnt << 16)|(U16)((g_USBHW_Setting.EPList[index[1]].buf_ptr) >> 6);
0006c0  0428              LSLS     r0,r5,#16
0006c2  9903              LDR      r1,[sp,#0xc]
0006c4  00ca              LSLS     r2,r1,#3
0006c6  495c              LDR      r1,|L1.2104|
0006c8  3108              ADDS     r1,r1,#8
0006ca  5889              LDR      r1,[r1,r2]
0006cc  0289              LSLS     r1,r1,#10
0006ce  0c09              LSRS     r1,r1,#16
0006d0  4308              ORRS     r0,r0,r1
0006d2  6821              LDR      r1,[r4,#0]
0006d4  4308              ORRS     r0,r0,r1
0006d6  6020              STR      r0,[r4,#0]
;;;869    
;;;870    	dataptr = (U32 *)g_USBHW_Setting.EPList[index[1]].buf_ptr;
0006d8  9803              LDR      r0,[sp,#0xc]
0006da  00c1              LSLS     r1,r0,#3
0006dc  4856              LDR      r0,|L1.2104|
0006de  3008              ADDS     r0,r0,#8
0006e0  5840              LDR      r0,[r0,r1]
0006e2  9001              STR      r0,[sp,#4]
;;;871    	/* Stuff the data first, whether send out or not(set ACTIVE bit) is based on STALL condition. */
;;;872    	for (n = 0; n < (cnt + 3) / 4; n++)
0006e4  2700              MOVS     r7,#0
0006e6  e00b              B        |L1.1792|
                  |L1.1768|
;;;873    	{
;;;874    		*((__packed U32 *)dataptr) = *((__packed U32 *)pData);
0006e8  9805              LDR      r0,[sp,#0x14]
0006ea  f7fffffe          BL       __aeabi_uread4
0006ee  9901              LDR      r1,[sp,#4]
0006f0  6008              STR      r0,[r1,#0]
;;;875    		pData += 4;
0006f2  9805              LDR      r0,[sp,#0x14]
0006f4  1d00              ADDS     r0,r0,#4
0006f6  9005              STR      r0,[sp,#0x14]
;;;876    		dataptr++;
0006f8  9801              LDR      r0,[sp,#4]
0006fa  1d00              ADDS     r0,r0,#4
0006fc  9001              STR      r0,[sp,#4]
0006fe  1c7f              ADDS     r7,r7,#1              ;872
                  |L1.1792|
000700  1ce8              ADDS     r0,r5,#3              ;872
000702  0880              LSRS     r0,r0,#2              ;872
000704  42b8              CMP      r0,r7                 ;872
000706  d8ef              BHI      |L1.1768|
;;;877    	}
;;;878    
;;;879    	if((*addr & EP_STALL) && (EPNum & 0x0F))
000708  2101              MOVS     r1,#1
00070a  0749              LSLS     r1,r1,#29
00070c  6820              LDR      r0,[r4,#0]
00070e  4008              ANDS     r0,r0,r1
000710  2800              CMP      r0,#0
000712  d00e              BEQ      |L1.1842|
000714  0730              LSLS     r0,r6,#28
000716  0f00              LSRS     r0,r0,#28
000718  2800              CMP      r0,#0
00071a  d00a              BEQ      |L1.1842|
;;;880    	{
;;;881    	 /* This is for MSC class when STALL occurs and non-zero EPs,
;;;882    		set the ACTIVE flag, but don't do anything until ClearFeature
;;;883    		to clear STALL, then tranfer the data. */
;;;884    		g_USBHW_Setting.EPActiveFlag |= (0x1U << index[0]);
00071c  4846              LDR      r0,|L1.2104|
00071e  6840              LDR      r0,[r0,#4]  ; g_USBHW_Setting
000720  2101              MOVS     r1,#1
000722  9a02              LDR      r2,[sp,#8]
000724  4091              LSLS     r1,r1,r2
000726  4308              ORRS     r0,r0,r1
000728  4943              LDR      r1,|L1.2104|
00072a  6048              STR      r0,[r1,#4]  ; g_USBHW_Setting
;;;885    		return (cnt);
00072c  4628              MOV      r0,r5
                  |L1.1838|
;;;886    	}
;;;887    
;;;888    	*addr |= BUF_ACTIVE;
;;;889    	return (cnt);
;;;890    }
00072e  b007              ADD      sp,sp,#0x1c
000730  bdf0              POP      {r4-r7,pc}
                  |L1.1842|
000732  2101              MOVS     r1,#1                 ;888
000734  07c9              LSLS     r1,r1,#31             ;888
000736  6820              LDR      r0,[r4,#0]            ;888
000738  4308              ORRS     r0,r0,r1              ;888
00073a  6020              STR      r0,[r4,#0]            ;888
00073c  4628              MOV      r0,r5                 ;889
00073e  e7f6              B        |L1.1838|
;;;891    
                          ENDP

                  wnDrv_Usb_ClrGetReqStatus PROC
;;;892    void wnDrv_Usb_ClrGetReqStatus(U32 EPNum)
000740  b570              PUSH     {r4-r6,lr}
;;;893    {
000742  4605              MOV      r5,r0
;;;894    	U32 *addr;
;;;895    
;;;896    	addr = (U32*)USB_GetEPCmdStatusPtr(EPNum);
000744  4628              MOV      r0,r5
000746  f7fffffe          BL       USB_GetEPCmdStatusPtr
00074a  4604              MOV      r4,r0
;;;897    
;;;898    	*addr &=~ BUF_ACTIVE;
00074c  6820              LDR      r0,[r4,#0]
00074e  0040              LSLS     r0,r0,#1
000750  0840              LSRS     r0,r0,#1
000752  6020              STR      r0,[r4,#0]
;;;899    }
000754  bd70              POP      {r4-r6,pc}
;;;900    #if USB_FIQ_EVENT
                          ENDP

                  USB_IRQHandler PROC
;;;925    
;;;926    void USB_IRQHandler (void)
000756  b5f8              PUSH     {r3-r7,lr}
;;;927    {
;;;928      uint32_t disr, val, n, m;
;;;929    
;;;930      disr = LPC_USB->INTSTAT;         /* Get Interrupt Status and clear immediately. */
000758  4838              LDR      r0,|L1.2108|
00075a  6a06              LDR      r6,[r0,#0x20]
;;;931      LPC_USB->INTSTAT = disr;
00075c  6206              STR      r6,[r0,#0x20]
;;;932    
;;;933      /* Device Status Interrupt (Reset, Connect change, Suspend/Resume) */
;;;934      if (disr & DEV_STAT_INT) {
00075e  0ff0              LSRS     r0,r6,#31
000760  07c0              LSLS     r0,r0,#31
000762  2800              CMP      r0,#0
000764  d01d              BEQ      |L1.1954|
;;;935        val = LPC_USB->DEVCMDSTAT;       /* Device Status */
000766  4835              LDR      r0,|L1.2108|
000768  6807              LDR      r7,[r0,#0]
;;;936    
;;;937        if (val & USB_DRESET_C) {               /* Reset */
00076a  01c0              LSLS     r0,r0,#7
00076c  4038              ANDS     r0,r0,r7
00076e  2800              CMP      r0,#0
000770  d003              BEQ      |L1.1914|
;;;938          NDrv_USB_Reset();
000772  f7fffffe          BL       NDrv_USB_Reset
;;;939    #if   USB_RESET_EVENT
;;;940          USB_Reset_Event();
000776  f7fffffe          BL       USB_Reset_Event
                  |L1.1914|
;;;941    #endif
;;;942        }
;;;943        if (val & USB_DCON_C) {                 /* Connect change */
;;;944    #if   USB_POWER_EVENT
;;;945          USB_Power_Event(val & DEV_CON);
;;;946    #endif
;;;947        }
;;;948        if (val & USB_DSUS_C) {                 /* Suspend/Resume */
00077a  2001              MOVS     r0,#1
00077c  0640              LSLS     r0,r0,#25
00077e  4038              ANDS     r0,r0,r7
000780  2800              CMP      r0,#0
000782  d00d              BEQ      |L1.1952|
;;;949          if (val & USB_DSUS) {                 /* Suspend */
000784  2001              MOVS     r0,#1
000786  0440              LSLS     r0,r0,#17
000788  4038              ANDS     r0,r0,r7
00078a  2800              CMP      r0,#0
00078c  d004              BEQ      |L1.1944|
;;;950            USB_Suspend();
00078e  f7fffffe          BL       USB_Suspend
;;;951    #if     USB_SUSPEND_EVENT
;;;952            USB_Suspend_Event();
000792  f7fffffe          BL       USB_Suspend_Event
000796  e003              B        |L1.1952|
                  |L1.1944|
;;;953    #endif
;;;954          } else {                              /* Resume */
;;;955            USB_Resume();
000798  f7fffffe          BL       USB_Resume
;;;956    #if REMOTE_WAKEUP_ENABLE
;;;957            LPC_SYSCON->USBCLKCTRL = 0;
;;;958    #endif
;;;959    #if     USB_RESUME_EVENT
;;;960            USB_Resume_Event();
00079c  f7fffffe          BL       USB_Resume_Event
                  |L1.1952|
;;;961    #endif
;;;962          }
;;;963        }
;;;964    #if LPM_SUPPORT
;;;965    	if (val & USB_LPM_SUS) {                /* LPM Suspend */
;;;966          DevStatusLPMSuspend++;
;;;967        }
;;;968    #endif
;;;969        goto isr_end;
0007a0  e045              B        |L1.2094|
                  |L1.1954|
;;;970      }
;;;971    
;;;972    #if USB_SOF_EVENT
;;;973      /* Start of Frame Interrupt */
;;;974      if (disr & FRAME_INT) {
;;;975        USB_SOF_Event();
;;;976    	SOFIRQCount++;
;;;977      }
;;;978    #endif
;;;979    
;;;980    
;;;981      /* Endpoint's Interrupt */
;;;982      if (disr & 0x3FF) {
0007a2  05b0              LSLS     r0,r6,#22
0007a4  0d80              LSRS     r0,r0,#22
0007a6  2800              CMP      r0,#0
0007a8  d040              BEQ      |L1.2092|
;;;983    	/* if any of the EP0 through EP9 is set, or bit 0 through 9 on disr */
;;;984        for (n = 0; n < USB_EP_NUM; n++) {      /* Check All Endpoints */
0007aa  2400              MOVS     r4,#0
0007ac  e03c              B        |L1.2088|
                  |L1.1966|
;;;985    	  if (disr & (1 << n)) {
0007ae  2001              MOVS     r0,#1
0007b0  40a0              LSLS     r0,r0,r4
0007b2  4030              ANDS     r0,r0,r6
0007b4  2800              CMP      r0,#0
0007b6  d035              BEQ      |L1.2084|
;;;986            m = n >> 1;
0007b8  0865              LSRS     r5,r4,#1
;;;987            if ((n & 1) == 0) {                 /* OUT Endpoint */
0007ba  07e0              LSLS     r0,r4,#31
0007bc  0fc0              LSRS     r0,r0,#31
0007be  2800              CMP      r0,#0
0007c0  d123              BNE      |L1.2058|
;;;988              if (n == 0) {                     /* Control OUT Endpoint */
0007c2  2c00              CMP      r4,#0
0007c4  d116              BNE      |L1.2036|
;;;989                if ( LPC_USB->DEVCMDSTAT & USB_SETUP_RCVD ) {
0007c6  481d              LDR      r0,|L1.2108|
0007c8  6800              LDR      r0,[r0,#0]
0007ca  21ff              MOVS     r1,#0xff
0007cc  3101              ADDS     r1,#1
0007ce  4008              ANDS     r0,r0,r1
0007d0  2800              CMP      r0,#0
0007d2  d00f              BEQ      |L1.2036|
;;;990     											/* Setup packet is received. */
;;;991                  if (USB_P_EP[0]) {
0007d4  481a              LDR      r0,|L1.2112|
0007d6  6800              LDR      r0,[r0,#0]  ; USB_P_EP
0007d8  2800              CMP      r0,#0
0007da  d00b              BEQ      |L1.2036|
;;;992                    USB_P_EP[0](USB_EVT_SETUP);
0007dc  4818              LDR      r0,|L1.2112|
0007de  6801              LDR      r1,[r0,#0]  ; USB_P_EP
0007e0  2001              MOVS     r0,#1
0007e2  4788              BLX      r1
;;;993    				LPC_USB->DEVCMDSTAT |= USB_SETUP_RCVD;
0007e4  4815              LDR      r0,|L1.2108|
0007e6  6800              LDR      r0,[r0,#0]
0007e8  21ff              MOVS     r1,#0xff
0007ea  3101              ADDS     r1,#1
0007ec  4308              ORRS     r0,r0,r1
0007ee  4913              LDR      r1,|L1.2108|
0007f0  6008              STR      r0,[r1,#0]
;;;994                    continue;
0007f2  e018              B        |L1.2086|
                  |L1.2036|
;;;995                  }
;;;996                }
;;;997              }
;;;998              if (USB_P_EP[m]) {
0007f4  00a8              LSLS     r0,r5,#2
0007f6  4912              LDR      r1,|L1.2112|
0007f8  5808              LDR      r0,[r1,r0]
0007fa  2800              CMP      r0,#0
0007fc  d012              BEQ      |L1.2084|
;;;999                USB_P_EP[m](USB_EVT_OUT);
0007fe  00a8              LSLS     r0,r5,#2
000800  460a              MOV      r2,r1
000802  5811              LDR      r1,[r2,r0]
000804  2002              MOVS     r0,#2
000806  4788              BLX      r1
000808  e00c              B        |L1.2084|
                  |L1.2058|
;;;1000             }
;;;1001           } else {                            /* IN Endpoint */
;;;1002             if (USB_P_EP[m]) {
00080a  00a8              LSLS     r0,r5,#2
00080c  490c              LDR      r1,|L1.2112|
00080e  5808              LDR      r0,[r1,r0]
000810  2800              CMP      r0,#0
000812  d007              BEQ      |L1.2084|
;;;1003               USB_P_EP[m](USB_EVT_IN);
000814  00a8              LSLS     r0,r5,#2
000816  460a              MOV      r2,r1
000818  5811              LDR      r1,[r2,r0]
00081a  2003              MOVS     r0,#3
00081c  4788              BLX      r1
;;;1004   			if( m == 1)
00081e  2d01              CMP      r5,#1
000820  d100              BNE      |L1.2084|
;;;1005   			{
;;;1006   				m = 1;
000822  bf00              NOP      
                  |L1.2084|
000824  bf00              NOP                            ;994
                  |L1.2086|
000826  1c64              ADDS     r4,r4,#1              ;984
                  |L1.2088|
000828  2c04              CMP      r4,#4                 ;984
00082a  d3c0              BCC      |L1.1966|
                  |L1.2092|
;;;1007   			}
;;;1008             }
;;;1009           }
;;;1010         }
;;;1011       }
;;;1012     }
;;;1013   isr_end:
00082c  bf00              NOP      
                  |L1.2094|
;;;1014     return;
;;;1015   }
00082e  bdf8              POP      {r3-r7,pc}
                  |L1.2096|
                          DCD      0xfc00ffff
                  |L1.2100|
                          DCD      0x80400000
                  |L1.2104|
                          DCD      g_USBHW_Setting
                  |L1.2108|
                          DCD      0x40080000
                  |L1.2112|
                          DCD      USB_P_EP
                          ENDP

                  wnDrv_Usb_EP_Status PROC
;;;1017   
;;;1018   Boolean wnDrv_Usb_EP_Status(U32 EPNum)
000844  b570              PUSH     {r4-r6,lr}
;;;1019   {
000846  4605              MOV      r5,r0
;;;1020       uint32_t *addr;
;;;1021   
;;;1022       addr = (uint32_t *)USB_GetEPCmdStatusPtr( EPNum );
000848  4628              MOV      r0,r5
00084a  f7fffffe          BL       USB_GetEPCmdStatusPtr
00084e  4604              MOV      r4,r0
;;;1023   
;;;1024       /* For non-zero EPs, if double buffer is used and EPInUse is set, buffer0
;;;1025       is used, otherwise, buffer1 is used. */
;;;1026       if(LPC_USB->EPBUFCFG & (0x1U << EPAdr(EPNum)))
000850  4628              MOV      r0,r5
000852  f7fffffe          BL       EPAdr
000856  4601              MOV      r1,r0
000858  2001              MOVS     r0,#1
00085a  4088              LSLS     r0,r0,r1
00085c  490d              LDR      r1,|L1.2196|
00085e  69c9              LDR      r1,[r1,#0x1c]
000860  4008              ANDS     r0,r0,r1
000862  2800              CMP      r0,#0
000864  d00b              BEQ      |L1.2174|
;;;1027       {
;;;1028           if(LPC_USB->EPINUSE & (0x1U << EPAdr(EPNum)))
000866  4628              MOV      r0,r5
000868  f7fffffe          BL       EPAdr
00086c  4601              MOV      r1,r0
00086e  2001              MOVS     r0,#1
000870  4088              LSLS     r0,r0,r1
000872  4908              LDR      r1,|L1.2196|
000874  6989              LDR      r1,[r1,#0x18]
000876  4008              ANDS     r0,r0,r1
000878  2800              CMP      r0,#0
00087a  d000              BEQ      |L1.2174|
;;;1029           {
;;;1030               addr++;/* move to buffer1 address in EP command/status list. */
00087c  1d24              ADDS     r4,r4,#4
                  |L1.2174|
;;;1031           }
;;;1032       }
;;;1033   
;;;1034       /* Get EP command/status List, update the length field and data pointer. */
;;;1035       if((*addr & BUF_ACTIVE) ==  BUF_ACTIVE)
00087e  6820              LDR      r0,[r4,#0]
000880  0fc0              LSRS     r0,r0,#31
000882  07c0              LSLS     r0,r0,#31
000884  2101              MOVS     r1,#1
000886  07c9              LSLS     r1,r1,#31
000888  4288              CMP      r0,r1
00088a  d101              BNE      |L1.2192|
;;;1036       {
;;;1037           return FALSE;
00088c  2000              MOVS     r0,#0
                  |L1.2190|
;;;1038       }
;;;1039       return TRUE;
;;;1040   }
00088e  bd70              POP      {r4-r6,pc}
                  |L1.2192|
000890  2001              MOVS     r0,#1                 ;1039
000892  e7fc              B        |L1.2190|
;;;1041   
                          ENDP

                  |L1.2196|
                          DCD      0x40080000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_USBHW_Setting
                          %        72

;*** Start embedded assembler ***

#line 1 "Src\\usbhw.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_usbhw_c_f2ca8f3d____REV16|
#line 112 ".\\Inc\\core_cmInstr.h"
|__asm___7_usbhw_c_f2ca8f3d____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_usbhw_c_f2ca8f3d____REVSH|
#line 130
|__asm___7_usbhw_c_f2ca8f3d____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
