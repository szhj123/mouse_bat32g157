L 1 "Src\Flash.c"
N
N#define _FLASH_C_ 1
N#include "LPC11Uxx.h"		
L 1 ".\Inc\LPC11Uxx.h" 1
N
N/****************************************************************************************************//**
N * @file     LPC11Uxx.h
N *
N *
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File for
N *           default LPC11Uxx Device Series
N *
N * @version  V0.1
N * @date     21. March 2011
N *
N * @note     Generated with SFDGen V2.6 Build 3j (beta) on Thursday, 17.03.2011 13:19:45
N *
N *           from CMSIS SVD File 'LPC11U1x_svd.xml' Version 0.1,
N *           created on Wednesday, 16.03.2011 20:30:42, last modified on Thursday, 17.03.2011 20:19:40
N *
N *******************************************************************************************************/
N
N
N
N/** @addtogroup NXP
N  * @{
N  */
N
N/** @addtogroup LPC11Uxx
N  * @{
N  */
N
N#ifndef __LPC11UXX_H__
N#define __LPC11UXX_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif 
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #pragma anon_unions
N#endif
N
N /* Interrupt Number Definition */
N
Ntypedef enum {
N// -------------------------  Cortex-M0 Processor Exceptions Numbers  -----------------------------
N  Reset_IRQn                        = -15,  /*!<   1  Reset Vector, invoked on Power up and warm reset */
N  NonMaskableInt_IRQn               = -14,  /*!<   2  Non maskable Interrupt, cannot be stopped or preempted */
N  HardFault_IRQn                    = -13,  /*!<   3  Hard Fault, all classes of Fault */
N  SVCall_IRQn                       = -5,   /*!<  11  System Service Call via SVC instruction */
N  DebugMonitor_IRQn                 = -4,   /*!<  12  Debug Monitor                    */
N  PendSV_IRQn                       = -2,   /*!<  14  Pendable request for system service */
N  SysTick_IRQn                      = -1,   /*!<  15  System Tick Timer                */
N// ---------------------------  LPC11Uxx Specific Interrupt Numbers  ------------------------------
NFLEX_INT0_IRQn                = 0,        /*!< All I/O pins can be routed to below 8 interrupts. */
N  FLEX_INT1_IRQn                = 1,
N  FLEX_INT2_IRQn                = 2,
N  FLEX_INT3_IRQn                = 3,
N  FLEX_INT4_IRQn                = 4,   
N  FLEX_INT5_IRQn                = 5,        
N  FLEX_INT6_IRQn                = 6,        
N  FLEX_INT7_IRQn                = 7,        
N  GINT0_IRQn                    = 8,        /*!< Grouped Interrupt 0                              */
N  GINT1_IRQn                    = 9,        /*!< Grouped Interrupt 1                              */
N  Reserved0_IRQn                = 10,       /*!< Reserved Interrupt                               */
N  Reserved1_IRQn                = 11,       
N  Reserved2_IRQn                = 12,       
N  Reserved3_IRQn                = 13,       
N  SSP1_IRQn                     = 14,       /*!< SSP1 Interrupt                                   */
N  I2C_IRQn                      = 15,       /*!< I2C Interrupt                                    */
N  TIMER_16_0_IRQn               = 16,       /*!< 16-bit Timer0 Interrupt                          */
N  TIMER_16_1_IRQn               = 17,       /*!< 16-bit Timer1 Interrupt                          */
N  TIMER_32_0_IRQn               = 18,       /*!< 32-bit Timer0 Interrupt                          */
N  TIMER_32_1_IRQn               = 19,       /*!< 32-bit Timer1 Interrupt                          */
N  SSP0_IRQn                     = 20,       /*!< SSP0 Interrupt                                   */
N  UART_IRQn                     = 21,       /*!< UART Interrupt                                   */
N  USB_IRQn                      = 22,       /*!< USB IRQ Interrupt                                */
N  USB_FIQn                      = 23,       /*!< USB FIQ Interrupt                                */
N  ADC_IRQn                      = 24,       /*!< A/D Converter Interrupt                          */
N  WDT_IRQn                      = 25,       /*!< Watchdog timer Interrupt                         */  
N  BOD_IRQn                      = 26,       /*!< Brown Out Detect(BOD) Interrupt                  */
N  FMC_IRQn                      = 27,       /*!< Flash Memory Controller Interrupt                */
N  Reserved4_IRQn                = 28,       /*!< Reserved Interrupt                               */
N  Reserved5_IRQn                = 29,       /*!< Reserved Interrupt                               */
N  USBWakeup_IRQn                = 30,       /*!< USB wakeup Interrupt                             */
N  Reserved6_IRQn                = 31,       /*!< Reserved Interrupt                               */
N} IRQn_Type;
N
N
N/** @addtogroup Configuration_of_CMSIS
N  * @{
N  */
N
N/* Processor and Core Peripheral Section */ /* Configuration of the Cortex-M0 Processor and Core Peripherals */
N
N#define __MPU_PRESENT             0         /*!< MPU present or not                    */
N#define __NVIC_PRIO_BITS          3         /*!< Number of Bits used for Priority Levels */
N#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used */
N/** @} */ /* End of group Configuration_of_CMSIS */
N
N#include "core_cm0.h"                       /*!< Cortex-M0 processor and core peripherals */
L 1 ".\Inc\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V2.01
N * @date     06. December 2010
N *
N * @note
N * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )                   
X#if 0L                   
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N
N/** \mainpage CMSIS Cortex-M0
N   
N  This documentation describes the CMSIS Cortex-M Core Peripheral Access Layer.
N  It consists of:
N 
N     - Cortex-M Core Register Definitions
N     - Cortex-M functions
N     - Cortex-M instructions
N 
N  The CMSIS Cortex-M0 Core Peripheral Access Layer contains C and assembly functions that ease 
N  access to the Cortex-M Core
N */ 
N
N/** \defgroup CMSIS_LintCinfiguration CMSIS Lint Configuration
N  List of Lint messages which will be suppressed and not shown:
N    - not yet checked
N  .
N  Note:  To re-enable a Message, insert a space before 'lint' *
N 
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \defgroup CMSIS_core_definitions CMSIS Core Definitions
N  This file defines all structures and symbols for CMSIS core:
N   - CMSIS version number
N   - Cortex-M core 
N   - Cortex-M core Revision Number
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x02)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (0x00)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | __CM0_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x00)                                                       /*!< Cortex core                    */
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S
N#endif
N
N#include <stdint.h>                      /*!< standard types definitions                      */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 95 ".\Inc\core_cm0.h" 2
N#include "core_cmInstr.h"                /*!< Core Instruction Access                         */
L 1 ".\Inc\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V2.01
N * @date     06. December 2010
N *
N * @note
N * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H__
N#define __CORE_CMINSTR_H__
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if defined ( __CC_ARM   ) /*------------------ RealView Compiler ----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor, 
N    so that all instructions following the ISB are fetched from cache or 
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier. 
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before 
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#if (__ARMCC_VERSION < 400677)
X#if (5060960 < 400677)
Sextern uint32_t __REV16(uint32_t value);
N#else  /* (__ARMCC_VERSION >= 400677)  */
Nstatic __INLINE __ASM uint32_t __REV16(uint32_t value)
Xstatic __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif /* __ARMCC_VERSION  */ 
N
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#if (__ARMCC_VERSION < 400677)
X#if (5060960 < 400677)
Sextern int32_t __REVSH(int32_t value);
N#else  /* (__ARMCC_VERSION >= 400677)  */
Nstatic __INLINE __ASM int32_t __REVSH(int32_t value)
Xstatic __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif /* __ARMCC_VERSION  */ 
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#if (__ARMCC_VERSION < 400000)
Sextern void __CLREX(void);
S#else  /* (__ARMCC_VERSION >= 400000)  */
S#define __CLREX                           __clrex
S#endif /* __ARMCC_VERSION  */ 
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz 
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif (defined (__ICCARM__)) /*---------------- ICC Compiler ---------------------*/
S/* IAR iccarm specific functions */
S
S#include <intrinsics.h>                     /* IAR Intrinsics   */
S
S#pragma diag_suppress=Pe940
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S#define __NOP                           __no_operation
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
Sstatic __INLINE  void __WFI(void)
S{
S  __ASM ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
Sstatic __INLINE  void __WFE(void)
S{
S  __ASM ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
Sstatic __INLINE  void __SEV(void)
S{
S  __ASM ("sev");
S}
S
S
S/* intrinsic     void __ISB(void)            (see intrinsics.h) */
S/* intrinsic     void __DSB(void)            (see intrinsics.h) */
S/* intrinsic     void __DMB(void)            (see intrinsics.h) */
S/* intrinsic uint32_t __REV(uint32_t value)  (see intrinsics.h) */
S/* intrinsic          __SSAT                 (see intrinsics.h) */
S/* intrinsic          __USAT                 (see intrinsics.h) */
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
Sstatic uint32_t __REV16(uint32_t value)
S{
S  __ASM("rev16 r0, r0");
S}
S
S
S/* intrinsic uint32_t __REVSH(uint32_t value)  (see intrinsics.h */
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
Sstatic uint32_t __RBIT(uint32_t value)
S{
S  __ASM("rbit r0, r0");
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
Sstatic uint8_t __LDREXB(volatile uint8_t *addr)
S{
S  __ASM("ldrexb r0, [r0]");
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
Sstatic uint16_t __LDREXH(volatile uint16_t *addr)
S{
S  __ASM("ldrexh r0, [r0]");
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S/* intrinsic unsigned long __LDREX(unsigned long *)  (see intrinsics.h) */
Sstatic uint32_t __LDREXW(volatile uint32_t *addr)
S{
S  __ASM("ldrex r0, [r0]");
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
Sstatic uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S  __ASM("strexb r0, r0, [r1]");
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
Sstatic uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S  __ASM("strexh r0, r0, [r1]");
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S/* intrinsic unsigned long __STREX(unsigned long, unsigned long)  (see intrinsics.h )*/
Sstatic uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S  __ASM("strex r0, r0, [r1]");
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
Sstatic __INLINE void __CLREX(void)
S{
S  __ASM ("clrex");
S}
S
S/* intrinsic   unsigned char __CLZ( unsigned long )      (see intrinsics.h) */
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S#pragma diag_default=Pe940
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor, 
S    so that all instructions following the ISB are fetched from cache or 
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier. 
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before 
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S  
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S  
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S  
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) static __INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S  
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) static __INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S  
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S  
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S  
S   __ASM volatile ("strexb %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S  
S   __ASM volatile ("strexh %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S  
S   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) static __INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S  
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif (defined (__TASKING__)) /*--------------- TASKING Compiler -----------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H__ */
L 96 ".\Inc\core_cm0.h" 2
N#include "core_cmFunc.h"                 /*!< Core Function Access                            */
L 1 ".\Inc\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V2.01
N * @date     06. December 2010
N *
N * @note
N * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H__
N#define __CORE_CMFUNC_H__
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface   
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if defined ( __CC_ARM   ) /*------------------ RealView Compiler ----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          uint32_t __get_CONTROL(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          void __set_CONTROL(uint32_t control);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get ISPR Register
N
N    This function returns the content of the ISPR Register.
N
N    \return               ISPR Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          uint32_t __get_IPSR(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          uint32_t __get_APSR(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          uint32_t __get_xPSR(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          uint32_t __get_PSP(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          void __set_PSP(uint32_t topOfProcStack);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          uint32_t __get_MSP(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          void __set_MSP(uint32_t topOfMainStack);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          uint32_t __get_PRIMASK(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          void __set_PRIMASK(uint32_t priMask);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N#endif /*  __ARMCC_VERSION  */ 
N 
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S#if       (__ARMCC_VERSION <  400000)
Sextern          uint32_t __get_BASEPRI(void);
S#else  /* (__ARMCC_VERSION >= 400000) */
Sstatic __INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S#endif /*  __ARMCC_VERSION  */ 
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S#if       (__ARMCC_VERSION <  400000)
Sextern          void __set_BASEPRI(uint32_t basePri);
S#else  /* (__ARMCC_VERSION >= 400000) */
Sstatic __INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S#endif /*  __ARMCC_VERSION  */ 
S 
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S#if       (__ARMCC_VERSION <  400000)
Sextern          uint32_t __get_FAULTMASK(void);
S#else  /* (__ARMCC_VERSION >= 400000) */
Sstatic __INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S#endif /*  __ARMCC_VERSION  */ 
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S#if       (__ARMCC_VERSION <  400000)
Sextern          void __set_FAULTMASK(uint32_t faultMask);
S#else  /* (__ARMCC_VERSION >= 400000) */
Sstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & 1);
S}
S#endif /*  __ARMCC_VERSION  */ 
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
Sstatic __INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
Sstatic __INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N #elif (defined (__ICCARM__)) /*---------------- ICC Compiler ---------------------*/
S/* IAR iccarm specific functions */
S
S#if defined (__ICCARM__)
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
S#endif
S
S#pragma diag_suppress=Pe940
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S#define __enable_irq                              __enable_interrupt
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S#define __disable_irq                             __disable_interrupt
S
S
S/* intrinsic unsigned long __get_CONTROL( void ); (see intrinsic.h) */
S/* intrinsic void __set_CONTROL( unsigned long ); (see intrinsic.h) */
S
S
S/** \brief  Get ISPR Register
S
S    This function returns the content of the ISPR Register.
S
S    \return               ISPR Register value
S */
Sstatic uint32_t __get_IPSR(void)
S{
S  __ASM("mrs r0, ipsr");
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
Sstatic uint32_t __get_APSR(void)
S{
S  __ASM("mrs r0, apsr");
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
Sstatic uint32_t __get_xPSR(void)
S{
S  __ASM("mrs r0, psr");           // assembler does not know "xpsr"
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
Sstatic uint32_t __get_PSP(void)
S{
S  __ASM("mrs r0, psp");
S}
S 
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
Sstatic void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM("msr psp, r0");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
Sstatic uint32_t __get_MSP(void)
S{
S  __ASM("mrs r0, msp");
S}
S 
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
Sstatic void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM("msr msp, r0");
S}
S 
S
S/* intrinsic unsigned long __get_PRIMASK( void ); (see intrinsic.h) */
S/* intrinsic void __set_PRIMASK( unsigned long ); (see intrinsic.h) */
S 
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
Sstatic __INLINE void __enable_fault_irq(void)
S{
S  __ASM ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
Sstatic __INLINE void __disable_fault_irq(void)
S{
S  __ASM ("cpsid f");
S}
S
S
S/* intrinsic unsigned long __get_BASEPRI( void );   (see intrinsic.h) */
S/* intrinsic void __set_BASEPRI( unsigned long );   (see intrinsic.h) */
S/* intrinsic unsigned long __get_FAULTMASK( void ); (see intrinsic.h) */
S/* intrinsic void __set_FAULTMASK(unsigned long);   (see intrinsic.h) */
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
Sstatic uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1)
S  __ASM("vmrs r0, fpscr"); 
S#else
S  return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
Sstatic void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1)
S  __ASM("vmsr fpscr, r0");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S#pragma diag_default=Pe940
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get ISPR Register
S
S    This function returns the content of the ISPR Register.
S
S    \return               ISPR Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S 
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S 
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S 
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S  
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S  
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1)
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1)
S  __ASM volatile ("MSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif (defined (__TASKING__)) /*--------------- TASKING Compiler -----------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N#endif /* __CORE_CMFUNC_H__ */
L 97 ".\Inc\core_cm0.h" 2
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N/* IO definitions (access restrictions to peripheral registers) */
N#ifdef __cplusplus
S  #define     __I     volatile           /*!< defines 'read only' permissions                 */
N#else
N  #define     __I     volatile const     /*!< defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< defines 'write only' permissions                */
N#define     __IO    volatile             /*!< defines 'read / write' permissions              */
N
N/*@} end of group CMSIS_core_definitions */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N/** \defgroup CMSIS_core_register CMSIS Core Register
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N*/
N
N/** \ingroup  CMSIS_core_register   
N    \defgroup CMSIS_CORE CMSIS Core
N  Type definitions for the Cortex-M Core Registers
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */ 
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup  CMSIS_core_register   
N    \defgroup CMSIS_NVIC CMSIS NVIC
N  Type definitions for the Cortex-M NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IPR[8];                  /*!< Offset: 0x3EC (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IPR[8];                   
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register   
N    \defgroup CMSIS_SCB CMSIS SCB
N  Type definitions for the Cortex-M System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPU ID Base Register                                  */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control State Register                      */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;                                      
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt / Reset Control Register        */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;                                      
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N       uint32_t RESERVED2[2];                                   
N  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                     
N} SCB_Type;                                                
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register   
N    \defgroup CMSIS_SysTick CMSIS SysTick
N  Type definitions for the Cortex-M System Timer Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register   
N    \defgroup CMSIS_CoreDebug CMSIS Core Debug
N  Type definitions for the Cortex-M Core Debug Registers
N  @{
N */
N
N/** \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                    
N  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                    
N  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                    
N  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                    
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_DWTENA_Pos         24                                             /*!< CoreDebug DEMCR: DWTENA Position */
N#define CoreDebug_DEMCR_DWTENA_Msk         (1UL << CoreDebug_DEMCR_DWTENA_Pos)            /*!< CoreDebug DEMCR: DWTENA Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup  CMSIS_core_register   
N  @{
N */
N 
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address           */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct          */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct      */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct         */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct   */
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface CMSIS Core Function Interface
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface   
N    \defgroup CMSIS_Core_NVICFunctions CMSIS Core NVIC Functions
N  @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    This function enables a device specific interupt in the NVIC interrupt controller.
N    The interrupt number cannot be a negative value. 
N
N    \param [in]      IRQn  Number of the external interrupt to enable
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    This function disables a device specific interupt in the NVIC interrupt controller.
N    The interrupt number cannot be a negative value. 
N
N    \param [in]      IRQn  Number of the external interrupt to disable
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    This function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt. 
N
N    \param [in]      IRQn  Number of the interrupt for get pending
N    \return             0  Interrupt status is not pending
N    \return             1  Interrupt status is pending
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    This function sets the pending bit for the specified interrupt. 
N    The interrupt number cannot be a negative value.
N
N    \param [in]      IRQn  Number of the interrupt for set pending
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    This function clears the pending bit for the specified interrupt. 
N    The interrupt number cannot be a negative value.
N
N    \param [in]      IRQn  Number of the interrupt for clear pending
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    This function sets the priority for the specified interrupt. The interrupt 
N    number can be positive to specify an external (device specific) 
N    interrupt, or negative to specify an internal (core) interrupt.
N
N    Note: The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Number of the interrupt for set priority
N    \param [in]  priority  Priority to set
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) | 
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) | 
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 3)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IPR[_IP_IDX(IRQn)] = (NVIC->IPR[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->IPR[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->IPR[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 3)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    This function reads the priority for the specified interrupt. The interrupt 
N    number can be positive to specify an external (device specific) 
N    interrupt, or negative to specify an internal (core) interrupt.
N
N    The returned priority value is automatically aligned to the implemented
N    priority bits of the microcontroller.
N
N    \param [in]   IRQn  Number of the interrupt for get priority
N    \return             Interrupt Priority
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 3)));  }  
N  else {
N    return((uint32_t)((NVIC->IPR[_IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->IPR[( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 3)));  }  
N}
N
N
N/** \brief  System Reset
N
N    This function initiate a system reset request to reset the MCU.
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */              
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      | 
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL))->AIRCR  = ((0x5FA << 16)      | 
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */              
X  __dsb(0xF);                                                                    
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface   
N    \defgroup CMSIS_Core_SysTickFunctions CMSIS Core SysTick Functions
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    This function initialises the system tick timer and its interrupt and start the system tick timer.
N    Counter is in free running mode to generate periodical interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{ 
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFUL << 0))  return (1);             
N                                                               
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL))->LOAD  = (ticks & (0xFFFFFFUL << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<3) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL))->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | 
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL))->CTRL  = (1UL << 2) | 
N                   SysTick_CTRL_TICKINT_Msk   | 
X                   (1UL << 1)   | 
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
N
N/*lint -restore */
L 100 ".\Inc\LPC11Uxx.h" 2
N#include "system_LPC11Uxx.h"                /*!< LPC11Uxx System                       */
L 1 ".\Inc\system_LPC11Uxx.h" 1
N/**************************************************************************//**
N * @file     system_LPC11Uxx.h
N * @brief    CMSIS Cortex-M0 Device Peripheral Access Layer Header File
N *           for the NXP LPC11Uxx Device Series
N * @version  V1.10
N * @date     24. November 2010
N *
N * @note
N * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#ifndef __SYSTEM_LPC11Uxx_H__
N#define __SYSTEM_LPC11Uxx_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "Type.h"
L 1 ".\Inc\Type.h" 1
N/****************************************************************************
N *   $Id:: type.h 6172 2011-01-13 18:22:51Z usb00423                        $
N *   Project: NXP LPC11xx software example
N *
N *   Description:
N *     This file contains different type definition.
N *
N ****************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N****************************************************************************/
N#ifndef __TYPE_H__
N#define __TYPE_H__
N
N/* exact-width signed integer types */
Ntypedef signed char int8_t;
Ntypedef int8_t S8;
Ntypedef S8 RetS8;
Ntypedef signed short int int16_t;
Ntypedef int16_t S16;
Ntypedef S16 RetS16;
Ntypedef signed int int32_t;
Ntypedef int32_t S32;
Ntypedef S32 RetS32;
Ntypedef signed __int64 int64_t;
Ntypedef int64_t S64;
Ntypedef S64 RetS64;
N/*exact-width unsigned integer types */
Ntypedef unsigned char uint8_t;
Ntypedef uint8_t U8;
Ntypedef U8 RetU8;
Ntypedef unsigned short int uint16_t;
Ntypedef uint16_t U16;
Ntypedef U16 RetU16;
Ntypedef unsigned int uint32_t;
Ntypedef uint32_t U32;
Ntypedef U32 RetU32;
Ntypedef unsigned __int64 uint64_t;
Ntypedef uint64_t U64;
Ntypedef U64 RetU64;
N
Ntypedef U8 Boolean;
N
N// Dennis 16/5/2014
Ntypedef union
N{
N	U16 w;
N	U8 b[2];
N}u16;
N
Ntypedef union
N{
N	S16 w;
N	S8 b[2];
N}s16;
N
N#define BIT0 (1 << 0)
N#define BIT1 (1 << 1)
N#define BIT2 (1 << 2)
N#define BIT3 (1 << 3)
N#define BIT4 (1 << 4)
N#define BIT5 (1 << 5)
N#define BIT6 (1 << 6)
N#define BIT7 (1 << 7)
N#define BIT8 (1 << 8)
N#define BIT9 (1 << 9)
N#define BIT10 (1 << 10)
N#define BIT11 (1 << 11)
N#define BIT12 (1 << 12)
N#define BIT13 (1 << 13)
N#define BIT14 (1 << 14)
N#define BIT15 (1 << 15)
N#define BIT16 (1 << 16)
N#define BIT17 (1 << 17)
N#define BIT18 (1 << 18)
N#define BIT19 (1 << 19)
N#define BIT20 (1 << 20)
N#define BIT21 (1 << 21)
N#define BIT22 (1 << 22)
N#define BIT23 (1 << 23)
N#define BIT24 (1 << 24)
N#define BIT25 (1 << 25)
N#define BIT26 (1 << 26)
N#define BIT27 (1 << 27)
N#define BIT28 (1 << 28)
N#define BIT29 (1 << 29)
N#define BIT30 (1 << 30)
N#define BIT31 (1UL << 31)
N
N#ifndef NULL
N#define NULL ((void *)0)
N#endif
N
N#ifndef FALSE
N#define FALSE (0)
N#endif
N
N#ifndef TRUE
N#define TRUE (1)
N#endif
N
N#ifndef LOW
N#define LOW (0)
N#endif
N
N#ifndef HIGH
N#define HIGH (1)
N#endif
N
N#ifndef EMPTY
N#define EMPTY (0xFF)
N#endif
N
N#endif  /* __TYPE_H__ */
L 34 ".\Inc\system_LPC11Uxx.h" 2
N
N#ifdef  __SYSTEM_LPC11Uxx_C__
S#define INTERFACE
N#else
N#define INTERFACE extern
N#endif
N
N#define SYSOSCCTRL_Val 0x00000000/* Reset: 0x000*/
N#define WDTOSCCTRL_Val 0x00000000/*Reset: 0x000*/
N#define SYSPLLCTRL_Val 0x00000023/*eset: 0x000*/
N#define SYSPLLCLKSEL_Val 0x00000001/*Reset: 0x000*/
N#define MAINCLKSEL_Val 0x00000003/*Reset: 0x000*/
N#define SYSAHBCLKDIV_Val 0x00000001/*Reset: 0x001*/
N#define USBPLLCTRL_Val 0x00000023/*Reset: 0x000*/
N#define USBPLLCLKSEL_Val 0x00000001/*Reset: 0x000*/
N#define USBCLKSEL_Val 0x00000000/*Reset: 0x000*/
N#define USBCLKDIV_Val 0x00000001/*Reset: 0x001*/
N/*----------------------------------------------------------------------------
N  Define clocks
N *----------------------------------------------------------------------------*/
N#define __XTAL (12000000UL)/* Oscillator frequency*/
N#define __SYS_OSC_CLK (__XTAL)/* Main oscillator frequency*/
N/*----------------------------------------------------------------------------
N  Check the register settings
N *----------------------------------------------------------------------------*/
N
NINTERFACE U32 SystemCoreClock;/*!< System Clock Frequency (Core Clock)*/
Xextern U32 SystemCoreClock; 
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
NINTERFACE void nsAPI_System_Init(void);
Xextern void nsAPI_System_Init(void);
N
N#undef INTERFACE
N#ifdef __cplusplus
S}
N#endif
N#endif /* __SYSTEM_LPC11Uxx_H */
L 101 ".\Inc\LPC11Uxx.h" 2
N
N/** @addtogroup Device_Peripheral_Registers
N  * @{
N  */
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                          I2C                                         -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x I2C-bus controller Modification date=3/16/2011 Major revision=0 Minor revision=3  (I2C)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40000000) I2C Structure          */
N  __IO uint32_t CONSET;                     /*!< (@ 0x40000000) I2C Control Set Register */
X  volatile uint32_t CONSET;                      
N  __I  uint32_t STAT;                       /*!< (@ 0x40000004) I2C Status Register */
X  volatile const  uint32_t STAT;                        
N  __IO uint32_t DAT;                        /*!< (@ 0x40000008) I2C Data Register.  */
X  volatile uint32_t DAT;                         
N  __IO uint32_t ADR0;                       /*!< (@ 0x4000000C) I2C Slave Address Register 0 */
X  volatile uint32_t ADR0;                        
N  __IO uint32_t SCLH;                       /*!< (@ 0x40000010) SCH Duty Cycle Register High Half Word */
X  volatile uint32_t SCLH;                        
N  __IO uint32_t SCLL;                       /*!< (@ 0x40000014) SCL Duty Cycle Register Low Half Word */
X  volatile uint32_t SCLL;                        
N  __IO uint32_t CONCLR;                     /*!< (@ 0x40000018) I2C Control Clear Register*/
X  volatile uint32_t CONCLR;                      
N  __IO uint32_t MMCTRL;                     /*!< (@ 0x4000001C) Monitor mode control register*/
X  volatile uint32_t MMCTRL;                      
N  __IO uint32_t ADR1;                       /*!< (@ 0x40000020) I2C Slave Address Register 1*/
X  volatile uint32_t ADR1;                        
N  __IO uint32_t ADR2;                       /*!< (@ 0x40000024) I2C Slave Address Register 2*/
X  volatile uint32_t ADR2;                        
N  __IO uint32_t ADR3;                       /*!< (@ 0x40000028) I2C Slave Address Register 3*/
X  volatile uint32_t ADR3;                        
N  __I  uint32_t DATA_BUFFER;                /*!< (@ 0x4000002C) Data buffer register */
X  volatile const  uint32_t DATA_BUFFER;                 
Nunion{
N  __IO uint32_t MASK[4];                    /*!< (@ 0x40000030) I2C Slave address mask register */
X  volatile uint32_t MASK[4];                     
N  struct{
N  __IO uint32_t MASK0;
X  volatile uint32_t MASK0;
N  __IO uint32_t MASK1;
X  volatile uint32_t MASK1;
N  __IO uint32_t MASK2;
X  volatile uint32_t MASK2;
N  __IO uint32_t MASK3;
X  volatile uint32_t MASK3;
N  };
N  };
N} LPC_I2C_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                         WWDT                                         -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x Windowed Watchdog Timer (WWDT) Modification date=3/16/2011 Major revision=0 Minor revision=3  (WWDT)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40004000) WWDT Structure         */
N  __IO uint32_t MOD;                        /*!< (@ 0x40004000) Watchdog mode register*/
X  volatile uint32_t MOD;                         
N  __IO uint32_t TC;                         /*!< (@ 0x40004004) Watchdog timer constant register */
X  volatile uint32_t TC;                          
N  __IO uint32_t FEED;                       /*!< (@ 0x40004008) Watchdog feed sequence register */
X  volatile uint32_t FEED;                        
N  __I  uint32_t TV;                         /*!< (@ 0x4000400C) Watchdog timer value register */
X  volatile const  uint32_t TV;                          
N  __IO uint32_t CLKSEL;                     /*!< (@ 0x40004010) Watchdog clock select register. */
X  volatile uint32_t CLKSEL;                      
N  __IO uint32_t WARNINT;                    /*!< (@ 0x40004014) Watchdog Warning Interrupt compare value. */
X  volatile uint32_t WARNINT;                     
N  __IO uint32_t WINDOW;                     /*!< (@ 0x40004018) Watchdog Window compare value. */
X  volatile uint32_t WINDOW;                      
N} LPC_WWDT_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                         USART                                        -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x USART Modification date=3/16/2011 Major revision=0 Minor revision=3  (USART)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40008000) USART Structure        */
N  
N  union {
N    __IO uint32_t DLL;                      /*!< (@ 0x40008000) Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1) */
X    volatile uint32_t DLL;                       
N    __O  uint32_t THR;                      /*!< (@ 0x40008000) Transmit Holding Register. The next character to be transmitted is written here. (DLAB=0) */
X    volatile  uint32_t THR;                       
N    __I  uint32_t RBR;                      /*!< (@ 0x40008000) Receiver Buffer Register. Contains the next received character to be read. (DLAB=0) */
X    volatile const  uint32_t RBR;                       
N  };
N  
N  union {
N    __IO uint32_t IER;                      /*!< (@ 0x40008004) Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential USART interrupts. (DLAB=0) */
X    volatile uint32_t IER;                       
N    __IO uint32_t DLM;                      /*!< (@ 0x40008004) Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1) */
X    volatile uint32_t DLM;                       
N  };
N  
N  union {
N    __O  uint32_t FCR;                      /*!< (@ 0x40008008) FIFO Control Register. Controls USART FIFO usage and modes. */
X    volatile  uint32_t FCR;                       
N    __I  uint32_t IIR;                      /*!< (@ 0x40008008) Interrupt ID Register. Identifies which interrupt(s) are pending. */
X    volatile const  uint32_t IIR;                       
N  };
N  __IO uint32_t LCR;                        /*!< (@ 0x4000800C) Line Control Register. Contains controls for frame formatting and break generation. */
X  volatile uint32_t LCR;                         
N  __IO uint32_t MCR;                        /*!< (@ 0x40008010) Modem Control Register. */
X  volatile uint32_t MCR;                         
N  __I  uint32_t LSR;                        /*!< (@ 0x40008014) Line Status Register. Contains flags for transmit and receive status, including line errors. */
X  volatile const  uint32_t LSR;                         
N  __I  uint32_t MSR;                        /*!< (@ 0x40008018) Modem Status Register. */
X  volatile const  uint32_t MSR;                         
N  __IO uint32_t SCR;                        /*!< (@ 0x4000801C) Scratch Pad Register. Eight-bit temporary storage for software. */
X  volatile uint32_t SCR;                         
N  __IO uint32_t ACR;                        /*!< (@ 0x40008020) Auto-baud Control Register. Contains controls for the auto-baud feature. */
X  volatile uint32_t ACR;                         
N  __IO uint32_t ICR;                        /*!< (@ 0x40008024) IrDA Control Register. Enables and configures the IrDA (remote control) mode. */
X  volatile uint32_t ICR;                         
N  __IO uint32_t FDR;                        /*!< (@ 0x40008028) Fractional Divider Register. Generates a clock input for the baud rate divider. */
X  volatile uint32_t FDR;                         
N  __IO uint32_t OSR;                        /*!< (@ 0x4000802C) Oversampling Register. Controls the degree of oversampling during each bit time. */
X  volatile uint32_t OSR;                         
N  __IO uint32_t TER;                        /*!< (@ 0x40008030) Transmit Enable Register. Turns off USART transmitter for use with software flow control. */
X  volatile uint32_t TER;                         
N  __I  uint32_t RESERVED0[3];
X  volatile const  uint32_t RESERVED0[3];
N  __IO uint32_t HDEN;                       /*!< (@ 0x40008040) Half duplex enable register. */
X  volatile uint32_t HDEN;                        
N  __I  uint32_t RESERVED1;
X  volatile const  uint32_t RESERVED1;
N  __IO uint32_t SCICTRL;                    /*!< (@ 0x40008048) Smart Card Interface Control register. Enables and configures the Smart Card Interface feature. */
X  volatile uint32_t SCICTRL;                     
N  __IO uint32_t RS485CTRL;                  /*!< (@ 0x4000804C) RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes. */
X  volatile uint32_t RS485CTRL;                   
N  __IO uint32_t RS485ADRMATCH;              /*!< (@ 0x40008050) RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode. */
X  volatile uint32_t RS485ADRMATCH;               
N  __IO uint32_t RS485DLY;                   /*!< (@ 0x40008054) RS-485/EIA-485 direction control delay. */
X  volatile uint32_t RS485DLY;                    
N  __IO uint32_t SYNCCTRL; 
X  volatile uint32_t SYNCCTRL; 
N} LPC_USART_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                        Timer                                       -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x 32-bitcounter/timers CT32B0/1 Modification date=3/16/2011 Major revision=0 Minor revision=3  
N  */
N
Ntypedef struct {                            /*!< (@ 0x40014000) CT32B0 Structure        */
N  __IO uint32_t IR;                         /*!< (@ 0x40014000) Interrupt Register      */
X  volatile uint32_t IR;                          
N  __IO uint32_t TCR;                        /*!< (@ 0x40014004) Timer Control Register  */
X  volatile uint32_t TCR;                         
N  __IO uint32_t TC;                         /*!< (@ 0x40014008) Timer Counter 		*/
X  volatile uint32_t TC;                          
N  __IO uint32_t PR;                         /*!< (@ 0x4001400C) Prescale Register  	*/
X  volatile uint32_t PR;                          
N  __IO uint32_t PC;                         /*!< (@ 0x40014010) Prescale Counter	 */
X  volatile uint32_t PC;                          
N  __IO uint32_t MCR;                        /*!< (@ 0x40014014) Match Control Register */
X  volatile uint32_t MCR;                         
N  union {
N  __IO uint32_t MR[4];                      /*!< (@ 0x40014018) Match Register */
X  volatile uint32_t MR[4];                       
N  struct{
N  __IO uint32_t MR0;                        /*!< (@ 0x40018018) Match Register. MR0 */
X  volatile uint32_t MR0;                         
N  __IO uint32_t MR1;                        /*!< (@ 0x4001801C) Match Register. MR1 */
X  volatile uint32_t MR1;                         
N  __IO uint32_t MR2;                        /*!< (@ 0x40018020) Match Register. MR2 */
X  volatile uint32_t MR2;                         
N  __IO uint32_t MR3;                        /*!< (@ 0x40018024) Match Register. MR3 */
X  volatile uint32_t MR3;                         
N  };
N  };
N  __IO uint32_t CCR;                        /*!< (@ 0x40014028) Capture Control Register */
X  volatile uint32_t CCR;                         
N  union{
N  __I  uint32_t CR[4];                      /*!< (@ 0x4001402C) Capture Register  */
X  volatile const  uint32_t CR[4];                       
N    struct{
N  __I  uint32_t CR0;			    /*!< (@ 0x4001802C) Capture Register. CR 0 */
X  volatile const  uint32_t CR0;			     
N  __I  uint32_t CR1;			    /*!< (@ 0x40018030) Capture Register. CR 1 */
X  volatile const  uint32_t CR1;			     
N  __I  uint32_t CR2;			    /*!< (@ 0x40018034) Capture Register. CR 2 */
X  volatile const  uint32_t CR2;			     
N  __I  uint32_t CR3;			    /*!< (@ 0x40018038) Capture Register. CR 3 */
X  volatile const  uint32_t CR3;			     
N  };
N  };
N__IO uint32_t EMR;                        /*!< (@ 0x4001403C) External Match Register */
Xvolatile uint32_t EMR;                         
N  __I  uint32_t RESERVED0[12];
X  volatile const  uint32_t RESERVED0[12];
N  __IO uint32_t CTCR;                       /*!< (@ 0x40014070) Count Control Register */
X  volatile uint32_t CTCR;                        
N  __IO uint32_t PWMC;                       /*!< (@ 0x40014074) PWM Control Register */
X  volatile uint32_t PWMC;                        
N} LPC_CTxxBx_Type;
N
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                          ADC                                         -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x ADC Modification date=3/16/2011 Major revision=0 Minor revision=3  (ADC)
N  */
N
Ntypedef struct {                            /*!< (@ 0x4001C000) ADC Structure          */
N  __IO uint32_t CR;                         /*!< (@ 0x4001C000) A/D Control Register */
X  volatile uint32_t CR;                          
N  __IO uint32_t GDR;                        /*!< (@ 0x4001C004) A/D Global Data Register */
X  volatile uint32_t GDR;                         
N  __I  uint32_t RESERVED0[1];
X  volatile const  uint32_t RESERVED0[1];
N  __IO uint32_t INTEN;                      /*!< (@ 0x4001C00C) A/D Interrupt Enable Register */
X  volatile uint32_t INTEN;                       
N  union{
N  __I  uint32_t DR[8];                      /*!< (@ 0x4001C010) A/D Channel Data Register*/
X  volatile const  uint32_t DR[8];                       
N    struct{
N  __IO uint32_t DR0;                      	/*!< (@ 0x40020010) A/D Channel Data Register 0*/
X  volatile uint32_t DR0;                      	 
N  __IO uint32_t DR1;                      	/*!< (@ 0x40020014) A/D Channel Data Register 1*/
X  volatile uint32_t DR1;                      	 
N  __IO uint32_t DR2;                      	/*!< (@ 0x40020018) A/D Channel Data Register 2*/
X  volatile uint32_t DR2;                      	 
N  __IO uint32_t DR3;                      	/*!< (@ 0x4002001C) A/D Channel Data Register 3*/
X  volatile uint32_t DR3;                      	 
N  __IO uint32_t DR4;                      	/*!< (@ 0x40020020) A/D Channel Data Register 4*/
X  volatile uint32_t DR4;                      	 
N  __IO uint32_t DR5;                      	/*!< (@ 0x40020024) A/D Channel Data Register 5*/
X  volatile uint32_t DR5;                      	 
N  __IO uint32_t DR6;                      	/*!< (@ 0x40020028) A/D Channel Data Register 6*/
X  volatile uint32_t DR6;                      	 
N  __IO uint32_t DR7;                      	/*!< (@ 0x4002002C) A/D Channel Data Register 7*/
X  volatile uint32_t DR7;                      	 
N  };
N  };
N  __I  uint32_t STAT;                       /*!< (@ 0x4001C030) A/D Status Register.  */
X  volatile const  uint32_t STAT;                        
N} LPC_ADC_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                          PMU                                         -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x Power Management Unit (PMU) Modification date=3/16/2011 Major revision=0 Minor revision=3  (PMU)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40038000) PMU Structure          */
N  __IO uint32_t PCON;                       /*!< (@ 0x40038000) Power control register */
X  volatile uint32_t PCON;                        
N  union{
N  __IO uint32_t GPREG[4];                   /*!< (@ 0x40038004) General purpose register 0 */
X  volatile uint32_t GPREG[4];                    
N  struct{
N  __IO uint32_t GPREG0;                   	/*!< (@ 0x40038004) General purpose register 0 */
X  volatile uint32_t GPREG0;                   	 
N  __IO uint32_t GPREG1;                   	/*!< (@ 0x40038008) General purpose register 1 */
X  volatile uint32_t GPREG1;                   	 
N  __IO uint32_t GPREG2;                   	/*!< (@ 0x4003800C) General purpose register 2 */
X  volatile uint32_t GPREG2;                   	 
N  __IO uint32_t GPREG3;                   	/*!< (@ 0x40038010) General purpose register 3 */
X  volatile uint32_t GPREG3;                   	 
N  };
N  };
N} LPC_PMU_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                       FLASHCTRL                                      -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x Flash programming firmware Modification date=3/17/2011 Major revision=0 Minor revision=3  (FLASHCTRL)
N  */
N
Ntypedef struct {                            /*!< (@ 0x4003C000) FLASHCTRL Structure    */
N  __I  uint32_t RESERVED0[4];
X  volatile const  uint32_t RESERVED0[4];
N  __IO uint32_t FLASHCFG;                   /*!< (@ 0x4003C010) Flash memory access time configuration register */
X  volatile uint32_t FLASHCFG;                    
N  __I  uint32_t RESERVED1[3];
X  volatile const  uint32_t RESERVED1[3];
N  __IO uint32_t FMSSTART;                   /*!< (@ 0x4003C020) Signature start address register */
X  volatile uint32_t FMSSTART;                    
N  __IO uint32_t FMSSTOP;                    /*!< (@ 0x4003C024) Signature stop-address register */
X  volatile uint32_t FMSSTOP;                     
N  __I  uint32_t RESERVED2[1];
X  volatile const  uint32_t RESERVED2[1];
N  __I  uint32_t FMSW0;                      /*!< (@ 0x4003C02C) Word 0 [31:0]          */
X  volatile const  uint32_t FMSW0;                       
N  __I  uint32_t FMSW1;                      /*!< (@ 0x4003C030) Word 1 [63:32]         */
X  volatile const  uint32_t FMSW1;                       
N  __I  uint32_t FMSW2;                      /*!< (@ 0x4003C034) Word 2 [95:64]         */
X  volatile const  uint32_t FMSW2;                       
N  __I  uint32_t FMSW3;                      /*!< (@ 0x4003C038) Word 3 [127:96]        */
X  volatile const  uint32_t FMSW3;                       
N  __I  uint32_t RESERVED3[1001];
X  volatile const  uint32_t RESERVED3[1001];
N  __I  uint32_t FMSTAT;                     /*!< (@ 0x4003CFE0) Signature generation status register */
X  volatile const  uint32_t FMSTAT;                      
N  __I  uint32_t RESERVED4[1];
X  volatile const  uint32_t RESERVED4[1];
N  __IO uint32_t FMSTATCLR;                  /*!< (@ 0x4003CFE8) Signature generation status clear register */
X  volatile uint32_t FMSTATCLR;                   
N} LPC_FLASHCTRL_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                         SSP0/1                                         -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x SSP/SPI Modification date=3/16/2011 Major revision=0 Minor revision=3  (SSP0)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40040000) SSP0 Structure         */
N  __IO uint32_t CR0;                        /*!< (@ 0x40040000) Control Register 0. Selects the serial clock rate, bus type, and data size. */
X  volatile uint32_t CR0;                         
N  __IO uint32_t CR1;                        /*!< (@ 0x40040004) Control Register 1. Selects master/slave and other modes. */
X  volatile uint32_t CR1;                         
N  __IO uint32_t DR;                         /*!< (@ 0x40040008) Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO. */
X  volatile uint32_t DR;                          
N  __I  uint32_t SR;                         /*!< (@ 0x4004000C) Status Register        */
X  volatile const  uint32_t SR;                          
N  __IO uint32_t CPSR;                       /*!< (@ 0x40040010) Clock Prescale Register */
X  volatile uint32_t CPSR;                        
N  __IO uint32_t IMSC;                       /*!< (@ 0x40040014) Interrupt Mask Set and Clear Register */
X  volatile uint32_t IMSC;                        
N  __I  uint32_t RIS;                        /*!< (@ 0x40040018) Raw Interrupt Status Register */
X  volatile const  uint32_t RIS;                         
N  __I  uint32_t MIS;                        /*!< (@ 0x4004001C) Masked Interrupt Status Register */
X  volatile const  uint32_t MIS;                         
N  __IO uint32_t ICR;                        /*!< (@ 0x40040020) SSPICR Interrupt Clear Register */
X  volatile uint32_t ICR;                         
N} LPC_SSPx_Type;
N
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                       IOCONFIG                                       -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x I/O configuration Modification date=3/16/2011 Major revision=0 Minor revision=3  (IOCONFIG)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40044000) IOCONFIG Structure     */
N  __IO uint32_t RESET_PIO0_0;               /*!< (@ 0x40044000) I/O configuration for pin RESET/PIO0_0 */
X  volatile uint32_t RESET_PIO0_0;                
N  __IO uint32_t PIO0_1;                     /*!< (@ 0x40044004) I/O configuration for pin PIO0_1/CLKOUT/CT32B0_MAT2/USB_FTOGGLE */
X  volatile uint32_t PIO0_1;                      
N  __IO uint32_t PIO0_2;                     /*!< (@ 0x40044008) I/O configuration for pin PIO0_2/SSEL0/CT16B0_CAP0 */
X  volatile uint32_t PIO0_2;                      
N  __IO uint32_t PIO0_3;                     /*!< (@ 0x4004400C) I/O configuration for pin PIO0_3/USB_VBUS */
X  volatile uint32_t PIO0_3;                      
N  __IO uint32_t PIO0_4;                     /*!< (@ 0x40044010) I/O configuration for pin PIO0_4/SCL */
X  volatile uint32_t PIO0_4;                      
N  __IO uint32_t PIO0_5;                     /*!< (@ 0x40044014) I/O configuration for pin PIO0_5/SDA */
X  volatile uint32_t PIO0_5;                      
N  __IO uint32_t PIO0_6;                     /*!< (@ 0x40044018) I/O configuration for pin PIO0_6/USB_CONNECT/SCK0 */
X  volatile uint32_t PIO0_6;                      
N  __IO uint32_t PIO0_7;                     /*!< (@ 0x4004401C) I/O configuration for pin PIO0_7/CTS */
X  volatile uint32_t PIO0_7;                      
N  __IO uint32_t PIO0_8;                     /*!< (@ 0x40044020) I/O configuration for pin PIO0_8/MISO0/CT16B0_MAT0 */
X  volatile uint32_t PIO0_8;                      
N  __IO uint32_t PIO0_9;                     /*!< (@ 0x40044024) I/O configuration for pin PIO0_9/MOSI0/CT16B0_MAT1 */
X  volatile uint32_t PIO0_9;                      
N  __IO uint32_t SWCLK_PIO0_10;              /*!< (@ 0x40044028) I/O configuration for pin SWCLK/PIO0_10/ SCK0/CT16B0_MAT2 */
X  volatile uint32_t SWCLK_PIO0_10;               
N  __IO uint32_t TDI_PIO0_11;                /*!< (@ 0x4004402C) I/O configuration for pin TDI/PIO0_11/AD0/CT32B0_MAT3 */
X  volatile uint32_t TDI_PIO0_11;                 
N  __IO uint32_t TMS_PIO0_12;                /*!< (@ 0x40044030) I/O configuration for pin TMS/PIO0_12/AD1/CT32B1_CAP0 */
X  volatile uint32_t TMS_PIO0_12;                 
N  __IO uint32_t TDO_PIO0_13;                /*!< (@ 0x40044034) I/O configuration for pin TDO/PIO0_13/AD2/CT32B1_MAT0 */
X  volatile uint32_t TDO_PIO0_13;                 
N  __IO uint32_t TRST_PIO0_14;               /*!< (@ 0x40044038) I/O configuration for pin TRST/PIO0_14/AD3/CT32B1_MAT1 */
X  volatile uint32_t TRST_PIO0_14;                
N  __IO uint32_t SWDIO_PIO0_15;              /*!< (@ 0x4004403C) I/O configuration for pin SWDIO/PIO0_15/AD4/CT32B1_MAT2 */
X  volatile uint32_t SWDIO_PIO0_15;               
N  __IO uint32_t PIO0_16;                    /*!< (@ 0x40044040) I/O configuration for pin PIO0_16/AD5/CT32B1_MAT3/ WAKEUP */
X  volatile uint32_t PIO0_16;                     
N  __IO uint32_t PIO0_17;                    /*!< (@ 0x40044044) I/O configuration for pin PIO0_17/RTS/CT32B0_CAP0/SCLK */
X  volatile uint32_t PIO0_17;                     
N  __IO uint32_t PIO0_18;                    /*!< (@ 0x40044048) I/O configuration for pin PIO0_18/RXD/CT32B0_MAT0 */
X  volatile uint32_t PIO0_18;                     
N  __IO uint32_t PIO0_19;                    /*!< (@ 0x4004404C) I/O configuration for pin PIO0_19/TXD/CT32B0_MAT1 */
X  volatile uint32_t PIO0_19;                     
N  __IO uint32_t PIO0_20;                    /*!< (@ 0x40044050) I/O configuration for pin PIO0_20/CT16B1_CAP0 */
X  volatile uint32_t PIO0_20;                     
N  __IO uint32_t PIO0_21;                    /*!< (@ 0x40044054) I/O configuration for pin PIO0_21/CT16B1_MAT0/MOSI1 */
X  volatile uint32_t PIO0_21;                     
N  __IO uint32_t PIO0_22;                    /*!< (@ 0x40044058) I/O configuration for pin PIO0_22/AD6/CT16B1_MAT1/MISO1 */
X  volatile uint32_t PIO0_22;                     
N  __IO uint32_t PIO0_23;                    /*!< (@ 0x4004405C) I/O configuration for pin PIO0_23/AD7 */
X  volatile uint32_t PIO0_23;                     
N  __IO uint32_t PIO1_0;                 /*!< Offset: 0x060 */
X  volatile uint32_t PIO1_0;                  
N  __IO uint32_t PIO1_1;         
X  volatile uint32_t PIO1_1;         
N  __IO uint32_t PIO1_2;       
X  volatile uint32_t PIO1_2;       
N  __IO uint32_t PIO1_3;      
X  volatile uint32_t PIO1_3;      
N  __IO uint32_t PIO1_4;                 /*!< Offset: 0x070 */
X  volatile uint32_t PIO1_4;                  
N  __IO uint32_t PIO1_5;                     /*!< (@ 0x40044074) I/O configuration for pin PIO1_5/CT32B1_CAP1 */
X  volatile uint32_t PIO1_5;                      
N  __IO uint32_t PIO1_6;     
X  volatile uint32_t PIO1_6;     
N  __IO uint32_t PIO1_7;       
X  volatile uint32_t PIO1_7;       
N  __IO uint32_t PIO1_8;                 /*!< Offset: 0x080 */
X  volatile uint32_t PIO1_8;                  
N  __IO uint32_t PIO1_9;        
X  volatile uint32_t PIO1_9;        
N  __IO uint32_t PIO1_10;        
X  volatile uint32_t PIO1_10;        
N  __IO uint32_t PIO1_11;       
X  volatile uint32_t PIO1_11;       
N  __IO uint32_t PIO1_12;                /*!< Offset: 0x090 */
X  volatile uint32_t PIO1_12;                 
N  __IO uint32_t PIO1_13;                    /*!< (@ 0x40044094) I/O configuration for pin PIO1_13/DTR/CT16B0_MAT0/TXD */
X  volatile uint32_t PIO1_13;                     
N  __IO uint32_t PIO1_14;                    /*!< (@ 0x40044098) I/O configuration for pin PIO1_14/DSR/CT16B0_MAT1/RXD */
X  volatile uint32_t PIO1_14;                     
N  __IO uint32_t PIO1_15;                    /*!< (@ 0x4004409C) I/O configuration for pin PIO1_15/DCD/ CT16B0_MAT2/SCK1 */
X  volatile uint32_t PIO1_15;                     
N  __IO uint32_t PIO1_16;                    /*!< (@ 0x400440A0) I/O configuration for pin PIO1_16/RI/CT16B0_CAP0 */
X  volatile uint32_t PIO1_16;                     
N  __IO uint32_t PIO1_17;
X  volatile uint32_t PIO1_17;
N  __IO uint32_t PIO1_18;
X  volatile uint32_t PIO1_18;
N  __IO uint32_t PIO1_19;                    /*!< (@ 0x400440AC) I/O configuration for pin PIO1_19/DTR/SSEL1 */
X  volatile uint32_t PIO1_19;                     
N  __IO uint32_t PIO1_20;                    /*!< (@ 0x400440B0) I/O configuration for pin PIO1_20/DSR/SCK1 */
X  volatile uint32_t PIO1_20;                     
N  __IO uint32_t PIO1_21;                    /*!< (@ 0x400440B4) I/O configuration for pin PIO1_21/DCD/MISO1 */
X  volatile uint32_t PIO1_21;                     
N  __IO uint32_t PIO1_22;                    /*!< (@ 0x400440B8) I/O configuration for pin PIO1_22/RI/MOSI1 */
X  volatile uint32_t PIO1_22;                     
N  __IO uint32_t PIO1_23;                    /*!< (@ 0x400440BC) I/O configuration for pin PIO1_23/CT16B1_MAT1/SSEL1 */
X  volatile uint32_t PIO1_23;                     
N  __IO uint32_t PIO1_24;                    /*!< (@ 0x400440C0) I/O configuration for pin PIO1_24/ CT32B0_MAT0 */
X  volatile uint32_t PIO1_24;                     
N  __IO uint32_t PIO1_25;                    /*!< (@ 0x400440C4) I/O configuration for pin PIO1_25/CT32B0_MAT1 */
X  volatile uint32_t PIO1_25;                     
N  __IO uint32_t PIO1_26;                    /*!< (@ 0x400440C8) I/O configuration for pin PIO1_26/CT32B0_MAT2/ RXD */
X  volatile uint32_t PIO1_26;                     
N  __IO uint32_t PIO1_27;                    /*!< (@ 0x400440CC) I/O configuration for pin PIO1_27/CT32B0_MAT3/ TXD */
X  volatile uint32_t PIO1_27;                     
N  __IO uint32_t PIO1_28;                    /*!< (@ 0x400440D0) I/O configuration for pin PIO1_28/CT32B0_CAP0/ SCLK */
X  volatile uint32_t PIO1_28;                     
N  __IO uint32_t PIO1_29;                    /*!< (@ 0x400440D4) I/O configuration for pin PIO1_29/SCK0/ CT32B0_CAP1 */
X  volatile uint32_t PIO1_29;                     
N  __IO uint32_t PIO1_30;
X  volatile uint32_t PIO1_30;
N  __IO uint32_t PIO1_31;                    /*!< (@ 0x400440DC) I/O configuration for pin PIO1_31 */
X  volatile uint32_t PIO1_31;                     
N} LPC_IOCON_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                        SYSCON                                        -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x System control block Modification date=3/16/2011 Major revision=0 Minor revision=3  (SYSCON)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40048000) SYSCON Structure       */
N  __IO uint32_t SYSMEMREMAP;                /*!< (@ 0x40048000) System memory remap    */
X  volatile uint32_t SYSMEMREMAP;                 
N  __IO uint32_t PRESETCTRL;                 /*!< (@ 0x40048004) Peripheral reset control */
X  volatile uint32_t PRESETCTRL;                  
N  __IO uint32_t SYSPLLCTRL;                 /*!< (@ 0x40048008) System PLL control     */
X  volatile uint32_t SYSPLLCTRL;                  
N  __I  uint32_t SYSPLLSTAT;                 /*!< (@ 0x4004800C) System PLL status      */
X  volatile const  uint32_t SYSPLLSTAT;                  
N  __IO uint32_t USBPLLCTRL;                 /*!< (@ 0x40048010) USB PLL control        */
X  volatile uint32_t USBPLLCTRL;                  
N  __I  uint32_t USBPLLSTAT;                 /*!< (@ 0x40048014) USB PLL status         */
X  volatile const  uint32_t USBPLLSTAT;                  
N  __I  uint32_t RESERVED0[2];
X  volatile const  uint32_t RESERVED0[2];
N  __IO uint32_t SYSOSCCTRL;                 /*!< (@ 0x40048020) System oscillator control */
X  volatile uint32_t SYSOSCCTRL;                  
N  __IO uint32_t WDTOSCCTRL;                 /*!< (@ 0x40048024) Watchdog oscillator control */
X  volatile uint32_t WDTOSCCTRL;                  
N  __I  uint32_t RESERVED1[2];
X  volatile const  uint32_t RESERVED1[2];
N  __IO uint32_t SYSRSTSTAT;                 /*!< (@ 0x40048030) System reset status register */
X  volatile uint32_t SYSRSTSTAT;                  
N  __I  uint32_t RESERVED2[3];
X  volatile const  uint32_t RESERVED2[3];
N  __IO uint32_t SYSPLLCLKSEL;               /*!< (@ 0x40048040) System PLL clock source select */
X  volatile uint32_t SYSPLLCLKSEL;                
N  __IO uint32_t SYSPLLCLKUEN;               /*!< (@ 0x40048044) System PLL clock source update enable */
X  volatile uint32_t SYSPLLCLKUEN;                
N  __IO uint32_t USBPLLCLKSEL;               /*!< (@ 0x40048048) USB PLL clock source select */
X  volatile uint32_t USBPLLCLKSEL;                
N  __IO uint32_t USBPLLCLKUEN;               /*!< (@ 0x4004804C) USB PLL clock source update enable */
X  volatile uint32_t USBPLLCLKUEN;                
N  __I  uint32_t RESERVED3[8];
X  volatile const  uint32_t RESERVED3[8];
N  __IO uint32_t MAINCLKSEL;                 /*!< (@ 0x40048070) Main clock source select */
X  volatile uint32_t MAINCLKSEL;                  
N  __IO uint32_t MAINCLKUEN;                 /*!< (@ 0x40048074) Main clock source update enable */
X  volatile uint32_t MAINCLKUEN;                  
N  __IO uint32_t SYSAHBCLKDIV;               /*!< (@ 0x40048078) System clock divider   */
X  volatile uint32_t SYSAHBCLKDIV;                
N  __I  uint32_t RESERVED4[1];
X  volatile const  uint32_t RESERVED4[1];
N  __IO uint32_t SYSAHBCLKCTRL;              /*!< (@ 0x40048080) System clock control   */
X  volatile uint32_t SYSAHBCLKCTRL;               
N  __I  uint32_t RESERVED5[4];
X  volatile const  uint32_t RESERVED5[4];
N  __IO uint32_t SSP0CLKDIV;                 /*!< (@ 0x40048094) SSP0 clock divider     */
X  volatile uint32_t SSP0CLKDIV;                  
N  __IO uint32_t UARTCLKDIV;                 /*!< (@ 0x40048098) UART clock divider     */
X  volatile uint32_t UARTCLKDIV;                  
N  __IO uint32_t SSP1CLKDIV;                 /*!< (@ 0x4004809C) SSP1 clock divider     */
X  volatile uint32_t SSP1CLKDIV;                  
N  __I  uint32_t RESERVED6[8];
X  volatile const  uint32_t RESERVED6[8];
N  __IO uint32_t USBCLKSEL;                  /*!< (@ 0x400480C0) USB clock source select */
X  volatile uint32_t USBCLKSEL;                   
N  __IO uint32_t USBCLKUEN;                  /*!< (@ 0x400480C4) USB clock source update enable */
X  volatile uint32_t USBCLKUEN;                   
N  __IO uint32_t USBCLKDIV;                  /*!< (@ 0x400480C8) USB clock source divider */
X  volatile uint32_t USBCLKDIV;                   
N  __I  uint32_t RESERVED7[5];
X  volatile const  uint32_t RESERVED7[5];
N  __IO uint32_t CLKOUTSEL;                  /*!< (@ 0x400480E0) CLKOUT clock source select */
X  volatile uint32_t CLKOUTSEL;                   
N  __IO uint32_t CLKOUTUEN;                  /*!< (@ 0x400480E4) CLKOUT clock source update enable */
X  volatile uint32_t CLKOUTUEN;                   
N  __IO uint32_t CLKOUTDIV;                  /*!< (@ 0x400480E8) CLKOUT clock divider   */
X  volatile uint32_t CLKOUTDIV;                   
N  __I  uint32_t RESERVED8[5];
X  volatile const  uint32_t RESERVED8[5];
N  __I  uint32_t PIOPORCAP0;                 /*!< (@ 0x40048100) POR captured PIO status 0 */
X  volatile const  uint32_t PIOPORCAP0;                  
N  __I  uint32_t PIOPORCAP1;                 /*!< (@ 0x40048104) POR captured PIO status 1 */
X  volatile const  uint32_t PIOPORCAP1;                  
N  __I  uint32_t RESERVED9[18];
X  volatile const  uint32_t RESERVED9[18];
N  __IO uint32_t BODCTRL;                    /*!< (@ 0x40048150) Brown-Out Detect       */
X  volatile uint32_t BODCTRL;                     
N  __IO uint32_t SYSTCKCAL;                  /*!< (@ 0x40048154) System tick counter calibration */
X  volatile uint32_t SYSTCKCAL;                   
N  __I  uint32_t RESERVED10[6];
X  volatile const  uint32_t RESERVED10[6];
N  __IO uint32_t IRQLATENCY;                 /*!< (@ 0x40048170) IQR delay */
X  volatile uint32_t IRQLATENCY;                  
N  __IO uint32_t NMISRC;                     /*!< (@ 0x40048174) NMI Source Control     */
X  volatile uint32_t NMISRC;                      
N  __IO uint32_t PINTSEL[8];                 /*!< (@ 0x40048178) GPIO Pin Interrupt Select register 0 */
X  volatile uint32_t PINTSEL[8];                  
N  __IO uint32_t USBCLKCTRL;                 /*!< (@ 0x40048198) USB clock control      */
X  volatile uint32_t USBCLKCTRL;                  
N  __I  uint32_t USBCLKST;                   /*!< (@ 0x4004819C) USB clock status       */
X  volatile const  uint32_t USBCLKST;                    
N  __I  uint32_t RESERVED11[25];
X  volatile const  uint32_t RESERVED11[25];
N  __IO uint32_t STARTERP0;                  /*!< (@ 0x40048204) Start logic 0 interrupt wake-up enable register 0 */
X  volatile uint32_t STARTERP0;                   
N  __I  uint32_t RESERVED12[3];
X  volatile const  uint32_t RESERVED12[3];
N  __IO uint32_t STARTERP1;                  /*!< (@ 0x40048214) Start logic 1 interrupt wake-up enable register 1 */
X  volatile uint32_t STARTERP1;                   
N  __I  uint32_t RESERVED13[6];
X  volatile const  uint32_t RESERVED13[6];
N  __IO uint32_t PDSLEEPCFG;                 /*!< (@ 0x40048230) Power-down states in deep-sleep mode */
X  volatile uint32_t PDSLEEPCFG;                  
N  __IO uint32_t PDAWAKECFG;                 /*!< (@ 0x40048234) Power-down states for wake-up from deep-sleep */
X  volatile uint32_t PDAWAKECFG;                  
N  __IO uint32_t PDRUNCFG;                   /*!< (@ 0x40048238) Power configuration register */
X  volatile uint32_t PDRUNCFG;                    
N  __I  uint32_t RESERVED14[110];
X  volatile const  uint32_t RESERVED14[110];
N  __I  uint32_t DEVICE_ID;                  /*!< (@ 0x400483F4) Device ID              */
X  volatile const  uint32_t DEVICE_ID;                   
N} LPC_SYSCON_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                     GPIO_PIN_INT                                     -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x GPIO Modification date=3/17/2011 Major revision=0 Minor revision=3  (GPIO_PIN_INT)
N  */
N
Ntypedef struct {                            /*!< (@ 0x4004C000) GPIO_PIN_INT Structure */
N  __IO uint32_t ISEL;                       /*!< (@ 0x4004C000) Pin Interrupt Mode register */
X  volatile uint32_t ISEL;                        
N  __IO uint32_t IENR;                       /*!< (@ 0x4004C004) Pin Interrupt Enable (Rising) register */
X  volatile uint32_t IENR;                        
N  __IO uint32_t SIENR;                      /*!< (@ 0x4004C008) Set Pin Interrupt Enable (Rising) register */
X  volatile uint32_t SIENR;                       
N  __IO uint32_t CIENR;                      /*!< (@ 0x4004C00C) Clear Pin Interrupt Enable (Rising) register */
X  volatile uint32_t CIENR;                       
N  __IO uint32_t IENF;                       /*!< (@ 0x4004C010) Pin Interrupt Enable Falling Edge / Active Level register */
X  volatile uint32_t IENF;                        
N  __IO uint32_t SIENF;                      /*!< (@ 0x4004C014) Set Pin Interrupt Enable Falling Edge / Active Level register */
X  volatile uint32_t SIENF;                       
N  __IO uint32_t CIENF;                      /*!< (@ 0x4004C018) Clear Pin Interrupt Enable Falling Edge / Active Level address */
X  volatile uint32_t CIENF;                       
N  __IO uint32_t RISE;                       /*!< (@ 0x4004C01C) Pin Interrupt Rising Edge register */
X  volatile uint32_t RISE;                        
N  __IO uint32_t FALL;                       /*!< (@ 0x4004C020) Pin Interrupt Falling Edge register */
X  volatile uint32_t FALL;                        
N  __IO uint32_t IST;                        /*!< (@ 0x4004C024) Pin Interrupt Status register */
X  volatile uint32_t IST;                         
N} LPC_GPIO_PIN_INT_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                    GPIO_GROUP_INT0/1                                   -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x GPIO Modification date=3/17/2011 Major revision=0 Minor revision=3  (GPIO_GROUP_INT0)
N  */
N
Ntypedef struct {                            /*!< (@ 0x4005C000) GPIO_GROUP_INT0 Structure */
N  __IO uint32_t CTRL;                       /*!< (@ 0x4005C000) GPIO grouped interrupt control register */
X  volatile uint32_t CTRL;                        
N  __I  uint32_t RESERVED0[7];
X  volatile const  uint32_t RESERVED0[7];
N  __IO uint32_t PORT_POL[2];                /*!< (@ 0x4005C020) GPIO grouped interrupt port 0 polarity register */
X  volatile uint32_t PORT_POL[2];                 
N  __I  uint32_t RESERVED1[6];
X  volatile const  uint32_t RESERVED1[6];
N  __IO uint32_t PORT_ENA[2];                /*!< (@ 0x4005C040) GPIO grouped interrupt port 0/1 enable register */
X  volatile uint32_t PORT_ENA[2];                 
N} LPC_GPIO_GROUP_INTx_Type;
N
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                          USB                                         -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x USB2.0device controller Modification date=3/16/2011 Major revision=0 Minor revision=3  (USB)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40080000) USB Structure          */
N  __IO uint32_t DEVCMDSTAT;                 /*!< (@ 0x40080000) USB Device Command/Status register */
X  volatile uint32_t DEVCMDSTAT;                  
N  __IO uint32_t INFO;                       /*!< (@ 0x40080004) USB Info register      */
X  volatile uint32_t INFO;                        
N  __IO uint32_t EPLISTSTART;                /*!< (@ 0x40080008) USB EP Command/Status List start address */
X  volatile uint32_t EPLISTSTART;                 
N  __IO uint32_t DATABUFSTART;               /*!< (@ 0x4008000C) USB Data buffer start address */
X  volatile uint32_t DATABUFSTART;                
N  __IO uint32_t LPM;                        /*!< (@ 0x40080010) Link Power Management register */
X  volatile uint32_t LPM;                         
N  __IO uint32_t EPSKIP;                     /*!< (@ 0x40080014) USB Endpoint skip      */
X  volatile uint32_t EPSKIP;                      
N  __IO uint32_t EPINUSE;                    /*!< (@ 0x40080018) USB Endpoint Buffer in use */
X  volatile uint32_t EPINUSE;                     
N  __IO uint32_t EPBUFCFG;                   /*!< (@ 0x4008001C) USB Endpoint Buffer Configuration register */
X  volatile uint32_t EPBUFCFG;                    
N  __IO uint32_t INTSTAT;                    /*!< (@ 0x40080020) USB interrupt status register */
X  volatile uint32_t INTSTAT;                     
N  __IO uint32_t INTEN;                      /*!< (@ 0x40080024) USB interrupt enable register */
X  volatile uint32_t INTEN;                       
N  __IO uint32_t INTSETSTAT;                 /*!< (@ 0x40080028) USB set interrupt status register */
X  volatile uint32_t INTSETSTAT;                  
N  __IO uint32_t INTROUTING;                 /*!< (@ 0x4008002C) USB interrupt routing register */
X  volatile uint32_t INTROUTING;                  
N  __I  uint32_t RESERVED0[1];
X  volatile const  uint32_t RESERVED0[1];
N  __I  uint32_t EPTOGGLE;                   /*!< (@ 0x40080034) USB Endpoint toggle register */
X  volatile const  uint32_t EPTOGGLE;                    
N} LPC_USB_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                       GPIO_PORT                                      -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x GPIO Modification date=3/17/2011 Major revision=0 Minor revision=3  (GPIO_PORT)
N  */
N
Ntypedef struct {                            
N  union {
N    struct {
N      __IO uint8_t B0[32];                       /*!< (@ 0x50000000) Byte pin registers port 0; pins PIO0_0 to PIO0_31 */
X      volatile uint8_t B0[32];                        
N      __IO uint8_t B1[32];                       /*!< (@ 0x50000020) Byte pin registers port 1 */
X      volatile uint8_t B1[32];                        
N    };
N    __IO uint8_t B[64];                       /*!< (@ 0x50000000) Byte pin registers port 0/1 */
X    volatile uint8_t B[64];                        
N  };
N  __I  uint32_t RESERVED0[1008];
X  volatile const  uint32_t RESERVED0[1008];
N  union {
N    struct {
N      __IO uint32_t W0[32];                      /*!< (@ 0x50001000) Word pin registers port 0 */
X      volatile uint32_t W0[32];                       
N      __IO uint32_t W1[32];                      /*!< (@ 0x50001080) Word pin registers port 1 */
X      volatile uint32_t W1[32];                       
N    };
N    __IO uint32_t W[64];                       /*!< (@ 0x50001000) Word pin registers port 0/1 */
X    volatile uint32_t W[64];                        
N  };
N       uint32_t RESERVED1[960];
N  __IO uint32_t DIR[2];			/* 0x2000 */
X  volatile uint32_t DIR[2];			 
N       uint32_t RESERVED2[30];
N  __IO uint32_t MASK[2];		/* 0x2080 */
X  volatile uint32_t MASK[2];		 
N       uint32_t RESERVED3[30];
N  __IO uint32_t PIN[2];			/* 0x2100 */
X  volatile uint32_t PIN[2];			 
N       uint32_t RESERVED4[30];
N  __IO uint32_t MPIN[2];		/* 0x2180 */
X  volatile uint32_t MPIN[2];		 
N       uint32_t RESERVED5[30];
N  __IO uint32_t SET[2];			/* 0x2200 */
X  volatile uint32_t SET[2];			 
N       uint32_t RESERVED6[30];
N  __O  uint32_t CLR[2];			/* 0x2280 */
X  volatile  uint32_t CLR[2];			 
N       uint32_t RESERVED7[30];
N  __O  uint32_t NOT[2];			/* 0x2300 */
X  volatile  uint32_t NOT[2];			 
N} LPC_GPIO_Type;
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #pragma no_anon_unions
N#endif
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                 Peripheral memory map                                -----
N// ------------------------------------------------------------------------------------------------
N
N#define LPC_I2C_BASE              (0x40000000)
N#define LPC_WWDT_BASE             (0x40004000)
N#define LPC_USART_BASE            (0x40008000)
N#define LPC_CT16B0_BASE           (0x4000C000)
N#define LPC_CT16B1_BASE           (0x40010000)
N#define LPC_CT32B0_BASE           (0x40014000)
N#define LPC_CT32B1_BASE           (0x40018000)
N#define LPC_ADC_BASE              (0x4001C000)
N#define LPC_PMU_BASE              (0x40038000)
N#define LPC_FLASHCTRL_BASE        (0x4003C000)
N#define LPC_SSP0_BASE             (0x40040000)
N#define LPC_SSP1_BASE             (0x40058000)
N#define LPC_IOCON_BASE            (0x40044000)
N#define LPC_SYSCON_BASE           (0x40048000)
N#define LPC_GPIO_PIN_INT_BASE     (0x4004C000)
N#define LPC_GPIO_GROUP_INT0_BASE  (0x4005C000)
N#define LPC_GPIO_GROUP_INT1_BASE  (0x40060000)
N#define LPC_USB_BASE              (0x40080000)
N#define LPC_GPIO_BASE             (0x50000000)
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                Peripheral declaration                                -----
N// ------------------------------------------------------------------------------------------------
N
N#define LPC_I2C                   ((LPC_I2C_Type            *) LPC_I2C_BASE)
N#define LPC_WWDT                  ((LPC_WWDT_Type           *) LPC_WWDT_BASE)
N#define LPC_USART                 ((LPC_USART_Type          *) LPC_USART_BASE)
N#define LPC_CT16B0                ((LPC_CTxxBx_Type         *) LPC_CT16B0_BASE)
N#define LPC_CT16B1                ((LPC_CTxxBx_Type         *) LPC_CT16B1_BASE)
N#define LPC_CT32B0                ((LPC_CTxxBx_Type         *) LPC_CT32B0_BASE)
N#define LPC_CT32B1                ((LPC_CTxxBx_Type         *) LPC_CT32B1_BASE)
N#define LPC_ADC                   ((LPC_ADC_Type            *) LPC_ADC_BASE)
N#define LPC_PMU                   ((LPC_PMU_Type            *) LPC_PMU_BASE)
N#define LPC_FLASHCTRL             ((LPC_FLASHCTRL_Type      *) LPC_FLASHCTRL_BASE)
N#define LPC_SSP0                  ((LPC_SSPx_Type           *) LPC_SSP0_BASE)
N#define LPC_SSP1                  ((LPC_SSPx_Type           *) LPC_SSP1_BASE)
N#define LPC_IOCON                 ((LPC_IOCON_Type          *) LPC_IOCON_BASE)
N#define LPC_SYSCON                ((LPC_SYSCON_Type         *) LPC_SYSCON_BASE)
N#define LPC_GPIO_PIN_INT          ((LPC_GPIO_PIN_INT_Type   *) LPC_GPIO_PIN_INT_BASE)
N#define LPC_GPIO_GROUP_INT0       ((LPC_GPIO_GROUP_INTx_Type*) LPC_GPIO_GROUP_INT0_BASE)
N#define LPC_GPIO_GROUP_INT1       ((LPC_GPIO_GROUP_INTx_Type*) LPC_GPIO_GROUP_INT1_BASE)
N#define LPC_USB                   ((LPC_USB_Type            *) LPC_USB_BASE)
N#define LPC_GPIO                  ((LPC_GPIO_Type           *) LPC_GPIO_BASE)
N
N
N/** @} */ /* End of group Device_Peripheral_Registers */
N/** @} */ /* End of group (null) */
N/** @} */ /* End of group LPC11Uxx */
N
N#ifdef __cplusplus
S}
N#endif
N#endif  // __LPC11UXX_H__
N
L 4 "Src\Flash.c" 2
N#include "Flash.h"
L 1 ".\Inc\Flash.h" 1
N#ifndef _FLASH_H_
N#define _FLASH_H_
N
N#include "Type.h"
N#include "Main.h"
L 1 ".\Inc\Main.h" 1
N/*----------------------------------------------------------------------------
N *      Name:    MAIN.H
N *      Purpose: USB HID Demo Definitions
N *      Version: V1.20
N *----------------------------------------------------------------------------
N *      This software is supplied "AS IS" without any warranties, express,
N *      implied or statutory, including but not limited to the implied
N *      warranties of fitness for purpose, satisfactory quality and
N *      noninfringement. Keil extends you a royalty-free right to reproduce
N *      and distribute executable files created using this software for use
N *      on NXP Semiconductors LPC microcontroller devices only. Nothing else 
N *      gives you the right to use this software.
N *
N * Copyright (c) 2009 Keil - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N#ifndef __MAIN_H__
N#define __MAIN_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "Type.h"
N#include "usbcfg.h"
L 1 ".\Inc\usbcfg.h" 1
N/*----------------------------------------------------------------------------
N *      U S B  -  K e r n e l
N *----------------------------------------------------------------------------
N * Name:    usbcfg.h
N * Purpose: USB Custom Configuration
N * Version: V1.20
N *----------------------------------------------------------------------------
N *      This software is supplied "AS IS" without any warranties, express,
N *      implied or statutory, including but not limited to the implied
N *      warranties of fitness for purpose, satisfactory quality and
N *      noninfringement. Keil extends you a royalty-free right to reproduce
N *      and distribute executable files created using this software for use
N *      on NXP Semiconductors LPC family microcontroller devices only. Nothing 
N *      else gives you the right to use this software.
N *
N * Copyright (c) 2009 Keil - An ARM Company. All rights reserved.
N *----------------------------------------------------------------------------
N * History:
N *          V1.20 Added vendor specific support
N *          V1.00 Initial Version
N *----------------------------------------------------------------------------*/
N
N#ifndef __USBCFG_H__
N#define __USBCFG_H__
N
N
N//*** <<< Use Configuration Wizard in Context Menu >>> ***
N
N
N/*
N// <h> USB Configuration
N//   <o0> USB Power
N//        <i> Default Power Setting
N//        <0=> Bus-powered
N//        <1=> Self-powered
N//   <o1> Max Number of Interfaces <1-256>
N//   <o2> Max Number of Endpoints  <1-32>
N//   <o3> Max Setup Packet Size
N//        <8=> 8 Bytes <16=> 16 Bytes <32=> 32 Bytes <64=> 64 Bytes
N//   <o4> Max Endpoint 0 Packet Size
N//        <8=> 8 Bytes <16=> 16 Bytes <32=> 32 Bytes <64=> 64 Bytes
N//   <o5> Maximum non-isochronous packet size  <1-64>
N//   <o6> Maximum isochronous packet size  <1-1023>
N
N// </h>
N*/
N
N#define USB_POWER 0
N#define USB_IF_NUM 1
N#define USB_EP_NUM 4 // 10 dennis
N#define USB_SETUP_PACKET_SIZE 8
N#define USB_MAX_PACKET0 64
N#define USB_MAX_NON_ISO_SIZE 64
N#define USB_MAX_ISO_SIZE 1023
N#define USB_LOGIC_EP_NUM 5
N
N
N#if 1 // dennis 6/5/2014
N	#define USB_PACKET_SIZE 0x12
N#else
S	#define USB_PACKET_SIZE 8
N#endif	  
N
N/*
N// <h> Miscellaneous USB support
N//     <o0.0> Power Down USB Wake-up
N//     <o1.0> Remote Wake-up enable
N//     <o2.0> Use double-buffered endpoints
N//     <o3.0> Link Power Management Support
N//     <o4.0> Isochronous communications
N//     <o5.0> Use Debug
N// </h>
N*/
N
N/* If REMOTE_WAKEUP_ENABLE is set to 1, set POWERDOWN_MODE_USB_WAKEUP flag to 0.
N   Don't turn on both flags at the same time. */
N#define POWERDOWN_MODE_USB_WAKEUP   0
N#define REMOTE_WAKEUP_ENABLE        0
N#define USE_DOUBLE_BUFFER           0
N#define LPM_SUPPORT                 0	/* Link Power Management */
N#define USB_ISO_COMMUNICATION       0
N
N/*
N// <h> USB Event Handlers
N//   <h> Device Events
N//     <o0.0> Power Event
N//     <o1.0> Reset Event
N//     <o2.0> Suspend Event
N//     <o3.0> Resume Event
N//     <o4.0> Remote Wakeup Event
N//     <o5.0> Start of Frame Event
N//     <o6.0> Error Event
N//   </h>
N//   <h> Endpoint Events
N//     <o7.0>  Endpoint 0 Event
N//     <o7.1>  Endpoint 1 Event
N//     <o7.2>  Endpoint 2 Event
N//     <o7.3>  Endpoint 3 Event
N//     <o7.4>  Endpoint 4 Event
N//   </h>
N//   <h> USB Core Events
N//     <o8.0>  Set Configuration Event
N//     <o9.0>  Set Interface Event
N//     <o10.0> Set/Clear Feature Event
N//   </h>
N// </h>
N*/
N
N#define USB_POWER_EVENT     0
N#define USB_RESET_EVENT     1
N#define USB_SUSPEND_EVENT   1
N#define USB_RESUME_EVENT    1
N#define USB_WAKEUP_EVENT    0
N#define USB_SOF_EVENT       0
N#define USB_ERROR_EVENT     0
N#define USB_EP_EVENT 0x0003
N#define USB_CONFIGURE_EVENT 1
N#define USB_INTERFACE_EVENT 0
N#define USB_FEATURE_EVENT   0
N#define USB_FIQ_EVENT		0
N
N
N/*
N// <e0> USB Class Support
N//   <i> enables USB Class specific Requests
N//   <e1> Human Interface Device (HID)
N//     <o2> Interface Number <0-255>
N//   </e>
N//   <e3> Mass Storage
N//     <o4> Interface Number <0-255>
N//   </e>
N//   <e5> Audio Device
N//     <o6> Control Interface Number <0-255>
N//     <o7> Streaming Interface 1 Number <0-255>
N//     <o8> Streaming Interface 2 Number <0-255>
N//   </e>
N//   <e9> Communication Device
N//     <o10> Control Interface Number <0-255>
N//     <o11> Bulk Interface Number <0-255>
N//     <o12> Max Communication Device Buffer Size
N//        <8=> 8 Bytes <16=> 16 Bytes <32=> 32 Bytes <64=> 64 Bytes 
N//   </e>
N// </e>
N*/
N
N#define USB_CLASS 1
N#define USB_HID 1
N#define USB_HID_IF_NUM 0
N
N/*
N// <e0> USB Vendor Support
N//   <i> enables USB Vendor specific Requests
N// </e>
N*/
N#define USB_VENDOR 0
N#endif  /* __USBCFG_H__ */
N
L 25 ".\Inc\Main.h" 2
N//#include "Pixart_Sensor.h"
N
N#ifdef _MAIN_C_
S#define INTERFACE
N#else
N#define INTERFACE extern
N#endif
N
N#define _DEMO_ONLY_ 0
N
N#define EP1_IN BIT0
N#define EP1_OUT BIT1
N#define EP2_IN BIT2
N#define EP2_OUT BIT3
N#define EP3_IN BIT4
N#define EP3_OUT BIT5
N#define EP4_IN BIT6
N#define EP4_OUT BIT7
N
N#define MISC_EVENT (BIT3|BIT2)
N
N
Ntypedef enum _GIndex_
N{
N    GIdx0 = 0,
N    GIdx1,
N    GIdx2,
N    GIdx3,
N    GIdx4,
N    GIdx5,
N    GIdx6,
N    GIdx7,
N    GIdx8,
N    GIdxLen =  GIdx8,
N}GIndex;
N
N#define MAIN_FLAG_MOUSE_REPORT_READY	BIT0	
N#define MAIN_FLAG_MOUSE_BUTTON_EVENT	BIT1	
N#define MAIN_FLAG_MOUSE_QIE_EVENT		BIT2
N//#define MAIN_FLAG_MOUSE_EVENT	BIT3
N#define MAIN_FLAG_MOUSE_EVENT			BIT3
N//#define MAIN_FLAG_MOUSE_FRAME_CAPTURE_EVENT BIT4
N
N/* HID Demo Variables */
Ntypedef struct _LPC11Uxx_MAIN_SETTING_
N{
N	U8 InReport[USB_PACKET_SIZE];
X	U8 InReport[0x12];
N	U8 OutReport[USB_PACKET_SIZE];
X	U8 OutReport[0x12];
N	U8 EPInOutReq;
N	U8 InReportSize;
N	U16 MouseEvent;
N}LPC11Uxx_MAIN_SETTING;
N
NINTERFACE LPC11Uxx_MAIN_SETTING g_Main_Setting;
Xextern LPC11Uxx_MAIN_SETTING g_Main_Setting;
N
N
N/* HID Demo Functions */
NINTERFACE void nsAPI_Main_GetInReport(void);
Xextern void nsAPI_Main_GetInReport(void);
NINTERFACE void SetOutReport(void);
Xextern void SetOutReport(void);
NINTERFACE void nsAPI_Main_MouseEventHandle(void);
Xextern void nsAPI_Main_MouseEventHandle(void);
NINTERFACE void nsAPI_Main_GetInMouseButtonReport(U16 *PreButtonEvent,U16 *u16ButtonStatus,U16 *KeycodeTblIdx);
Xextern void nsAPI_Main_GetInMouseButtonReport(U16 *PreButtonEvent,U16 *u16ButtonStatus,U16 *KeycodeTblIdx);
NINTERFACE void nsAPI_Main_GetInMouseQIEReport(S8 s8Temp);
Xextern void nsAPI_Main_GetInMouseQIEReport(S8 s8Temp);
NINTERFACE void nsAPI_Main_Clr_MouseEvent(void);
Xextern void nsAPI_Main_Clr_MouseEvent(void);
NINTERFACE void Mapp_Main_Init(void);
Xextern void Mapp_Main_Init(void);
N
N#undef INTERFACE
N#ifdef __cplusplus
S}
N#endif
N#endif //__MAIN_H__
L 6 ".\Inc\Flash.h" 2
N
N#ifdef _FLASH_C_
N#define INTERFACE
N#else
S#define INTERFACE extern
N#endif
N
N#define _Flash_Debug_(y) //y 
N
N#define Sector_0_Start_Adr 0x00000000
N#define Sector_1_Start_Adr 0x00001000
N#define Sector_2_Start_Adr 0x00002000
N#define Sector_3_Start_Adr 0x00003000
N#define Sector_4_Start_Adr 0x00004000
N#define Sector_5_Start_Adr 0x00005000/*LPC1113*/
N#define Sector_6_Start_Adr 0x00006000
N#define Sector_7_Start_Adr 0x00007000/*LPC1114*/
N
N#define Sector_0_End_Adr 0x00000FFF
N#define Sector_1_End_Adr 0x00001FFF
N#define Sector_2_End_Adr 0x00002FFF
N#define Sector_3_End_Adr 0x00003FFF
N#define Sector_4_End_Adr 0x00004FFF
N#define Sector_5_End_Adr 0x00005FFF/*LPC1113*/
N#define Sector_6_End_Adr 0x00006FFF
N#define Sector_7_End_Adr 0x00007FFF/*LPC1114*/
N
N#define Sector_0 0
N#define Sector_1 1
N#define Sector_2 2
N#define Sector_3 3
N#define Sector_4 4
N#define Sector_5 5/*LPC1113*/
N#define Sector_6 6
N#define Sector_7 7/*LPC1114*/
N
N#define AppCode_StartAdr Sector_3_Start_Adr 
N#define AppCode_StartSector Sector_3
N#define AppCode_EndSector Sector_7
N
N#define AppUpgrade_EndAdr Sector_7_End_Adr
N#define AppUpgrade_ReserveLen 0xFF				//need check
N#define AppUpgrade_Adr (AppUpgrade_EndAdr -AppUpgrade_ReserveLen)
N#define AppUpgrade_FlagAdr AppUpgrade_Adr 
N
N#define R2FBUFSIZE 256
N#define Vectors_Table_Size 0x100 
N
N#define AppID 0x5A5A
N
N#define AppID_Adr 0x00003100
N#define AppVer_Adr 0x00001104
N#define AppNonUpgradeID 0xCA//AC
N#define AppReqUpgradeID 0xAC//CA
N#define BL_NORMAL 0xAA//BB
N#define AP_MAIN_OFFSET	0x001C
N#define ID_SUCCESS 0xFE
N
N
N/* IAP Command Definitions */
N#define	IAP_CMD_PREPARE_SECTORS 		50
N#define	IAP_CMD_COPY_RAM_TO_FLASH 		51
N#define	IAP_CMD_ERASE_SECTORS 			52
N#define	IAP_CMD_BLANK_CHECK_SECTORS		53
N#define	IAP_CMD_READ_PART_ID			54
N#define	IAP_CMD_READ_BOOT_ROM_VERSION 	55
N#define	IAP_CMD_COMPARE 				56
N#define	IAP_CMD_REINVOKE_ISP 			57
N
N/* IAP Command Status Codes */
N#define IAP_STA_CMD_SUCCESS 0
N#define IAP_STA_INVALID_COMMAND 1
N#define IAP_STA_SRC_ADDR_ERROR 2
N#define IAP_STA_DST_ADDR_ERROR 3
N#define IAP_STA_SRC_ADDR_NOT_MAPPED 4
N#define IAP_STA_DST_ADDR_NOT_MAPPED 5
N#define IAP_STA_COUNT_ERROR 6
N#define IAP_STA_INVALID_SECTOR 7
N#define IAP_STA_SECTOR_NOT_BLANK 8
N#define IAP_STA_SECTOR_NOT_PREPARED_FOR_WRITE_OPERATION 9
N#define IAP_STA_COMPARE_ERROR 10
N#define IAP_STA_BUSY 11
N#define IAP_STA_INVALD_PARAM 12
N
N
N#define IAP_CLK (Fcclk /1000)
N
N/* IAP boot ROM location and access function */
N#define IAP_ROM_LOCATION 0x1FFF1FF1UL
N//				(U32 *)	0x1FFF1FF1
N#define IAP_EXECUTE_CMD(a, b) ((void (*)())(IAP_ROM_LOCATION))(a, b) 
N
N
Ntypedef U8 BOOLEAN;
Ntypedef U8 BootLean;
N#define MSEL 0x00000003
N#define Fcclk (__SYS_OSC_CLK*(MSEL+1))
N
Ntypedef enum _BootloaderStatusType_
N{
N	_BL_IDLE_ = 0xA0,	
N	_BL_START_,
N	_BL_READY_,
N	_BL_NEXTLINE,
N	_BL_BUSY_,
N	_BL_COMPLETED_,
N	_BL_BITERROR_,
N	_BL_ERROE_,
N	_BL_SECTION_BL,
N	_BL_SECTION_APP,
N	_BL_EMPTY_ = 0xFF
N}BootloaderStatusType;
N
Ntypedef enum _SIndex_
N{
N    SIDX0 = 0,
N    SIDX1,
N    SIDX2,
N    SIDX3,
N    SIDX4,
N    SIDX5,
N    SIDX6,
N    SIDX7,
N    SIDX8,
N    SIDXLEN = SIDX8,
N}SIndex; 
N
Ntypedef struct _LPC11xx_Bootloader_Setting_
N{  		
N	U8 AddrPoint256;
N	U8 BufOffset;
N	U16 AddrPointOffset;	
N	
N	U8 CopyData2Buf[9];
N	U8 Buf2Flash[R2FBUFSIZE] __attribute__ ((aligned (4)));
X	U8 Buf2Flash[256] __attribute__ ((aligned (4)));
N	
N	BootloaderStatusType pMsg;
N
N}LPC11xx_Bootloader_Setting;
N
N
NINTERFACE volatile LPC11xx_Bootloader_Setting g_BootloaderSetting;
X volatile LPC11xx_Bootloader_Setting g_BootloaderSetting;
NINTERFACE void Write_In_Flash(void);
X void Write_In_Flash(void);
NINTERFACE RetU32 msAPI_Flash_PrepareSec( U32 StartSecNum , U32 EndSecNum ) ;
X RetU32 msAPI_Flash_PrepareSec( U32 StartSecNum , U32 EndSecNum ) ;
NINTERFACE RetU32 msAPI_Flash_CopyRAM2Flash( U32 dst , U32 src , U16 number) ;
X RetU32 msAPI_Flash_CopyRAM2Flash( U32 dst , U32 src , U16 number) ;
NINTERFACE RetU32 msAPI_Flash_EraseSec( U32 StartSecNum , U32 EndSecNum );
X RetU32 msAPI_Flash_EraseSec( U32 StartSecNum , U32 EndSecNum );
N#if 0
SINTERFACE U32 msAPI_Flash_BlankChkSec( U32 StartSecNum , U32 EndSecNum , U32 * pResult ) ;
SINTERFACE U32 msAPI_Flash_ReadParID( U32 * PartID );
SINTERFACE U32 msAPI_Flash_Read_BootVer( U32 * MajorVer , U32 * MinorVer ) ;
SINTERFACE U32 msAPI_Flash_Compare( U32 dst , U32 src , U32 number , U32 *offset );
SINTERFACE void  msAPI_Flash_ReinvokeISP(void) ;
SINTERFACE void msAPI_Flash_Ram_Fill(U8 *u8src_prt,U32 u32Size);
N#endif
NINTERFACE void  nsAPI_Flash_Jump2AppSector(void);
X void  nsAPI_Flash_Jump2AppSector(void);
NINTERFACE void nsAPI_Flash_BootBurn2Flash(void);
X void nsAPI_Flash_BootBurn2Flash(void);
NINTERFACE void nsAPI_Flash_UpgradeID(U16 u16ID);
X void nsAPI_Flash_UpgradeID(U16 u16ID);
NINTERFACE void msAPI_Flash_SlaveTransmitter_Status(U8 S0 ,U8 S1,U8 S2);
X void msAPI_Flash_SlaveTransmitter_Status(U8 S0 ,U8 S1,U8 S2);
N//INTERFACE BinCheckSumStatusType msAPI_Flash_IsCheckSumCorrect(void);
NINTERFACE void nsAPI_Flash_Init(void);
X void nsAPI_Flash_Init(void);
NINTERFACE void nsAPI_Flash_SetBLStatus(BootloaderStatusType BLStatus);
X void nsAPI_Flash_SetBLStatus(BootloaderStatusType BLStatus);
NINTERFACE BootloaderStatusType nsAPI_Flash_GetBLStatus(void);
X BootloaderStatusType nsAPI_Flash_GetBLStatus(void);
NINTERFACE RetU8 _XRead(U32 u32Adr);
X RetU8 _XRead(U32 u32Adr);
NINTERFACE BootLean nsAPI_Flash_AppPresent(void);
X BootLean nsAPI_Flash_AppPresent(void);
NINTERFACE BootLean nsAPI_Flash_IsUpgrade(void);
X BootLean nsAPI_Flash_IsUpgrade(void);
NINTERFACE void nsAPI_Flash_EraseAppSector(void);
X void nsAPI_Flash_EraseAppSector(void);
NINTERFACE void nsAPI_Flash_CopyData2Buf(U8 u8Lenth);
X void nsAPI_Flash_CopyData2Buf(U8 u8Lenth);
N//INTERFACE void nsAPI_Flash_CopyData2Buf(void);
N#undef INTERFACE
N#endif 
L 5 "Src\Flash.c" 2
N#include "wdt.h"
L 1 ".\Inc\wdt.h" 1
N/****************************************************************************
N *   $Id:: wdt.h 4110 2010-08-02 22:28:35Z usb01267                         $
N *   Project: NXP LPC11Uxx WDT example
N *
N *   Description:
N *     This file contains WDT code header definition.
N *
N ****************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N****************************************************************************/
N#ifndef __WDT_H 
N#define __WDT_H
N
N#define WDEN              (0x1<<0)
N#define WDRESET           (0x1<<1)
N#define WDTOF             (0x1<<2)
N#define WDINT             (0x1<<3)
N#define WDPROTECT         (0x1<<4)
N#define WDLOCKCLK         (0x1<<5)
N
N#define WDT_FEED_VALUE		0x003FFFFF
N
N#define WINDOW_MODE       0
N#define PROTECT_MODE      1
N#define WATCHDOG_RESET    1
N#define WDLOCK_MODE       0
N#define LOCKCLK_MODE      0
N
Nextern void WDT_IRQHandler(void);
Nextern void WDTInit( void );
Nextern void WDTFeed( void );
Nextern void WDT_CLK_Setup ( uint32_t clksrc );
N#endif /* end __WDT_H */
N/*****************************************************************************
N**                            End Of File
N******************************************************************************/
L 6 "Src\Flash.c" 2
N#include "GPIO.h"
L 1 ".\Inc\GPIO.h" 1
N/****************************************************************************
N *   $Id:: gpio.h 6172 2011-01-13 18:22:51Z usb00423                        $
N *   Project: NXP LPC11xx software example
N *
N *   Description:
N *     This file contains definition and prototype for GPIO.
N *
N ****************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N****************************************************************************/
N#ifndef __GPIO_H__ 
N#define __GPIO_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "Type.h"
N
N#ifdef  __GPIO_C__
S#define INTERFACE
N#else
N#define INTERFACE extern
N#endif
N
N#define PORT0 0
N#define PORT1 1
N
N#define GROUP0 0
N#define GROUP1 1
N
N#define GPIOIN 0
N#define GPIOOUT 1
N
N#define GPIO_SCANKEY_NULL 0
N#define GPIO_SCANKEY_PR BIT0
N#define GPIO_SCANKEY_PH BIT1
N#define GPIO_SCANKEY_RELEASE BIT2
N
N#define GPIO0_PR (0xFFFFFFFF)
N//#define GPIO1_PR (BIT20|BIT19|BIT15|BIT14|BIT13) //ori
N#define GPIO1_PR (BIT31|BIT28|BIT27|BIT26|BIT25)
N
Ntypedef enum _QIEStatusIndex_
N{   
N    QIE_STOP = 0x00,
N    QIE_FORWARD = 0x01,
N    QIE_BACKWARD = 0xFF,    
N    QIE_SAME = 0xAA  
N}QIEStatusIndex;
N
N
Ntypedef struct _LPC11Uxx_Gpio_Setting_
N{
N	U16 ButtonStatus; 
N	U16 ButtonEvent;	
N	U16 ButtonEventCount;	
N	U16 PreButtonEvent;	
N	U16 KeycodeTblIdx; 
N	U8  PreQIEStatus;
N}LPC11Uxx_Gpio_Setting;
N
N
NINTERFACE LPC11Uxx_Gpio_Setting g_GpioButtonEvent;
Xextern LPC11Uxx_Gpio_Setting g_GpioButtonEvent;
N
N
N
NINTERFACE void FLEX_INT0_IRQHandler(void);
Xextern void FLEX_INT0_IRQHandler(void);
NINTERFACE void FLEX_INT1_IRQHandler(void);
Xextern void FLEX_INT1_IRQHandler(void);
NINTERFACE void FLEX_INT2_IRQHandler(void);
Xextern void FLEX_INT2_IRQHandler(void);
NINTERFACE void FLEX_INT3_IRQHandler(void);
Xextern void FLEX_INT3_IRQHandler(void);
NINTERFACE void FLEX_INT4_IRQHandler(void);
Xextern void FLEX_INT4_IRQHandler(void);
NINTERFACE void FLEX_INT5_IRQHandler(void);
Xextern void FLEX_INT5_IRQHandler(void);
NINTERFACE void FLEX_INT6_IRQHandler(void);
Xextern void FLEX_INT6_IRQHandler(void);
NINTERFACE void FLEX_INT7_IRQHandler(void);
Xextern void FLEX_INT7_IRQHandler(void);
NINTERFACE void GINT0_IRQHandler(void);
Xextern void GINT0_IRQHandler(void);
NINTERFACE void GINT1_IRQHandler(void);
Xextern void GINT1_IRQHandler(void);
NINTERFACE void nsAPI_GPIO_Init( void );
Xextern void nsAPI_GPIO_Init( void );
NINTERFACE void NDrv_GPIO_SetBitValue(U32 portNum, U32 bitPosi, U32 bitVal );
Xextern void NDrv_GPIO_SetBitValue(U32 portNum, U32 bitPosi, U32 bitVal );
NINTERFACE RetU32 nsAPI_GPIO_GetPinValue( U8 portNum, U32 bitPosi);
Xextern RetU32 nsAPI_GPIO_GetPinValue( U8 portNum, U32 bitPosi);
NINTERFACE void NDrv_GPIO_SetDir( U32 portNum, U32 bitPosi, U32 dir );
Xextern void NDrv_GPIO_SetDir( U32 portNum, U32 bitPosi, U32 dir );
NINTERFACE void nsAPI_GPIO_LEDSetting(U8 uPort, U32 uPosition, U8 uValue);
Xextern void nsAPI_GPIO_LEDSetting(U8 uPort, U32 uPosition, U8 uValue);
NINTERFACE RetU8 nsAPI_GPIO_ScanButton(void);
Xextern RetU8 nsAPI_GPIO_ScanButton(void);
NINTERFACE void nsAPI_GPIO_MouseButtonMonitor(void);
Xextern void nsAPI_GPIO_MouseButtonMonitor(void);
NINTERFACE RetU16 nsAPI_GPIO_ChangingIndex(U16 u16Index);
Xextern RetU16 nsAPI_GPIO_ChangingIndex(U16 u16Index);
NINTERFACE U8 nsAPI_GPIO_Get_QIE(void);
Xextern U8 nsAPI_GPIO_Get_QIE(void);
NINTERFACE void nsAPI_GPIO_QIE_Monitor(void);
Xextern void nsAPI_GPIO_QIE_Monitor(void);
NINTERFACE void nsAPI_GPIO_Macrokey_Monitor(void);
Xextern void nsAPI_GPIO_Macrokey_Monitor(void);
N
N#undef INTERFACE
N#ifdef __cplusplus
S}
N#endif
N#endif /* end __GPIO_H */
N
L 7 "Src\Flash.c" 2
N#include "I2C.h"
L 1 ".\Inc\I2C.h" 1
N/*****************************************************************************
N *   i2c.h:  Header file for NXP LPC11xx Family Microprocessors
N *
N *   Copyright(C) 2006, NXP Semiconductor
N *   All rights reserved.
N *
N *   History
N *   2006.07.19  ver 1.00    Preliminary version, first Release
N *
N******************************************************************************/
N#ifndef __I2C_H__ 
N#define __I2C_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "Type.h"
N
N#ifdef  __I2C_C__
S#define INTERFACE
N#else
N#define INTERFACE extern
N#endif
N
N#if 0
S#define _DEBUG_I2C_(x) x
N#else
N#define _DEBUG_I2C_(x) 
N#endif
N
N#define I2CBUFSIZE 4
N#define MAX_TIMEOUT 0x00FFFFFF
N
N#define AT24C512_ADDR 0xA0
N#define READ_STATUS 0x01
N
N#define I2C_BUS_IDLE 0
N#define I2C_BUS_WRITE 1
N#define I2C_BUS_READ 2
N
N#define I2C_IDLE 0
N#define I2C_DEVICEARD 1
N#define I2C_FWORDARD 2
N#define I2C_SWORDARD 3
N#define I2C_RESTARTED 4
N#define I2C_REPEATED_START 5
N#define DATA_ACK 6
N#define DATA_NACK 7
N
N#define I2CONSET_I2EN BIT6/* I2C Control Set Register */
N#define I2CONSET_AA BIT2
N#define I2CONSET_SI BIT3
N#define I2CONSET_STO BIT4
N#define I2CONSET_STA BIT5
N
N#define I2CONCLR_AAC BIT2/* I2C Control clear Register */
N#define I2CONCLR_SIC BIT3
N#define I2CONCLR_STAC BIT5
N#define I2CONCLR_I2ENC BIT6
N
N#define I2C_SPEED 400000UL//400K
N#define I2SCLH_SCLH (SystemCoreClock / I2C_SPEED) / 2/* I2C SCL Duty Cycle High Reg */
N#define I2SCLL_SCLL I2SCLH_SCLH/* I2C SCL Duty Cycle Low Reg */
N
Ntypedef struct _LPC11Uxx_I2C_Setting_
N{	
N	U8 I2CMasterState;
N	U8 I2CDeviceAdr;
N	U8 I2CBusState;		
N	U8 I2CMasterBuffer[I2CBUFSIZE];
X	U8 I2CMasterBuffer[4];
N	U8 I2CSlaveBuffer[I2CBUFSIZE];
X	U8 I2CSlaveBuffer[4];
N	U8 I2CReadLength;
N	U8 I2CWriteLength;	
N	U8 RdIndex;
N	U8 WrIndex;	
N	U16 I2CWordAdr;
N} LPC11Uxx_I2C_Setting;
N
NINTERFACE LPC11Uxx_I2C_Setting g_I2C_Setting;
Xextern LPC11Uxx_I2C_Setting g_I2C_Setting;
N
NINTERFACE void I2C_IRQHandler(void);
Xextern void I2C_IRQHandler(void);
NINTERFACE void nsAPI_I2C_Init(void);
Xextern void nsAPI_I2C_Init(void);
NINTERFACE void NDrv_API_I2C_Stop(void);
Xextern void NDrv_API_I2C_Stop(void);
NINTERFACE void nsAPI_I2C_Write(void);
Xextern void nsAPI_I2C_Write(void);
NINTERFACE void nsAPI_I2C_Read(void);
Xextern void nsAPI_I2C_Read(void);
NINTERFACE void nsAPI_I2C_Write_Database(U16 u16Adr,U8 *pBuf);
Xextern void nsAPI_I2C_Write_Database(U16 u16Adr,U8 *pBuf);
NINTERFACE RetU8 nsAPI_I2C_Read_Database(U16 u16Adr);
Xextern RetU8 nsAPI_I2C_Read_Database(U16 u16Adr);
N
N#undef INTERFACE
N#ifdef __cplusplus
S}
N#endif
N#endif /* end __I2C_H */
N
L 8 "Src\Flash.c" 2
N//-----FlashrepareSec-----
N//***********************************************************************
N//* Function Name : FlashPrepareSec                                     *
N//* Parameters :                                                        *
N//  StartSecNum -- Start Sector Number                                  *
N//  EndSecNum -- End Sector Number                                      *
N//* Return : unsigned long -- Status Code                               *
N//* Description : This BL_command must be executed before               *
N//                executing "Copy RAM to Flash" or                      *
N//                "Erase Sector(s)" BL_command.                         *
N//***********************************************************************
NRetU32 msAPI_Flash_PrepareSec( U32 u32StartSecNum , U32 u32EndSecNum )
N{       
N	U32 u32Status;
N	U32 u32BootResult[3];
N	U32 u32BootCommand[5];     
N
N	if(u32EndSecNum < u32StartSecNum)
N	{     
N		u32Status = IAP_STA_INVALD_PARAM;
X		u32Status = 12;
N	}
N	else
N	{
N		u32BootCommand[0] = IAP_CMD_PREPARE_SECTORS;
X		u32BootCommand[0] = 50;
N		u32BootCommand[1] = u32StartSecNum;
N		u32BootCommand[2] = u32EndSecNum;
N
N		IAP_EXECUTE_CMD(u32BootCommand, u32BootResult);
X		((void (*)())(0x1FFF1FF1UL))(u32BootCommand, u32BootResult);
N
N		u32Status = u32BootResult[0];
N	}	
N	return u32Status;
N
N}
N//-----FlashCopyRAMToFlash-----
N//***********************************************************************
N//* Function Name : FlashCopyRAMToFlash                                 *
N//* Parameters :                                                        *
N//  dst -- Destination Flash address, should be a 256 byte boundary.    *
N//  src -- Source RAM address, should be a word boundary                *
N//  number -- 256 | 512 |1024 |4096                                     *
N//  Return : unsigned long -- Status Code                               *
N//* Description : This BL_command is used to program the flash memory.  *
N//***********************************************************************
N
NRetU32 msAPI_Flash_CopyRAM2Flash( U32 dst , U32 src , U16 number)
N{
N	U32 u32BootCommand[5],u32BootResult[3];
N
N	u32BootCommand[0] = IAP_CMD_COPY_RAM_TO_FLASH;
X	u32BootCommand[0] = 51;
N	u32BootCommand[1] = dst;  
N	u32BootCommand[2] = src;	 
N	u32BootCommand[3] = number;	 
N	u32BootCommand[4] = IAP_CLK;//0x00;
X	u32BootCommand[4] = ((((12000000UL))*(0x00000003+1)) /1000);
N	
N	IAP_EXECUTE_CMD(u32BootCommand, u32BootResult);	
X	((void (*)())(0x1FFF1FF1UL))(u32BootCommand, u32BootResult);	
N
N
N
N	return u32BootResult[0];
N}
N//-----FlashEraseSec-----
N//***********************************************************************
N//* Function Name : FlashEraseSec                                       *
N//* Parameters :                                                        *
N//  StartSecNum -- Start Sector Number                                  *
N//  EndSecNum -- End Sector Number                                      *
N//* Return : unsigned long -- Status Code                               *
N//* Description :                                                       *
N//  This BootComman is used to erase a sector or multiple sectors of    *
N//  on-chip Flash memory.                                               *
N//***********************************************************************
NRetU32 msAPI_Flash_EraseSec( U32 u32StartSecNum , U32 u32EndSecNum )
N{
N	U32 u32Status; 
N	U32 u32BootCommand[5],u32BootResult[3];
N
N	if (u32EndSecNum < u32StartSecNum)
N	{
N		u32Status = IAP_STA_INVALD_PARAM;
X		u32Status = 12;
N	}
N	else
N	{
N		u32BootCommand[0] = IAP_CMD_ERASE_SECTORS;
X		u32BootCommand[0] = 52;
N		u32BootCommand[1] = u32StartSecNum;
N		u32BootCommand[2] = u32EndSecNum;
N		u32BootCommand[3] = IAP_CLK;//0x00;
X		u32BootCommand[3] = ((((12000000UL))*(0x00000003+1)) /1000);
N
N		IAP_EXECUTE_CMD(u32BootCommand,u32BootResult);
X		((void (*)())(0x1FFF1FF1UL))(u32BootCommand, u32BootResult);
N		u32Status = u32BootResult[0];
N	}
N	return u32Status;
N}
N#if 0
S//-----FlashBlankChkSec-----
S//***********************************************************************
S//* Function Name : FlashBlankChkSec                                    *
S//* Parameters :                                                        *
S//  StartSecNum -- Start Sector Number                                  *
S//  EndSecNum -- End Sector Number                                      *
S//* Return : unsigned long -- Status Code                               *
S//* Description :                                                       *
S//  This BL_command is used to blank check a sector or                  *
S//  mutilple sectors of on-chip Flash memory.                           *
S//***********************************************************************
SU32 msAPI_Flash_BlankChkSec( U32 StartSecNum , U32 EndSecNum , U32 * pResult )
S{
S      U32 u32BootCommand[5],u32BootResult[4];
S
S	if (EndSecNum < StartSecNum)	
S	return IAP_STA_INVALD_PARAM;	
S	
S	u32BootCommand[0] =IAP_CMD_BLANK_CHECK_SECTORS ;
S	u32BootCommand[1] = StartSecNum ;
S	u32BootCommand[2] = EndSecNum ;
S	IAP_EXECUTE_CMD(u32BootCommand,u32BootResult) ;
S	if(u32BootResult[0] == IAP_STA_SECTOR_NOT_BLANK)
S	{
S		*pResult = u32BootResult[0];
S		*(pResult+1) = u32BootResult[1];
S	}
S	return u32BootResult[0] ;
S}
S//-----FlashReadParID-----
S//***********************************************************************
S//* Function Name : FlashReadParID                                      *
S//* Parameters :                                                        *
S//  * PartID --                                                         *
S//* Return : unsigned long -- Status Code                               *
S//* Description :                                                       *
S//  This BootComman is used to read the part identification number.     *
S//***********************************************************************
SU32 msAPI_Flash_ReadParID( U32 * PartID )
S{
S      U32 u32BootCommand[5],u32BootResult[4];
S
S	u32BootCommand[0] = IAP_CMD_READ_PART_ID;
S	
S	IAP_EXECUTE_CMD(u32BootCommand,u32BootResult);
S	*PartID = u32BootResult[1];
S	
S	return u32BootResult[0];
S}
S//-----FlashReadBootVer-----
S//***********************************************************************
S//* Function Name : FlashReadBootVer                                    *
S//*Parameters :                                                         *
S//  char * MajorVer                                                     *
S//  char * MinorVer                                                     *
S//* Return : unsigned long -- Status Code                               *
S//* Description:                                                        *
S//  This BootComman is used to read the boot code version number.       *
S//***********************************************************************
SU32 msAPI_Flash_Read_BootVer( U32 * MajorVer , U32 * MinorVer )
S{
S       U32 u32BootCommand[5],u32BootResult[4];
S
S	u32BootCommand[0] = IAP_CMD_READ_BOOT_ROM_VERSION ;
S	
S	IAP_EXECUTE_CMD(u32BootCommand,u32BootResult) ;
S	*MajorVer = (u32BootResult[1] & 0xff00)>>8 ;
S	*MinorVer = u32BootResult[1] & 0xff ;
S	
S	return u32BootResult[0] ;
S}
S//-----FlashCompare-----
S//***********************************************************************
S//* Function Name : FlashCompare                                        *
S//* Parameters :                                                        *
S//  dst -- Destination Flash address                                    *
S//  src -- Source RAM address                                           *
S//  number -- Should be in mutilple of 4                                *
S//* Return : unsigned long -- Status Code                               *
S//* Description :                                                       *
S//  This BootComman is used to compary the memory contents at two locations.
S//* NOTE :                                                              *
S//  Compary BootResult may not be correct when source or destination address contains
S//  any of the first 64 bytes starting from address zero.               *
S//  First 64 bytes can be re-mapped to RAM.                             *
S//***********************************************************************
SU32 msAPI_Flash_Compare( U32 dst , U32 src , U32 number , U32 *offset )
S{
S      U32 u32BootCommand[5],u32BootResult[4];
S
S	u32BootCommand[0] = IAP_CMD_COMPARE;
S	u32BootCommand[1] = dst ;
S	u32BootCommand[2] = src ;
S	u32BootCommand[3] = number;
S	
S	IAP_EXECUTE_CMD(u32BootCommand,u32BootResult);
S
S	if (u32BootResult[0] == IAP_STA_COMPARE_ERROR)
S	*offset = u32BootResult[1];
S	
S	return u32BootResult[0];
S}
S
Svoid msAPI_Flash_ReinvokeISP(void)
S{
S	U32 u32BootCommand[5],u32BootResult[4];
S
S	u32BootCommand[0] = IAP_CMD_REINVOKE_ISP;
S	IAP_EXECUTE_CMD(u32BootCommand , u32BootResult); 
S}
S
S void msAPI_Flash_Ram_Fill(U8 *u8src_prt,U32 u32Size)
S {
S	U16  i;
S	
S	for(i = 0; i < u32Size; i++)  
S	{
S		*u8src_prt ++= i;		 
S	}
S}
N#endif
N
Nvoid nsAPI_Flash_EraseAppSector(void)
N{
N	__disable_irq();
N       
N	if(msAPI_Flash_PrepareSec(AppCode_StartSector,AppCode_EndSector)== IAP_STA_CMD_SUCCESS)
X	if(msAPI_Flash_PrepareSec(3,7)== 0)
N	{
N		msAPI_Flash_EraseSec(AppCode_StartSector,AppCode_EndSector);
X		msAPI_Flash_EraseSec(3,7);
N		//if(msAPI_Flash_EraseSec(AppCode_StartSector,AppCode_EndSector)== IAP_STA_CMD_SUCCESS)
N		//{
N        //       _Flash_Debug_(xprintf("\r\n Erase AppSector is Ok",0));
N		//}
N	}
N	
N	__enable_irq();
N}
N
NBootLean nsAPI_Flash_IsUpgrade(void)
N{
N	U16 u16UpgradeID;
N
N	u16UpgradeID = _XRead(AppUpgrade_FlagAdr) << 8;
X	u16UpgradeID = _XRead((0x00007FFF -0xFF)) << 8;
N	u16UpgradeID |= _XRead(AppUpgrade_FlagAdr+0x01);
X	u16UpgradeID |= _XRead((0x00007FFF -0xFF)+0x01);
N
N	_Flash_Debug_(xprintf("\r\n IsUpgrade = %x ",u16UpgradeID));
X	;
N     
N	if(u16UpgradeID == AppReqUpgradeID)
X	if(u16UpgradeID == 0xAC)
N	return TRUE;
X	return (1);
N	else	
N	return FALSE;
X	return (0);
N}
N
N
N
N
NBootLean nsAPI_Flash_AppPresent(void)
N{
N	U8 u8AppUpgrade = TRUE;
X	U8 u8AppUpgrade = (1);
N	U16 u16AppID,u16AppupgradID;
N	
N	u16AppID	 = _XRead(AppID_Adr) << 8;
X	u16AppID	 = _XRead(0x00003100) << 8;
N	u16AppID|= _XRead(AppID_Adr+0x01) << 0;
X	u16AppID|= _XRead(0x00003100+0x01) << 0;
N
N	u16AppupgradID = _XRead(AppUpgrade_FlagAdr) << 8;
X	u16AppupgradID = _XRead((0x00007FFF -0xFF)) << 8;
N	u16AppupgradID |= _XRead(AppUpgrade_FlagAdr+0x01) << 0;
X	u16AppupgradID |= _XRead((0x00007FFF -0xFF)+0x01) << 0;
N 
N       _Flash_Debug_(xprintf("\r\n u16AppID = %x",u16AppID));
X       ;
N	  
N	if(u16AppID == AppID)
X	if(u16AppID == 0x5A5A)
N	{
N		if(nsAPI_Flash_IsUpgrade())
N		{
N			nsAPI_Flash_EraseAppSector(); 	   	
N		}
N		else	
N		u8AppUpgrade = FALSE;
X		u8AppUpgrade = (0);
N	}
N	else
N	{
N		if(u16AppID != 0xFFFF||u16AppupgradID == AppReqUpgradeID)
X		if(u16AppID != 0xFFFF||u16AppupgradID == 0xAC)
N		nsAPI_Flash_EraseAppSector();
N	}
N	_Flash_Debug_(xprintf("\r\n u8AppUpgrade = %x",u8AppUpgrade));
X	;
N	 
N	return u8AppUpgrade;
N}
N
N#if 0
Svoid nsAPI_Flash_Init(void)
S{
S	U16 i; 
S
S	for( i = 0; i < R2FBUFSIZE; i++)		
S	g_BootloaderSetting.Buf2Flash[i] = 0xFF;
S	
S	for(i = 0; i < 9;i++)
S	g_BootloaderSetting.CopyData2Buf[i] = 0; 
S
S	g_BootloaderSetting.AddrPoint256 = 0;
S	g_BootloaderSetting.AddrPointOffset = 0;
S	g_BootloaderSetting.BufOffset = 0;
S	
S}
N#endif 
N
Nvoid nsAPI_Flash_Jump2AppSector(void)
N{
N	typedef void Jump2BootloaderSector(void);
N	Jump2BootloaderSector *_Jump_ ;
N	_Jump_ = (Jump2BootloaderSector *)(AppCode_StartAdr|0x000000C1);
X	_Jump_ = (Jump2BootloaderSector *)(0x00003000|0x000000C1);
N	_Jump_(); 
N}
N
Nvoid nsAPI_Flash_BootBurn2Flash(void)
N{
N	U8 u8Length;
N	U16 i;/*,u16OffSet*/
N	u8Length =  8;//g_BootloaderSetting.CopyData2Buf[SIDX0];
N	
N	for(i = 0; i < u8Length; i++)
N	{
N		g_BootloaderSetting.Buf2Flash[g_BootloaderSetting.AddrPointOffset] = g_Main_Setting.OutReport[i];//g_BootloaderSetting.CopyData2Buf[SIDX1+i];	
N		g_BootloaderSetting.AddrPointOffset++; 			
N	}
N	//g_BootloaderSetting.AddrPointOffset = 257;
N	if(g_BootloaderSetting.AddrPointOffset >= 256)
N	{ 		
N		__disable_irq();
N		
N		if(msAPI_Flash_PrepareSec(AppCode_StartSector,AppCode_EndSector) == IAP_STA_CMD_SUCCESS)	//Start burn
X		if(msAPI_Flash_PrepareSec(3,7) == 0)	
N		{
N			if(msAPI_Flash_CopyRAM2Flash((U32)AppCode_StartAdr+(g_BootloaderSetting.AddrPoint256*256),(U32)g_BootloaderSetting.Buf2Flash,0x100) ==  IAP_STA_CMD_SUCCESS)
X			if(msAPI_Flash_CopyRAM2Flash((U32)0x00003000+(g_BootloaderSetting.AddrPoint256*256),(U32)g_BootloaderSetting.Buf2Flash,0x100) ==  0)
N			{   
N				__enable_irq();
N				for( i = 0; i < R2FBUFSIZE; i++)		
X				for( i = 0; i < 256; i++)		
N				g_BootloaderSetting.Buf2Flash[i] = 0xFF;	
N
N				g_BootloaderSetting.AddrPointOffset = 0;
N				g_BootloaderSetting.AddrPoint256++;					
N			}
N			//else{
N			
N			//_Flash_Debug_(xprintf("\r\n CopyRam2F is fault",0));	
N			//}
N		}
N		//else
N		// _Flash_Debug_(xprintf("\r\n PrepareSec is fault",0));	
N
N		__enable_irq();
N	}		
N	g_BootloaderSetting.BufOffset = 0;
N	
N}
N
Nvoid Write_In_Flash(){
N		U8 u8Length;
N	U16 i;/*,u16OffSet*/
N	u8Length =  8;//g_BootloaderSetting.CopyData2Buf[SIDX0];
N	
N	for(i = 0; i < u8Length; i++)
N	{
N		g_BootloaderSetting.Buf2Flash[g_BootloaderSetting.AddrPointOffset] = g_Main_Setting.OutReport[i];//g_BootloaderSetting.CopyData2Buf[SIDX1+i];	
N		g_BootloaderSetting.AddrPointOffset++; 			
N	}
N		//U8 j;
N		//j = 0x22;
N		//nsAPI_I2C_Write_Database(RM_BOOTLOADER_STATUS_ADR+1,&j,1);	//Update firmware Finish
N		__disable_irq();
N			   
N		if(msAPI_Flash_PrepareSec(AppCode_StartSector,AppCode_EndSector) == IAP_STA_CMD_SUCCESS)	//Start burn
X		if(msAPI_Flash_PrepareSec(3,7) == 0)	
N		{  			   
N			msAPI_Flash_CopyRAM2Flash((U32)AppCode_StartAdr+(g_BootloaderSetting.AddrPoint256*256),(U32)g_BootloaderSetting.Buf2Flash,0x100);
X			msAPI_Flash_CopyRAM2Flash((U32)0x00003000+(g_BootloaderSetting.AddrPoint256*256),(U32)g_BootloaderSetting.Buf2Flash,0x100);
N			//if(msAPI_Flash_CopyRAM2Flash((U32)AppCode_StartAdr+(g_BootloaderSetting.AddrPoint256*256),(U32)g_BootloaderSetting.Buf2Flash,0x100) ==  IAP_STA_CMD_SUCCESS)
N			//{   
N				__enable_irq();
N				//j = 0x22;
N				//nsAPI_I2C_Write_Database(RM_BOOTLOADER_STATUS_ADR+1,&j,1);	//Update firmware Finish
N				//for( i = 0; i < R2FBUFSIZE; i++)		
N				//g_BootloaderSetting.Buf2Flash[i] = 0xFF;	
N
N				//g_BootloaderSetting.AddrPointOffset = 0;
N				//g_BootloaderSetting.AddrPoint256++;					
N			//}
N			//else
N			//_Flash_Debug_(xprintf("\r\n CopyRam2F is fault",0));	
N		}
N		//else{
N		// _Flash_Debug_(xprintf("\r\n PrepareSec is fault",0));	
N		//}
N
N		__enable_irq(); 
N}
N
NRetU8 _XRead(U32 u32Adr )
N{
N   volatile U8 * u8Value;
N   u8Value = (volatile U8*)u32Adr;
N   return (*u8Value);
N}
N
N
Nvoid nsAPI_Flash_CopyData2Buf(U8 u8Lenth)
N{
N	U8 i;
N	g_BootloaderSetting.CopyData2Buf[SIDX0] = u8Lenth;
N	for(i = 0; i < u8Lenth; i++)
N	{
N		g_BootloaderSetting.CopyData2Buf[SIDX1+g_BootloaderSetting.BufOffset] = \
N		g_Main_Setting.OutReport[SIDX0+i];
X		g_BootloaderSetting.CopyData2Buf[SIDX1+g_BootloaderSetting.BufOffset] = 		g_Main_Setting.OutReport[SIDX0+i];
N           
N		g_BootloaderSetting.BufOffset++;
N	}	
N}
