L 1 "Src\system_LPC11Uxx.c"
N/******************************************************************************
N * @file     system_LPC11Uxx.c
N * @purpose  CMSIS Cortex-M3 Device Peripheral Access Layer Source File
N *           for the NXP LPC13xx Device Series
N * @version  V1.10
N * @date     24. November 2010
N *
N * @note
N * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#define __SYSTEM_LPC11Uxx_C__
N
N#include "system_LPC11Uxx.h"
L 1 ".\Inc\system_LPC11Uxx.h" 1
N/**************************************************************************//**
N * @file     system_LPC11Uxx.h
N * @brief    CMSIS Cortex-M0 Device Peripheral Access Layer Header File
N *           for the NXP LPC11Uxx Device Series
N * @version  V1.10
N * @date     24. November 2010
N *
N * @note
N * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#ifndef __SYSTEM_LPC11Uxx_H__
N#define __SYSTEM_LPC11Uxx_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "Type.h"
L 1 ".\Inc\Type.h" 1
N/****************************************************************************
N *   $Id:: type.h 6172 2011-01-13 18:22:51Z usb00423                        $
N *   Project: NXP LPC11xx software example
N *
N *   Description:
N *     This file contains different type definition.
N *
N ****************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N****************************************************************************/
N#ifndef __TYPE_H__
N#define __TYPE_H__
N
N/* exact-width signed integer types */
Ntypedef signed char int8_t;
Ntypedef int8_t S8;
Ntypedef S8 RetS8;
Ntypedef signed short int int16_t;
Ntypedef int16_t S16;
Ntypedef S16 RetS16;
Ntypedef signed int int32_t;
Ntypedef int32_t S32;
Ntypedef S32 RetS32;
Ntypedef signed __int64 int64_t;
Ntypedef int64_t S64;
Ntypedef S64 RetS64;
N/*exact-width unsigned integer types */
Ntypedef unsigned char uint8_t;
Ntypedef uint8_t U8;
Ntypedef U8 RetU8;
Ntypedef unsigned short int uint16_t;
Ntypedef uint16_t U16;
Ntypedef U16 RetU16;
Ntypedef unsigned int uint32_t;
Ntypedef uint32_t U32;
Ntypedef U32 RetU32;
Ntypedef unsigned __int64 uint64_t;
Ntypedef uint64_t U64;
Ntypedef U64 RetU64;
N
Ntypedef U8 Boolean;
N
N// Dennis 16/5/2014
Ntypedef union
N{
N	U16 w;
N	U8 b[2];
N}u16;
N
Ntypedef union
N{
N	S16 w;
N	S8 b[2];
N}s16;
N
N#define BIT0 (1 << 0)
N#define BIT1 (1 << 1)
N#define BIT2 (1 << 2)
N#define BIT3 (1 << 3)
N#define BIT4 (1 << 4)
N#define BIT5 (1 << 5)
N#define BIT6 (1 << 6)
N#define BIT7 (1 << 7)
N#define BIT8 (1 << 8)
N#define BIT9 (1 << 9)
N#define BIT10 (1 << 10)
N#define BIT11 (1 << 11)
N#define BIT12 (1 << 12)
N#define BIT13 (1 << 13)
N#define BIT14 (1 << 14)
N#define BIT15 (1 << 15)
N#define BIT16 (1 << 16)
N#define BIT17 (1 << 17)
N#define BIT18 (1 << 18)
N#define BIT19 (1 << 19)
N#define BIT20 (1 << 20)
N#define BIT21 (1 << 21)
N#define BIT22 (1 << 22)
N#define BIT23 (1 << 23)
N#define BIT24 (1 << 24)
N#define BIT25 (1 << 25)
N#define BIT26 (1 << 26)
N#define BIT27 (1 << 27)
N#define BIT28 (1 << 28)
N#define BIT29 (1 << 29)
N#define BIT30 (1 << 30)
N#define BIT31 (1UL << 31)
N
N#ifndef NULL
N#define NULL ((void *)0)
N#endif
N
N#ifndef FALSE
N#define FALSE (0)
N#endif
N
N#ifndef TRUE
N#define TRUE (1)
N#endif
N
N#ifndef LOW
N#define LOW (0)
N#endif
N
N#ifndef HIGH
N#define HIGH (1)
N#endif
N
N#ifndef EMPTY
N#define EMPTY (0xFF)
N#endif
N
N#endif  /* __TYPE_H__ */
L 34 ".\Inc\system_LPC11Uxx.h" 2
N
N#ifdef  __SYSTEM_LPC11Uxx_C__
N#define INTERFACE
N#else
S#define INTERFACE extern
N#endif
N
N#define SYSOSCCTRL_Val 0x00000000/* Reset: 0x000*/
N#define WDTOSCCTRL_Val 0x00000000/*Reset: 0x000*/
N#define SYSPLLCTRL_Val 0x00000023/*eset: 0x000*/
N#define SYSPLLCLKSEL_Val 0x00000001/*Reset: 0x000*/
N#define MAINCLKSEL_Val 0x00000003/*Reset: 0x000*/
N#define SYSAHBCLKDIV_Val 0x00000001/*Reset: 0x001*/
N#define USBPLLCTRL_Val 0x00000023/*Reset: 0x000*/
N#define USBPLLCLKSEL_Val 0x00000001/*Reset: 0x000*/
N#define USBCLKSEL_Val 0x00000000/*Reset: 0x000*/
N#define USBCLKDIV_Val 0x00000001/*Reset: 0x001*/
N/*----------------------------------------------------------------------------
N  Define clocks
N *----------------------------------------------------------------------------*/
N#define __XTAL (12000000UL)/* Oscillator frequency*/
N#define __SYS_OSC_CLK (__XTAL)/* Main oscillator frequency*/
N/*----------------------------------------------------------------------------
N  Check the register settings
N *----------------------------------------------------------------------------*/
N
NINTERFACE U32 SystemCoreClock;/*!< System Clock Frequency (Core Clock)*/
X U32 SystemCoreClock; 
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
NINTERFACE void nsAPI_System_Init(void);
X void nsAPI_System_Init(void);
N
N#undef INTERFACE
N#ifdef __cplusplus
S}
N#endif
N#endif /* __SYSTEM_LPC11Uxx_H */
L 27 "Src\system_LPC11Uxx.c" 2
N#include "LPC11Uxx.h"
L 1 ".\Inc\LPC11Uxx.h" 1
N
N/****************************************************************************************************//**
N * @file     LPC11Uxx.h
N *
N *
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File for
N *           default LPC11Uxx Device Series
N *
N * @version  V0.1
N * @date     21. March 2011
N *
N * @note     Generated with SFDGen V2.6 Build 3j (beta) on Thursday, 17.03.2011 13:19:45
N *
N *           from CMSIS SVD File 'LPC11U1x_svd.xml' Version 0.1,
N *           created on Wednesday, 16.03.2011 20:30:42, last modified on Thursday, 17.03.2011 20:19:40
N *
N *******************************************************************************************************/
N
N
N
N/** @addtogroup NXP
N  * @{
N  */
N
N/** @addtogroup LPC11Uxx
N  * @{
N  */
N
N#ifndef __LPC11UXX_H__
N#define __LPC11UXX_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif 
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #pragma anon_unions
N#endif
N
N /* Interrupt Number Definition */
N
Ntypedef enum {
N// -------------------------  Cortex-M0 Processor Exceptions Numbers  -----------------------------
N  Reset_IRQn                        = -15,  /*!<   1  Reset Vector, invoked on Power up and warm reset */
N  NonMaskableInt_IRQn               = -14,  /*!<   2  Non maskable Interrupt, cannot be stopped or preempted */
N  HardFault_IRQn                    = -13,  /*!<   3  Hard Fault, all classes of Fault */
N  SVCall_IRQn                       = -5,   /*!<  11  System Service Call via SVC instruction */
N  DebugMonitor_IRQn                 = -4,   /*!<  12  Debug Monitor                    */
N  PendSV_IRQn                       = -2,   /*!<  14  Pendable request for system service */
N  SysTick_IRQn                      = -1,   /*!<  15  System Tick Timer                */
N// ---------------------------  LPC11Uxx Specific Interrupt Numbers  ------------------------------
NFLEX_INT0_IRQn                = 0,        /*!< All I/O pins can be routed to below 8 interrupts. */
N  FLEX_INT1_IRQn                = 1,
N  FLEX_INT2_IRQn                = 2,
N  FLEX_INT3_IRQn                = 3,
N  FLEX_INT4_IRQn                = 4,   
N  FLEX_INT5_IRQn                = 5,        
N  FLEX_INT6_IRQn                = 6,        
N  FLEX_INT7_IRQn                = 7,        
N  GINT0_IRQn                    = 8,        /*!< Grouped Interrupt 0                              */
N  GINT1_IRQn                    = 9,        /*!< Grouped Interrupt 1                              */
N  Reserved0_IRQn                = 10,       /*!< Reserved Interrupt                               */
N  Reserved1_IRQn                = 11,       
N  Reserved2_IRQn                = 12,       
N  Reserved3_IRQn                = 13,       
N  SSP1_IRQn                     = 14,       /*!< SSP1 Interrupt                                   */
N  I2C_IRQn                      = 15,       /*!< I2C Interrupt                                    */
N  TIMER_16_0_IRQn               = 16,       /*!< 16-bit Timer0 Interrupt                          */
N  TIMER_16_1_IRQn               = 17,       /*!< 16-bit Timer1 Interrupt                          */
N  TIMER_32_0_IRQn               = 18,       /*!< 32-bit Timer0 Interrupt                          */
N  TIMER_32_1_IRQn               = 19,       /*!< 32-bit Timer1 Interrupt                          */
N  SSP0_IRQn                     = 20,       /*!< SSP0 Interrupt                                   */
N  UART_IRQn                     = 21,       /*!< UART Interrupt                                   */
N  USB_IRQn                      = 22,       /*!< USB IRQ Interrupt                                */
N  USB_FIQn                      = 23,       /*!< USB FIQ Interrupt                                */
N  ADC_IRQn                      = 24,       /*!< A/D Converter Interrupt                          */
N  WDT_IRQn                      = 25,       /*!< Watchdog timer Interrupt                         */  
N  BOD_IRQn                      = 26,       /*!< Brown Out Detect(BOD) Interrupt                  */
N  FMC_IRQn                      = 27,       /*!< Flash Memory Controller Interrupt                */
N  Reserved4_IRQn                = 28,       /*!< Reserved Interrupt                               */
N  Reserved5_IRQn                = 29,       /*!< Reserved Interrupt                               */
N  USBWakeup_IRQn                = 30,       /*!< USB wakeup Interrupt                             */
N  Reserved6_IRQn                = 31,       /*!< Reserved Interrupt                               */
N} IRQn_Type;
N
N
N/** @addtogroup Configuration_of_CMSIS
N  * @{
N  */
N
N/* Processor and Core Peripheral Section */ /* Configuration of the Cortex-M0 Processor and Core Peripherals */
N
N#define __MPU_PRESENT             0         /*!< MPU present or not                    */
N#define __NVIC_PRIO_BITS          3         /*!< Number of Bits used for Priority Levels */
N#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used */
N/** @} */ /* End of group Configuration_of_CMSIS */
N
N#include "core_cm0.h"                       /*!< Cortex-M0 processor and core peripherals */
L 1 ".\Inc\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V2.01
N * @date     06. December 2010
N *
N * @note
N * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )                   
X#if 0L                   
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N
N/** \mainpage CMSIS Cortex-M0
N   
N  This documentation describes the CMSIS Cortex-M Core Peripheral Access Layer.
N  It consists of:
N 
N     - Cortex-M Core Register Definitions
N     - Cortex-M functions
N     - Cortex-M instructions
N 
N  The CMSIS Cortex-M0 Core Peripheral Access Layer contains C and assembly functions that ease 
N  access to the Cortex-M Core
N */ 
N
N/** \defgroup CMSIS_LintCinfiguration CMSIS Lint Configuration
N  List of Lint messages which will be suppressed and not shown:
N    - not yet checked
N  .
N  Note:  To re-enable a Message, insert a space before 'lint' *
N 
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \defgroup CMSIS_core_definitions CMSIS Core Definitions
N  This file defines all structures and symbols for CMSIS core:
N   - CMSIS version number
N   - Cortex-M core 
N   - Cortex-M core Revision Number
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x02)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (0x00)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | __CM0_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x00)                                                       /*!< Cortex core                    */
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S
N#endif
N
N#include <stdint.h>                      /*!< standard types definitions                      */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 95 ".\Inc\core_cm0.h" 2
N#include "core_cmInstr.h"                /*!< Core Instruction Access                         */
L 1 ".\Inc\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V2.01
N * @date     06. December 2010
N *
N * @note
N * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H__
N#define __CORE_CMINSTR_H__
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if defined ( __CC_ARM   ) /*------------------ RealView Compiler ----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor, 
N    so that all instructions following the ISB are fetched from cache or 
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier. 
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before 
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#if (__ARMCC_VERSION < 400677)
X#if (5060960 < 400677)
Sextern uint32_t __REV16(uint32_t value);
N#else  /* (__ARMCC_VERSION >= 400677)  */
Nstatic __INLINE __ASM uint32_t __REV16(uint32_t value)
Xstatic __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif /* __ARMCC_VERSION  */ 
N
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#if (__ARMCC_VERSION < 400677)
X#if (5060960 < 400677)
Sextern int32_t __REVSH(int32_t value);
N#else  /* (__ARMCC_VERSION >= 400677)  */
Nstatic __INLINE __ASM int32_t __REVSH(int32_t value)
Xstatic __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif /* __ARMCC_VERSION  */ 
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#if (__ARMCC_VERSION < 400000)
Sextern void __CLREX(void);
S#else  /* (__ARMCC_VERSION >= 400000)  */
S#define __CLREX                           __clrex
S#endif /* __ARMCC_VERSION  */ 
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz 
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif (defined (__ICCARM__)) /*---------------- ICC Compiler ---------------------*/
S/* IAR iccarm specific functions */
S
S#include <intrinsics.h>                     /* IAR Intrinsics   */
S
S#pragma diag_suppress=Pe940
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S#define __NOP                           __no_operation
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
Sstatic __INLINE  void __WFI(void)
S{
S  __ASM ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
Sstatic __INLINE  void __WFE(void)
S{
S  __ASM ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
Sstatic __INLINE  void __SEV(void)
S{
S  __ASM ("sev");
S}
S
S
S/* intrinsic     void __ISB(void)            (see intrinsics.h) */
S/* intrinsic     void __DSB(void)            (see intrinsics.h) */
S/* intrinsic     void __DMB(void)            (see intrinsics.h) */
S/* intrinsic uint32_t __REV(uint32_t value)  (see intrinsics.h) */
S/* intrinsic          __SSAT                 (see intrinsics.h) */
S/* intrinsic          __USAT                 (see intrinsics.h) */
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
Sstatic uint32_t __REV16(uint32_t value)
S{
S  __ASM("rev16 r0, r0");
S}
S
S
S/* intrinsic uint32_t __REVSH(uint32_t value)  (see intrinsics.h */
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
Sstatic uint32_t __RBIT(uint32_t value)
S{
S  __ASM("rbit r0, r0");
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
Sstatic uint8_t __LDREXB(volatile uint8_t *addr)
S{
S  __ASM("ldrexb r0, [r0]");
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
Sstatic uint16_t __LDREXH(volatile uint16_t *addr)
S{
S  __ASM("ldrexh r0, [r0]");
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S/* intrinsic unsigned long __LDREX(unsigned long *)  (see intrinsics.h) */
Sstatic uint32_t __LDREXW(volatile uint32_t *addr)
S{
S  __ASM("ldrex r0, [r0]");
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
Sstatic uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S  __ASM("strexb r0, r0, [r1]");
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
Sstatic uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S  __ASM("strexh r0, r0, [r1]");
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S/* intrinsic unsigned long __STREX(unsigned long, unsigned long)  (see intrinsics.h )*/
Sstatic uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S  __ASM("strex r0, r0, [r1]");
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
Sstatic __INLINE void __CLREX(void)
S{
S  __ASM ("clrex");
S}
S
S/* intrinsic   unsigned char __CLZ( unsigned long )      (see intrinsics.h) */
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S#pragma diag_default=Pe940
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor, 
S    so that all instructions following the ISB are fetched from cache or 
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier. 
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before 
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S  
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S  
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S  
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) static __INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S  
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) static __INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S  
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S  
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S  
S   __ASM volatile ("strexb %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S  
S   __ASM volatile ("strexh %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S  
S   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) static __INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S  
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif (defined (__TASKING__)) /*--------------- TASKING Compiler -----------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H__ */
L 96 ".\Inc\core_cm0.h" 2
N#include "core_cmFunc.h"                 /*!< Core Function Access                            */
L 1 ".\Inc\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V2.01
N * @date     06. December 2010
N *
N * @note
N * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H__
N#define __CORE_CMFUNC_H__
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface   
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if defined ( __CC_ARM   ) /*------------------ RealView Compiler ----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          uint32_t __get_CONTROL(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          void __set_CONTROL(uint32_t control);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get ISPR Register
N
N    This function returns the content of the ISPR Register.
N
N    \return               ISPR Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          uint32_t __get_IPSR(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          uint32_t __get_APSR(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          uint32_t __get_xPSR(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          uint32_t __get_PSP(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          void __set_PSP(uint32_t topOfProcStack);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          uint32_t __get_MSP(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          void __set_MSP(uint32_t topOfMainStack);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          uint32_t __get_PRIMASK(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N#endif /*  __ARMCC_VERSION  */ 
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5060960 <  400000)
Sextern          void __set_PRIMASK(uint32_t priMask);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N#endif /*  __ARMCC_VERSION  */ 
N 
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S#if       (__ARMCC_VERSION <  400000)
Sextern          uint32_t __get_BASEPRI(void);
S#else  /* (__ARMCC_VERSION >= 400000) */
Sstatic __INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S#endif /*  __ARMCC_VERSION  */ 
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S#if       (__ARMCC_VERSION <  400000)
Sextern          void __set_BASEPRI(uint32_t basePri);
S#else  /* (__ARMCC_VERSION >= 400000) */
Sstatic __INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S#endif /*  __ARMCC_VERSION  */ 
S 
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S#if       (__ARMCC_VERSION <  400000)
Sextern          uint32_t __get_FAULTMASK(void);
S#else  /* (__ARMCC_VERSION >= 400000) */
Sstatic __INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S#endif /*  __ARMCC_VERSION  */ 
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S#if       (__ARMCC_VERSION <  400000)
Sextern          void __set_FAULTMASK(uint32_t faultMask);
S#else  /* (__ARMCC_VERSION >= 400000) */
Sstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & 1);
S}
S#endif /*  __ARMCC_VERSION  */ 
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
Sstatic __INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
Sstatic __INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N #elif (defined (__ICCARM__)) /*---------------- ICC Compiler ---------------------*/
S/* IAR iccarm specific functions */
S
S#if defined (__ICCARM__)
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
S#endif
S
S#pragma diag_suppress=Pe940
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S#define __enable_irq                              __enable_interrupt
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S#define __disable_irq                             __disable_interrupt
S
S
S/* intrinsic unsigned long __get_CONTROL( void ); (see intrinsic.h) */
S/* intrinsic void __set_CONTROL( unsigned long ); (see intrinsic.h) */
S
S
S/** \brief  Get ISPR Register
S
S    This function returns the content of the ISPR Register.
S
S    \return               ISPR Register value
S */
Sstatic uint32_t __get_IPSR(void)
S{
S  __ASM("mrs r0, ipsr");
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
Sstatic uint32_t __get_APSR(void)
S{
S  __ASM("mrs r0, apsr");
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
Sstatic uint32_t __get_xPSR(void)
S{
S  __ASM("mrs r0, psr");           // assembler does not know "xpsr"
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
Sstatic uint32_t __get_PSP(void)
S{
S  __ASM("mrs r0, psp");
S}
S 
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
Sstatic void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM("msr psp, r0");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
Sstatic uint32_t __get_MSP(void)
S{
S  __ASM("mrs r0, msp");
S}
S 
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
Sstatic void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM("msr msp, r0");
S}
S 
S
S/* intrinsic unsigned long __get_PRIMASK( void ); (see intrinsic.h) */
S/* intrinsic void __set_PRIMASK( unsigned long ); (see intrinsic.h) */
S 
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
Sstatic __INLINE void __enable_fault_irq(void)
S{
S  __ASM ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
Sstatic __INLINE void __disable_fault_irq(void)
S{
S  __ASM ("cpsid f");
S}
S
S
S/* intrinsic unsigned long __get_BASEPRI( void );   (see intrinsic.h) */
S/* intrinsic void __set_BASEPRI( unsigned long );   (see intrinsic.h) */
S/* intrinsic unsigned long __get_FAULTMASK( void ); (see intrinsic.h) */
S/* intrinsic void __set_FAULTMASK(unsigned long);   (see intrinsic.h) */
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
Sstatic uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1)
S  __ASM("vmrs r0, fpscr"); 
S#else
S  return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
Sstatic void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1)
S  __ASM("vmsr fpscr, r0");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S#pragma diag_default=Pe940
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get ISPR Register
S
S    This function returns the content of the ISPR Register.
S
S    \return               ISPR Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S 
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S 
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S 
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S  
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S  
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1)
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1)
S  __ASM volatile ("MSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif (defined (__TASKING__)) /*--------------- TASKING Compiler -----------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N#endif /* __CORE_CMFUNC_H__ */
L 97 ".\Inc\core_cm0.h" 2
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N/* IO definitions (access restrictions to peripheral registers) */
N#ifdef __cplusplus
S  #define     __I     volatile           /*!< defines 'read only' permissions                 */
N#else
N  #define     __I     volatile const     /*!< defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< defines 'write only' permissions                */
N#define     __IO    volatile             /*!< defines 'read / write' permissions              */
N
N/*@} end of group CMSIS_core_definitions */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N/** \defgroup CMSIS_core_register CMSIS Core Register
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N*/
N
N/** \ingroup  CMSIS_core_register   
N    \defgroup CMSIS_CORE CMSIS Core
N  Type definitions for the Cortex-M Core Registers
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */ 
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup  CMSIS_core_register   
N    \defgroup CMSIS_NVIC CMSIS NVIC
N  Type definitions for the Cortex-M NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IPR[8];                  /*!< Offset: 0x3EC (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IPR[8];                   
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register   
N    \defgroup CMSIS_SCB CMSIS SCB
N  Type definitions for the Cortex-M System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPU ID Base Register                                  */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control State Register                      */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;                                      
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt / Reset Control Register        */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;                                      
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N       uint32_t RESERVED2[2];                                   
N  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                     
N} SCB_Type;                                                
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register   
N    \defgroup CMSIS_SysTick CMSIS SysTick
N  Type definitions for the Cortex-M System Timer Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register   
N    \defgroup CMSIS_CoreDebug CMSIS Core Debug
N  Type definitions for the Cortex-M Core Debug Registers
N  @{
N */
N
N/** \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                    
N  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                    
N  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                    
N  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                    
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_DWTENA_Pos         24                                             /*!< CoreDebug DEMCR: DWTENA Position */
N#define CoreDebug_DEMCR_DWTENA_Msk         (1UL << CoreDebug_DEMCR_DWTENA_Pos)            /*!< CoreDebug DEMCR: DWTENA Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup  CMSIS_core_register   
N  @{
N */
N 
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address           */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct          */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct      */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct         */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct   */
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface CMSIS Core Function Interface
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface   
N    \defgroup CMSIS_Core_NVICFunctions CMSIS Core NVIC Functions
N  @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    This function enables a device specific interupt in the NVIC interrupt controller.
N    The interrupt number cannot be a negative value. 
N
N    \param [in]      IRQn  Number of the external interrupt to enable
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    This function disables a device specific interupt in the NVIC interrupt controller.
N    The interrupt number cannot be a negative value. 
N
N    \param [in]      IRQn  Number of the external interrupt to disable
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    This function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt. 
N
N    \param [in]      IRQn  Number of the interrupt for get pending
N    \return             0  Interrupt status is not pending
N    \return             1  Interrupt status is pending
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    This function sets the pending bit for the specified interrupt. 
N    The interrupt number cannot be a negative value.
N
N    \param [in]      IRQn  Number of the interrupt for set pending
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    This function clears the pending bit for the specified interrupt. 
N    The interrupt number cannot be a negative value.
N
N    \param [in]      IRQn  Number of the interrupt for clear pending
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    This function sets the priority for the specified interrupt. The interrupt 
N    number can be positive to specify an external (device specific) 
N    interrupt, or negative to specify an internal (core) interrupt.
N
N    Note: The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Number of the interrupt for set priority
N    \param [in]  priority  Priority to set
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) | 
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) | 
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 3)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IPR[_IP_IDX(IRQn)] = (NVIC->IPR[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->IPR[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->IPR[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 3)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    This function reads the priority for the specified interrupt. The interrupt 
N    number can be positive to specify an external (device specific) 
N    interrupt, or negative to specify an internal (core) interrupt.
N
N    The returned priority value is automatically aligned to the implemented
N    priority bits of the microcontroller.
N
N    \param [in]   IRQn  Number of the interrupt for get priority
N    \return             Interrupt Priority
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 3)));  }  
N  else {
N    return((uint32_t)((NVIC->IPR[_IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL))->IPR[( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 3)));  }  
N}
N
N
N/** \brief  System Reset
N
N    This function initiate a system reset request to reset the MCU.
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */              
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      | 
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL))->AIRCR  = ((0x5FA << 16)      | 
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */              
X  __dsb(0xF);                                                                    
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface   
N    \defgroup CMSIS_Core_SysTickFunctions CMSIS Core SysTick Functions
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    This function initialises the system tick timer and its interrupt and start the system tick timer.
N    Counter is in free running mode to generate periodical interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{ 
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFUL << 0))  return (1);             
N                                                               
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL))->LOAD  = (ticks & (0xFFFFFFUL << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<3) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL))->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | 
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL))->CTRL  = (1UL << 2) | 
N                   SysTick_CTRL_TICKINT_Msk   | 
X                   (1UL << 1)   | 
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
N
N/*lint -restore */
L 100 ".\Inc\LPC11Uxx.h" 2
N#include "system_LPC11Uxx.h"                /*!< LPC11Uxx System                       */
N
N/** @addtogroup Device_Peripheral_Registers
N  * @{
N  */
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                          I2C                                         -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x I2C-bus controller Modification date=3/16/2011 Major revision=0 Minor revision=3  (I2C)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40000000) I2C Structure          */
N  __IO uint32_t CONSET;                     /*!< (@ 0x40000000) I2C Control Set Register */
X  volatile uint32_t CONSET;                      
N  __I  uint32_t STAT;                       /*!< (@ 0x40000004) I2C Status Register */
X  volatile const  uint32_t STAT;                        
N  __IO uint32_t DAT;                        /*!< (@ 0x40000008) I2C Data Register.  */
X  volatile uint32_t DAT;                         
N  __IO uint32_t ADR0;                       /*!< (@ 0x4000000C) I2C Slave Address Register 0 */
X  volatile uint32_t ADR0;                        
N  __IO uint32_t SCLH;                       /*!< (@ 0x40000010) SCH Duty Cycle Register High Half Word */
X  volatile uint32_t SCLH;                        
N  __IO uint32_t SCLL;                       /*!< (@ 0x40000014) SCL Duty Cycle Register Low Half Word */
X  volatile uint32_t SCLL;                        
N  __IO uint32_t CONCLR;                     /*!< (@ 0x40000018) I2C Control Clear Register*/
X  volatile uint32_t CONCLR;                      
N  __IO uint32_t MMCTRL;                     /*!< (@ 0x4000001C) Monitor mode control register*/
X  volatile uint32_t MMCTRL;                      
N  __IO uint32_t ADR1;                       /*!< (@ 0x40000020) I2C Slave Address Register 1*/
X  volatile uint32_t ADR1;                        
N  __IO uint32_t ADR2;                       /*!< (@ 0x40000024) I2C Slave Address Register 2*/
X  volatile uint32_t ADR2;                        
N  __IO uint32_t ADR3;                       /*!< (@ 0x40000028) I2C Slave Address Register 3*/
X  volatile uint32_t ADR3;                        
N  __I  uint32_t DATA_BUFFER;                /*!< (@ 0x4000002C) Data buffer register */
X  volatile const  uint32_t DATA_BUFFER;                 
Nunion{
N  __IO uint32_t MASK[4];                    /*!< (@ 0x40000030) I2C Slave address mask register */
X  volatile uint32_t MASK[4];                     
N  struct{
N  __IO uint32_t MASK0;
X  volatile uint32_t MASK0;
N  __IO uint32_t MASK1;
X  volatile uint32_t MASK1;
N  __IO uint32_t MASK2;
X  volatile uint32_t MASK2;
N  __IO uint32_t MASK3;
X  volatile uint32_t MASK3;
N  };
N  };
N} LPC_I2C_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                         WWDT                                         -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x Windowed Watchdog Timer (WWDT) Modification date=3/16/2011 Major revision=0 Minor revision=3  (WWDT)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40004000) WWDT Structure         */
N  __IO uint32_t MOD;                        /*!< (@ 0x40004000) Watchdog mode register*/
X  volatile uint32_t MOD;                         
N  __IO uint32_t TC;                         /*!< (@ 0x40004004) Watchdog timer constant register */
X  volatile uint32_t TC;                          
N  __IO uint32_t FEED;                       /*!< (@ 0x40004008) Watchdog feed sequence register */
X  volatile uint32_t FEED;                        
N  __I  uint32_t TV;                         /*!< (@ 0x4000400C) Watchdog timer value register */
X  volatile const  uint32_t TV;                          
N  __IO uint32_t CLKSEL;                     /*!< (@ 0x40004010) Watchdog clock select register. */
X  volatile uint32_t CLKSEL;                      
N  __IO uint32_t WARNINT;                    /*!< (@ 0x40004014) Watchdog Warning Interrupt compare value. */
X  volatile uint32_t WARNINT;                     
N  __IO uint32_t WINDOW;                     /*!< (@ 0x40004018) Watchdog Window compare value. */
X  volatile uint32_t WINDOW;                      
N} LPC_WWDT_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                         USART                                        -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x USART Modification date=3/16/2011 Major revision=0 Minor revision=3  (USART)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40008000) USART Structure        */
N  
N  union {
N    __IO uint32_t DLL;                      /*!< (@ 0x40008000) Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1) */
X    volatile uint32_t DLL;                       
N    __O  uint32_t THR;                      /*!< (@ 0x40008000) Transmit Holding Register. The next character to be transmitted is written here. (DLAB=0) */
X    volatile  uint32_t THR;                       
N    __I  uint32_t RBR;                      /*!< (@ 0x40008000) Receiver Buffer Register. Contains the next received character to be read. (DLAB=0) */
X    volatile const  uint32_t RBR;                       
N  };
N  
N  union {
N    __IO uint32_t IER;                      /*!< (@ 0x40008004) Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential USART interrupts. (DLAB=0) */
X    volatile uint32_t IER;                       
N    __IO uint32_t DLM;                      /*!< (@ 0x40008004) Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1) */
X    volatile uint32_t DLM;                       
N  };
N  
N  union {
N    __O  uint32_t FCR;                      /*!< (@ 0x40008008) FIFO Control Register. Controls USART FIFO usage and modes. */
X    volatile  uint32_t FCR;                       
N    __I  uint32_t IIR;                      /*!< (@ 0x40008008) Interrupt ID Register. Identifies which interrupt(s) are pending. */
X    volatile const  uint32_t IIR;                       
N  };
N  __IO uint32_t LCR;                        /*!< (@ 0x4000800C) Line Control Register. Contains controls for frame formatting and break generation. */
X  volatile uint32_t LCR;                         
N  __IO uint32_t MCR;                        /*!< (@ 0x40008010) Modem Control Register. */
X  volatile uint32_t MCR;                         
N  __I  uint32_t LSR;                        /*!< (@ 0x40008014) Line Status Register. Contains flags for transmit and receive status, including line errors. */
X  volatile const  uint32_t LSR;                         
N  __I  uint32_t MSR;                        /*!< (@ 0x40008018) Modem Status Register. */
X  volatile const  uint32_t MSR;                         
N  __IO uint32_t SCR;                        /*!< (@ 0x4000801C) Scratch Pad Register. Eight-bit temporary storage for software. */
X  volatile uint32_t SCR;                         
N  __IO uint32_t ACR;                        /*!< (@ 0x40008020) Auto-baud Control Register. Contains controls for the auto-baud feature. */
X  volatile uint32_t ACR;                         
N  __IO uint32_t ICR;                        /*!< (@ 0x40008024) IrDA Control Register. Enables and configures the IrDA (remote control) mode. */
X  volatile uint32_t ICR;                         
N  __IO uint32_t FDR;                        /*!< (@ 0x40008028) Fractional Divider Register. Generates a clock input for the baud rate divider. */
X  volatile uint32_t FDR;                         
N  __IO uint32_t OSR;                        /*!< (@ 0x4000802C) Oversampling Register. Controls the degree of oversampling during each bit time. */
X  volatile uint32_t OSR;                         
N  __IO uint32_t TER;                        /*!< (@ 0x40008030) Transmit Enable Register. Turns off USART transmitter for use with software flow control. */
X  volatile uint32_t TER;                         
N  __I  uint32_t RESERVED0[3];
X  volatile const  uint32_t RESERVED0[3];
N  __IO uint32_t HDEN;                       /*!< (@ 0x40008040) Half duplex enable register. */
X  volatile uint32_t HDEN;                        
N  __I  uint32_t RESERVED1;
X  volatile const  uint32_t RESERVED1;
N  __IO uint32_t SCICTRL;                    /*!< (@ 0x40008048) Smart Card Interface Control register. Enables and configures the Smart Card Interface feature. */
X  volatile uint32_t SCICTRL;                     
N  __IO uint32_t RS485CTRL;                  /*!< (@ 0x4000804C) RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes. */
X  volatile uint32_t RS485CTRL;                   
N  __IO uint32_t RS485ADRMATCH;              /*!< (@ 0x40008050) RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode. */
X  volatile uint32_t RS485ADRMATCH;               
N  __IO uint32_t RS485DLY;                   /*!< (@ 0x40008054) RS-485/EIA-485 direction control delay. */
X  volatile uint32_t RS485DLY;                    
N  __IO uint32_t SYNCCTRL; 
X  volatile uint32_t SYNCCTRL; 
N} LPC_USART_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                        Timer                                       -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x 32-bitcounter/timers CT32B0/1 Modification date=3/16/2011 Major revision=0 Minor revision=3  
N  */
N
Ntypedef struct {                            /*!< (@ 0x40014000) CT32B0 Structure        */
N  __IO uint32_t IR;                         /*!< (@ 0x40014000) Interrupt Register      */
X  volatile uint32_t IR;                          
N  __IO uint32_t TCR;                        /*!< (@ 0x40014004) Timer Control Register  */
X  volatile uint32_t TCR;                         
N  __IO uint32_t TC;                         /*!< (@ 0x40014008) Timer Counter 		*/
X  volatile uint32_t TC;                          
N  __IO uint32_t PR;                         /*!< (@ 0x4001400C) Prescale Register  	*/
X  volatile uint32_t PR;                          
N  __IO uint32_t PC;                         /*!< (@ 0x40014010) Prescale Counter	 */
X  volatile uint32_t PC;                          
N  __IO uint32_t MCR;                        /*!< (@ 0x40014014) Match Control Register */
X  volatile uint32_t MCR;                         
N  union {
N  __IO uint32_t MR[4];                      /*!< (@ 0x40014018) Match Register */
X  volatile uint32_t MR[4];                       
N  struct{
N  __IO uint32_t MR0;                        /*!< (@ 0x40018018) Match Register. MR0 */
X  volatile uint32_t MR0;                         
N  __IO uint32_t MR1;                        /*!< (@ 0x4001801C) Match Register. MR1 */
X  volatile uint32_t MR1;                         
N  __IO uint32_t MR2;                        /*!< (@ 0x40018020) Match Register. MR2 */
X  volatile uint32_t MR2;                         
N  __IO uint32_t MR3;                        /*!< (@ 0x40018024) Match Register. MR3 */
X  volatile uint32_t MR3;                         
N  };
N  };
N  __IO uint32_t CCR;                        /*!< (@ 0x40014028) Capture Control Register */
X  volatile uint32_t CCR;                         
N  union{
N  __I  uint32_t CR[4];                      /*!< (@ 0x4001402C) Capture Register  */
X  volatile const  uint32_t CR[4];                       
N    struct{
N  __I  uint32_t CR0;			    /*!< (@ 0x4001802C) Capture Register. CR 0 */
X  volatile const  uint32_t CR0;			     
N  __I  uint32_t CR1;			    /*!< (@ 0x40018030) Capture Register. CR 1 */
X  volatile const  uint32_t CR1;			     
N  __I  uint32_t CR2;			    /*!< (@ 0x40018034) Capture Register. CR 2 */
X  volatile const  uint32_t CR2;			     
N  __I  uint32_t CR3;			    /*!< (@ 0x40018038) Capture Register. CR 3 */
X  volatile const  uint32_t CR3;			     
N  };
N  };
N__IO uint32_t EMR;                        /*!< (@ 0x4001403C) External Match Register */
Xvolatile uint32_t EMR;                         
N  __I  uint32_t RESERVED0[12];
X  volatile const  uint32_t RESERVED0[12];
N  __IO uint32_t CTCR;                       /*!< (@ 0x40014070) Count Control Register */
X  volatile uint32_t CTCR;                        
N  __IO uint32_t PWMC;                       /*!< (@ 0x40014074) PWM Control Register */
X  volatile uint32_t PWMC;                        
N} LPC_CTxxBx_Type;
N
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                          ADC                                         -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x ADC Modification date=3/16/2011 Major revision=0 Minor revision=3  (ADC)
N  */
N
Ntypedef struct {                            /*!< (@ 0x4001C000) ADC Structure          */
N  __IO uint32_t CR;                         /*!< (@ 0x4001C000) A/D Control Register */
X  volatile uint32_t CR;                          
N  __IO uint32_t GDR;                        /*!< (@ 0x4001C004) A/D Global Data Register */
X  volatile uint32_t GDR;                         
N  __I  uint32_t RESERVED0[1];
X  volatile const  uint32_t RESERVED0[1];
N  __IO uint32_t INTEN;                      /*!< (@ 0x4001C00C) A/D Interrupt Enable Register */
X  volatile uint32_t INTEN;                       
N  union{
N  __I  uint32_t DR[8];                      /*!< (@ 0x4001C010) A/D Channel Data Register*/
X  volatile const  uint32_t DR[8];                       
N    struct{
N  __IO uint32_t DR0;                      	/*!< (@ 0x40020010) A/D Channel Data Register 0*/
X  volatile uint32_t DR0;                      	 
N  __IO uint32_t DR1;                      	/*!< (@ 0x40020014) A/D Channel Data Register 1*/
X  volatile uint32_t DR1;                      	 
N  __IO uint32_t DR2;                      	/*!< (@ 0x40020018) A/D Channel Data Register 2*/
X  volatile uint32_t DR2;                      	 
N  __IO uint32_t DR3;                      	/*!< (@ 0x4002001C) A/D Channel Data Register 3*/
X  volatile uint32_t DR3;                      	 
N  __IO uint32_t DR4;                      	/*!< (@ 0x40020020) A/D Channel Data Register 4*/
X  volatile uint32_t DR4;                      	 
N  __IO uint32_t DR5;                      	/*!< (@ 0x40020024) A/D Channel Data Register 5*/
X  volatile uint32_t DR5;                      	 
N  __IO uint32_t DR6;                      	/*!< (@ 0x40020028) A/D Channel Data Register 6*/
X  volatile uint32_t DR6;                      	 
N  __IO uint32_t DR7;                      	/*!< (@ 0x4002002C) A/D Channel Data Register 7*/
X  volatile uint32_t DR7;                      	 
N  };
N  };
N  __I  uint32_t STAT;                       /*!< (@ 0x4001C030) A/D Status Register.  */
X  volatile const  uint32_t STAT;                        
N} LPC_ADC_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                          PMU                                         -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x Power Management Unit (PMU) Modification date=3/16/2011 Major revision=0 Minor revision=3  (PMU)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40038000) PMU Structure          */
N  __IO uint32_t PCON;                       /*!< (@ 0x40038000) Power control register */
X  volatile uint32_t PCON;                        
N  union{
N  __IO uint32_t GPREG[4];                   /*!< (@ 0x40038004) General purpose register 0 */
X  volatile uint32_t GPREG[4];                    
N  struct{
N  __IO uint32_t GPREG0;                   	/*!< (@ 0x40038004) General purpose register 0 */
X  volatile uint32_t GPREG0;                   	 
N  __IO uint32_t GPREG1;                   	/*!< (@ 0x40038008) General purpose register 1 */
X  volatile uint32_t GPREG1;                   	 
N  __IO uint32_t GPREG2;                   	/*!< (@ 0x4003800C) General purpose register 2 */
X  volatile uint32_t GPREG2;                   	 
N  __IO uint32_t GPREG3;                   	/*!< (@ 0x40038010) General purpose register 3 */
X  volatile uint32_t GPREG3;                   	 
N  };
N  };
N} LPC_PMU_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                       FLASHCTRL                                      -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x Flash programming firmware Modification date=3/17/2011 Major revision=0 Minor revision=3  (FLASHCTRL)
N  */
N
Ntypedef struct {                            /*!< (@ 0x4003C000) FLASHCTRL Structure    */
N  __I  uint32_t RESERVED0[4];
X  volatile const  uint32_t RESERVED0[4];
N  __IO uint32_t FLASHCFG;                   /*!< (@ 0x4003C010) Flash memory access time configuration register */
X  volatile uint32_t FLASHCFG;                    
N  __I  uint32_t RESERVED1[3];
X  volatile const  uint32_t RESERVED1[3];
N  __IO uint32_t FMSSTART;                   /*!< (@ 0x4003C020) Signature start address register */
X  volatile uint32_t FMSSTART;                    
N  __IO uint32_t FMSSTOP;                    /*!< (@ 0x4003C024) Signature stop-address register */
X  volatile uint32_t FMSSTOP;                     
N  __I  uint32_t RESERVED2[1];
X  volatile const  uint32_t RESERVED2[1];
N  __I  uint32_t FMSW0;                      /*!< (@ 0x4003C02C) Word 0 [31:0]          */
X  volatile const  uint32_t FMSW0;                       
N  __I  uint32_t FMSW1;                      /*!< (@ 0x4003C030) Word 1 [63:32]         */
X  volatile const  uint32_t FMSW1;                       
N  __I  uint32_t FMSW2;                      /*!< (@ 0x4003C034) Word 2 [95:64]         */
X  volatile const  uint32_t FMSW2;                       
N  __I  uint32_t FMSW3;                      /*!< (@ 0x4003C038) Word 3 [127:96]        */
X  volatile const  uint32_t FMSW3;                       
N  __I  uint32_t RESERVED3[1001];
X  volatile const  uint32_t RESERVED3[1001];
N  __I  uint32_t FMSTAT;                     /*!< (@ 0x4003CFE0) Signature generation status register */
X  volatile const  uint32_t FMSTAT;                      
N  __I  uint32_t RESERVED4[1];
X  volatile const  uint32_t RESERVED4[1];
N  __IO uint32_t FMSTATCLR;                  /*!< (@ 0x4003CFE8) Signature generation status clear register */
X  volatile uint32_t FMSTATCLR;                   
N} LPC_FLASHCTRL_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                         SSP0/1                                         -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x SSP/SPI Modification date=3/16/2011 Major revision=0 Minor revision=3  (SSP0)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40040000) SSP0 Structure         */
N  __IO uint32_t CR0;                        /*!< (@ 0x40040000) Control Register 0. Selects the serial clock rate, bus type, and data size. */
X  volatile uint32_t CR0;                         
N  __IO uint32_t CR1;                        /*!< (@ 0x40040004) Control Register 1. Selects master/slave and other modes. */
X  volatile uint32_t CR1;                         
N  __IO uint32_t DR;                         /*!< (@ 0x40040008) Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO. */
X  volatile uint32_t DR;                          
N  __I  uint32_t SR;                         /*!< (@ 0x4004000C) Status Register        */
X  volatile const  uint32_t SR;                          
N  __IO uint32_t CPSR;                       /*!< (@ 0x40040010) Clock Prescale Register */
X  volatile uint32_t CPSR;                        
N  __IO uint32_t IMSC;                       /*!< (@ 0x40040014) Interrupt Mask Set and Clear Register */
X  volatile uint32_t IMSC;                        
N  __I  uint32_t RIS;                        /*!< (@ 0x40040018) Raw Interrupt Status Register */
X  volatile const  uint32_t RIS;                         
N  __I  uint32_t MIS;                        /*!< (@ 0x4004001C) Masked Interrupt Status Register */
X  volatile const  uint32_t MIS;                         
N  __IO uint32_t ICR;                        /*!< (@ 0x40040020) SSPICR Interrupt Clear Register */
X  volatile uint32_t ICR;                         
N} LPC_SSPx_Type;
N
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                       IOCONFIG                                       -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x I/O configuration Modification date=3/16/2011 Major revision=0 Minor revision=3  (IOCONFIG)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40044000) IOCONFIG Structure     */
N  __IO uint32_t RESET_PIO0_0;               /*!< (@ 0x40044000) I/O configuration for pin RESET/PIO0_0 */
X  volatile uint32_t RESET_PIO0_0;                
N  __IO uint32_t PIO0_1;                     /*!< (@ 0x40044004) I/O configuration for pin PIO0_1/CLKOUT/CT32B0_MAT2/USB_FTOGGLE */
X  volatile uint32_t PIO0_1;                      
N  __IO uint32_t PIO0_2;                     /*!< (@ 0x40044008) I/O configuration for pin PIO0_2/SSEL0/CT16B0_CAP0 */
X  volatile uint32_t PIO0_2;                      
N  __IO uint32_t PIO0_3;                     /*!< (@ 0x4004400C) I/O configuration for pin PIO0_3/USB_VBUS */
X  volatile uint32_t PIO0_3;                      
N  __IO uint32_t PIO0_4;                     /*!< (@ 0x40044010) I/O configuration for pin PIO0_4/SCL */
X  volatile uint32_t PIO0_4;                      
N  __IO uint32_t PIO0_5;                     /*!< (@ 0x40044014) I/O configuration for pin PIO0_5/SDA */
X  volatile uint32_t PIO0_5;                      
N  __IO uint32_t PIO0_6;                     /*!< (@ 0x40044018) I/O configuration for pin PIO0_6/USB_CONNECT/SCK0 */
X  volatile uint32_t PIO0_6;                      
N  __IO uint32_t PIO0_7;                     /*!< (@ 0x4004401C) I/O configuration for pin PIO0_7/CTS */
X  volatile uint32_t PIO0_7;                      
N  __IO uint32_t PIO0_8;                     /*!< (@ 0x40044020) I/O configuration for pin PIO0_8/MISO0/CT16B0_MAT0 */
X  volatile uint32_t PIO0_8;                      
N  __IO uint32_t PIO0_9;                     /*!< (@ 0x40044024) I/O configuration for pin PIO0_9/MOSI0/CT16B0_MAT1 */
X  volatile uint32_t PIO0_9;                      
N  __IO uint32_t SWCLK_PIO0_10;              /*!< (@ 0x40044028) I/O configuration for pin SWCLK/PIO0_10/ SCK0/CT16B0_MAT2 */
X  volatile uint32_t SWCLK_PIO0_10;               
N  __IO uint32_t TDI_PIO0_11;                /*!< (@ 0x4004402C) I/O configuration for pin TDI/PIO0_11/AD0/CT32B0_MAT3 */
X  volatile uint32_t TDI_PIO0_11;                 
N  __IO uint32_t TMS_PIO0_12;                /*!< (@ 0x40044030) I/O configuration for pin TMS/PIO0_12/AD1/CT32B1_CAP0 */
X  volatile uint32_t TMS_PIO0_12;                 
N  __IO uint32_t TDO_PIO0_13;                /*!< (@ 0x40044034) I/O configuration for pin TDO/PIO0_13/AD2/CT32B1_MAT0 */
X  volatile uint32_t TDO_PIO0_13;                 
N  __IO uint32_t TRST_PIO0_14;               /*!< (@ 0x40044038) I/O configuration for pin TRST/PIO0_14/AD3/CT32B1_MAT1 */
X  volatile uint32_t TRST_PIO0_14;                
N  __IO uint32_t SWDIO_PIO0_15;              /*!< (@ 0x4004403C) I/O configuration for pin SWDIO/PIO0_15/AD4/CT32B1_MAT2 */
X  volatile uint32_t SWDIO_PIO0_15;               
N  __IO uint32_t PIO0_16;                    /*!< (@ 0x40044040) I/O configuration for pin PIO0_16/AD5/CT32B1_MAT3/ WAKEUP */
X  volatile uint32_t PIO0_16;                     
N  __IO uint32_t PIO0_17;                    /*!< (@ 0x40044044) I/O configuration for pin PIO0_17/RTS/CT32B0_CAP0/SCLK */
X  volatile uint32_t PIO0_17;                     
N  __IO uint32_t PIO0_18;                    /*!< (@ 0x40044048) I/O configuration for pin PIO0_18/RXD/CT32B0_MAT0 */
X  volatile uint32_t PIO0_18;                     
N  __IO uint32_t PIO0_19;                    /*!< (@ 0x4004404C) I/O configuration for pin PIO0_19/TXD/CT32B0_MAT1 */
X  volatile uint32_t PIO0_19;                     
N  __IO uint32_t PIO0_20;                    /*!< (@ 0x40044050) I/O configuration for pin PIO0_20/CT16B1_CAP0 */
X  volatile uint32_t PIO0_20;                     
N  __IO uint32_t PIO0_21;                    /*!< (@ 0x40044054) I/O configuration for pin PIO0_21/CT16B1_MAT0/MOSI1 */
X  volatile uint32_t PIO0_21;                     
N  __IO uint32_t PIO0_22;                    /*!< (@ 0x40044058) I/O configuration for pin PIO0_22/AD6/CT16B1_MAT1/MISO1 */
X  volatile uint32_t PIO0_22;                     
N  __IO uint32_t PIO0_23;                    /*!< (@ 0x4004405C) I/O configuration for pin PIO0_23/AD7 */
X  volatile uint32_t PIO0_23;                     
N  __IO uint32_t PIO1_0;                 /*!< Offset: 0x060 */
X  volatile uint32_t PIO1_0;                  
N  __IO uint32_t PIO1_1;         
X  volatile uint32_t PIO1_1;         
N  __IO uint32_t PIO1_2;       
X  volatile uint32_t PIO1_2;       
N  __IO uint32_t PIO1_3;      
X  volatile uint32_t PIO1_3;      
N  __IO uint32_t PIO1_4;                 /*!< Offset: 0x070 */
X  volatile uint32_t PIO1_4;                  
N  __IO uint32_t PIO1_5;                     /*!< (@ 0x40044074) I/O configuration for pin PIO1_5/CT32B1_CAP1 */
X  volatile uint32_t PIO1_5;                      
N  __IO uint32_t PIO1_6;     
X  volatile uint32_t PIO1_6;     
N  __IO uint32_t PIO1_7;       
X  volatile uint32_t PIO1_7;       
N  __IO uint32_t PIO1_8;                 /*!< Offset: 0x080 */
X  volatile uint32_t PIO1_8;                  
N  __IO uint32_t PIO1_9;        
X  volatile uint32_t PIO1_9;        
N  __IO uint32_t PIO1_10;        
X  volatile uint32_t PIO1_10;        
N  __IO uint32_t PIO1_11;       
X  volatile uint32_t PIO1_11;       
N  __IO uint32_t PIO1_12;                /*!< Offset: 0x090 */
X  volatile uint32_t PIO1_12;                 
N  __IO uint32_t PIO1_13;                    /*!< (@ 0x40044094) I/O configuration for pin PIO1_13/DTR/CT16B0_MAT0/TXD */
X  volatile uint32_t PIO1_13;                     
N  __IO uint32_t PIO1_14;                    /*!< (@ 0x40044098) I/O configuration for pin PIO1_14/DSR/CT16B0_MAT1/RXD */
X  volatile uint32_t PIO1_14;                     
N  __IO uint32_t PIO1_15;                    /*!< (@ 0x4004409C) I/O configuration for pin PIO1_15/DCD/ CT16B0_MAT2/SCK1 */
X  volatile uint32_t PIO1_15;                     
N  __IO uint32_t PIO1_16;                    /*!< (@ 0x400440A0) I/O configuration for pin PIO1_16/RI/CT16B0_CAP0 */
X  volatile uint32_t PIO1_16;                     
N  __IO uint32_t PIO1_17;
X  volatile uint32_t PIO1_17;
N  __IO uint32_t PIO1_18;
X  volatile uint32_t PIO1_18;
N  __IO uint32_t PIO1_19;                    /*!< (@ 0x400440AC) I/O configuration for pin PIO1_19/DTR/SSEL1 */
X  volatile uint32_t PIO1_19;                     
N  __IO uint32_t PIO1_20;                    /*!< (@ 0x400440B0) I/O configuration for pin PIO1_20/DSR/SCK1 */
X  volatile uint32_t PIO1_20;                     
N  __IO uint32_t PIO1_21;                    /*!< (@ 0x400440B4) I/O configuration for pin PIO1_21/DCD/MISO1 */
X  volatile uint32_t PIO1_21;                     
N  __IO uint32_t PIO1_22;                    /*!< (@ 0x400440B8) I/O configuration for pin PIO1_22/RI/MOSI1 */
X  volatile uint32_t PIO1_22;                     
N  __IO uint32_t PIO1_23;                    /*!< (@ 0x400440BC) I/O configuration for pin PIO1_23/CT16B1_MAT1/SSEL1 */
X  volatile uint32_t PIO1_23;                     
N  __IO uint32_t PIO1_24;                    /*!< (@ 0x400440C0) I/O configuration for pin PIO1_24/ CT32B0_MAT0 */
X  volatile uint32_t PIO1_24;                     
N  __IO uint32_t PIO1_25;                    /*!< (@ 0x400440C4) I/O configuration for pin PIO1_25/CT32B0_MAT1 */
X  volatile uint32_t PIO1_25;                     
N  __IO uint32_t PIO1_26;                    /*!< (@ 0x400440C8) I/O configuration for pin PIO1_26/CT32B0_MAT2/ RXD */
X  volatile uint32_t PIO1_26;                     
N  __IO uint32_t PIO1_27;                    /*!< (@ 0x400440CC) I/O configuration for pin PIO1_27/CT32B0_MAT3/ TXD */
X  volatile uint32_t PIO1_27;                     
N  __IO uint32_t PIO1_28;                    /*!< (@ 0x400440D0) I/O configuration for pin PIO1_28/CT32B0_CAP0/ SCLK */
X  volatile uint32_t PIO1_28;                     
N  __IO uint32_t PIO1_29;                    /*!< (@ 0x400440D4) I/O configuration for pin PIO1_29/SCK0/ CT32B0_CAP1 */
X  volatile uint32_t PIO1_29;                     
N  __IO uint32_t PIO1_30;
X  volatile uint32_t PIO1_30;
N  __IO uint32_t PIO1_31;                    /*!< (@ 0x400440DC) I/O configuration for pin PIO1_31 */
X  volatile uint32_t PIO1_31;                     
N} LPC_IOCON_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                        SYSCON                                        -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x System control block Modification date=3/16/2011 Major revision=0 Minor revision=3  (SYSCON)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40048000) SYSCON Structure       */
N  __IO uint32_t SYSMEMREMAP;                /*!< (@ 0x40048000) System memory remap    */
X  volatile uint32_t SYSMEMREMAP;                 
N  __IO uint32_t PRESETCTRL;                 /*!< (@ 0x40048004) Peripheral reset control */
X  volatile uint32_t PRESETCTRL;                  
N  __IO uint32_t SYSPLLCTRL;                 /*!< (@ 0x40048008) System PLL control     */
X  volatile uint32_t SYSPLLCTRL;                  
N  __I  uint32_t SYSPLLSTAT;                 /*!< (@ 0x4004800C) System PLL status      */
X  volatile const  uint32_t SYSPLLSTAT;                  
N  __IO uint32_t USBPLLCTRL;                 /*!< (@ 0x40048010) USB PLL control        */
X  volatile uint32_t USBPLLCTRL;                  
N  __I  uint32_t USBPLLSTAT;                 /*!< (@ 0x40048014) USB PLL status         */
X  volatile const  uint32_t USBPLLSTAT;                  
N  __I  uint32_t RESERVED0[2];
X  volatile const  uint32_t RESERVED0[2];
N  __IO uint32_t SYSOSCCTRL;                 /*!< (@ 0x40048020) System oscillator control */
X  volatile uint32_t SYSOSCCTRL;                  
N  __IO uint32_t WDTOSCCTRL;                 /*!< (@ 0x40048024) Watchdog oscillator control */
X  volatile uint32_t WDTOSCCTRL;                  
N  __I  uint32_t RESERVED1[2];
X  volatile const  uint32_t RESERVED1[2];
N  __IO uint32_t SYSRSTSTAT;                 /*!< (@ 0x40048030) System reset status register */
X  volatile uint32_t SYSRSTSTAT;                  
N  __I  uint32_t RESERVED2[3];
X  volatile const  uint32_t RESERVED2[3];
N  __IO uint32_t SYSPLLCLKSEL;               /*!< (@ 0x40048040) System PLL clock source select */
X  volatile uint32_t SYSPLLCLKSEL;                
N  __IO uint32_t SYSPLLCLKUEN;               /*!< (@ 0x40048044) System PLL clock source update enable */
X  volatile uint32_t SYSPLLCLKUEN;                
N  __IO uint32_t USBPLLCLKSEL;               /*!< (@ 0x40048048) USB PLL clock source select */
X  volatile uint32_t USBPLLCLKSEL;                
N  __IO uint32_t USBPLLCLKUEN;               /*!< (@ 0x4004804C) USB PLL clock source update enable */
X  volatile uint32_t USBPLLCLKUEN;                
N  __I  uint32_t RESERVED3[8];
X  volatile const  uint32_t RESERVED3[8];
N  __IO uint32_t MAINCLKSEL;                 /*!< (@ 0x40048070) Main clock source select */
X  volatile uint32_t MAINCLKSEL;                  
N  __IO uint32_t MAINCLKUEN;                 /*!< (@ 0x40048074) Main clock source update enable */
X  volatile uint32_t MAINCLKUEN;                  
N  __IO uint32_t SYSAHBCLKDIV;               /*!< (@ 0x40048078) System clock divider   */
X  volatile uint32_t SYSAHBCLKDIV;                
N  __I  uint32_t RESERVED4[1];
X  volatile const  uint32_t RESERVED4[1];
N  __IO uint32_t SYSAHBCLKCTRL;              /*!< (@ 0x40048080) System clock control   */
X  volatile uint32_t SYSAHBCLKCTRL;               
N  __I  uint32_t RESERVED5[4];
X  volatile const  uint32_t RESERVED5[4];
N  __IO uint32_t SSP0CLKDIV;                 /*!< (@ 0x40048094) SSP0 clock divider     */
X  volatile uint32_t SSP0CLKDIV;                  
N  __IO uint32_t UARTCLKDIV;                 /*!< (@ 0x40048098) UART clock divider     */
X  volatile uint32_t UARTCLKDIV;                  
N  __IO uint32_t SSP1CLKDIV;                 /*!< (@ 0x4004809C) SSP1 clock divider     */
X  volatile uint32_t SSP1CLKDIV;                  
N  __I  uint32_t RESERVED6[8];
X  volatile const  uint32_t RESERVED6[8];
N  __IO uint32_t USBCLKSEL;                  /*!< (@ 0x400480C0) USB clock source select */
X  volatile uint32_t USBCLKSEL;                   
N  __IO uint32_t USBCLKUEN;                  /*!< (@ 0x400480C4) USB clock source update enable */
X  volatile uint32_t USBCLKUEN;                   
N  __IO uint32_t USBCLKDIV;                  /*!< (@ 0x400480C8) USB clock source divider */
X  volatile uint32_t USBCLKDIV;                   
N  __I  uint32_t RESERVED7[5];
X  volatile const  uint32_t RESERVED7[5];
N  __IO uint32_t CLKOUTSEL;                  /*!< (@ 0x400480E0) CLKOUT clock source select */
X  volatile uint32_t CLKOUTSEL;                   
N  __IO uint32_t CLKOUTUEN;                  /*!< (@ 0x400480E4) CLKOUT clock source update enable */
X  volatile uint32_t CLKOUTUEN;                   
N  __IO uint32_t CLKOUTDIV;                  /*!< (@ 0x400480E8) CLKOUT clock divider   */
X  volatile uint32_t CLKOUTDIV;                   
N  __I  uint32_t RESERVED8[5];
X  volatile const  uint32_t RESERVED8[5];
N  __I  uint32_t PIOPORCAP0;                 /*!< (@ 0x40048100) POR captured PIO status 0 */
X  volatile const  uint32_t PIOPORCAP0;                  
N  __I  uint32_t PIOPORCAP1;                 /*!< (@ 0x40048104) POR captured PIO status 1 */
X  volatile const  uint32_t PIOPORCAP1;                  
N  __I  uint32_t RESERVED9[18];
X  volatile const  uint32_t RESERVED9[18];
N  __IO uint32_t BODCTRL;                    /*!< (@ 0x40048150) Brown-Out Detect       */
X  volatile uint32_t BODCTRL;                     
N  __IO uint32_t SYSTCKCAL;                  /*!< (@ 0x40048154) System tick counter calibration */
X  volatile uint32_t SYSTCKCAL;                   
N  __I  uint32_t RESERVED10[6];
X  volatile const  uint32_t RESERVED10[6];
N  __IO uint32_t IRQLATENCY;                 /*!< (@ 0x40048170) IQR delay */
X  volatile uint32_t IRQLATENCY;                  
N  __IO uint32_t NMISRC;                     /*!< (@ 0x40048174) NMI Source Control     */
X  volatile uint32_t NMISRC;                      
N  __IO uint32_t PINTSEL[8];                 /*!< (@ 0x40048178) GPIO Pin Interrupt Select register 0 */
X  volatile uint32_t PINTSEL[8];                  
N  __IO uint32_t USBCLKCTRL;                 /*!< (@ 0x40048198) USB clock control      */
X  volatile uint32_t USBCLKCTRL;                  
N  __I  uint32_t USBCLKST;                   /*!< (@ 0x4004819C) USB clock status       */
X  volatile const  uint32_t USBCLKST;                    
N  __I  uint32_t RESERVED11[25];
X  volatile const  uint32_t RESERVED11[25];
N  __IO uint32_t STARTERP0;                  /*!< (@ 0x40048204) Start logic 0 interrupt wake-up enable register 0 */
X  volatile uint32_t STARTERP0;                   
N  __I  uint32_t RESERVED12[3];
X  volatile const  uint32_t RESERVED12[3];
N  __IO uint32_t STARTERP1;                  /*!< (@ 0x40048214) Start logic 1 interrupt wake-up enable register 1 */
X  volatile uint32_t STARTERP1;                   
N  __I  uint32_t RESERVED13[6];
X  volatile const  uint32_t RESERVED13[6];
N  __IO uint32_t PDSLEEPCFG;                 /*!< (@ 0x40048230) Power-down states in deep-sleep mode */
X  volatile uint32_t PDSLEEPCFG;                  
N  __IO uint32_t PDAWAKECFG;                 /*!< (@ 0x40048234) Power-down states for wake-up from deep-sleep */
X  volatile uint32_t PDAWAKECFG;                  
N  __IO uint32_t PDRUNCFG;                   /*!< (@ 0x40048238) Power configuration register */
X  volatile uint32_t PDRUNCFG;                    
N  __I  uint32_t RESERVED14[110];
X  volatile const  uint32_t RESERVED14[110];
N  __I  uint32_t DEVICE_ID;                  /*!< (@ 0x400483F4) Device ID              */
X  volatile const  uint32_t DEVICE_ID;                   
N} LPC_SYSCON_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                     GPIO_PIN_INT                                     -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x GPIO Modification date=3/17/2011 Major revision=0 Minor revision=3  (GPIO_PIN_INT)
N  */
N
Ntypedef struct {                            /*!< (@ 0x4004C000) GPIO_PIN_INT Structure */
N  __IO uint32_t ISEL;                       /*!< (@ 0x4004C000) Pin Interrupt Mode register */
X  volatile uint32_t ISEL;                        
N  __IO uint32_t IENR;                       /*!< (@ 0x4004C004) Pin Interrupt Enable (Rising) register */
X  volatile uint32_t IENR;                        
N  __IO uint32_t SIENR;                      /*!< (@ 0x4004C008) Set Pin Interrupt Enable (Rising) register */
X  volatile uint32_t SIENR;                       
N  __IO uint32_t CIENR;                      /*!< (@ 0x4004C00C) Clear Pin Interrupt Enable (Rising) register */
X  volatile uint32_t CIENR;                       
N  __IO uint32_t IENF;                       /*!< (@ 0x4004C010) Pin Interrupt Enable Falling Edge / Active Level register */
X  volatile uint32_t IENF;                        
N  __IO uint32_t SIENF;                      /*!< (@ 0x4004C014) Set Pin Interrupt Enable Falling Edge / Active Level register */
X  volatile uint32_t SIENF;                       
N  __IO uint32_t CIENF;                      /*!< (@ 0x4004C018) Clear Pin Interrupt Enable Falling Edge / Active Level address */
X  volatile uint32_t CIENF;                       
N  __IO uint32_t RISE;                       /*!< (@ 0x4004C01C) Pin Interrupt Rising Edge register */
X  volatile uint32_t RISE;                        
N  __IO uint32_t FALL;                       /*!< (@ 0x4004C020) Pin Interrupt Falling Edge register */
X  volatile uint32_t FALL;                        
N  __IO uint32_t IST;                        /*!< (@ 0x4004C024) Pin Interrupt Status register */
X  volatile uint32_t IST;                         
N} LPC_GPIO_PIN_INT_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                    GPIO_GROUP_INT0/1                                   -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x GPIO Modification date=3/17/2011 Major revision=0 Minor revision=3  (GPIO_GROUP_INT0)
N  */
N
Ntypedef struct {                            /*!< (@ 0x4005C000) GPIO_GROUP_INT0 Structure */
N  __IO uint32_t CTRL;                       /*!< (@ 0x4005C000) GPIO grouped interrupt control register */
X  volatile uint32_t CTRL;                        
N  __I  uint32_t RESERVED0[7];
X  volatile const  uint32_t RESERVED0[7];
N  __IO uint32_t PORT_POL[2];                /*!< (@ 0x4005C020) GPIO grouped interrupt port 0 polarity register */
X  volatile uint32_t PORT_POL[2];                 
N  __I  uint32_t RESERVED1[6];
X  volatile const  uint32_t RESERVED1[6];
N  __IO uint32_t PORT_ENA[2];                /*!< (@ 0x4005C040) GPIO grouped interrupt port 0/1 enable register */
X  volatile uint32_t PORT_ENA[2];                 
N} LPC_GPIO_GROUP_INTx_Type;
N
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                          USB                                         -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x USB2.0device controller Modification date=3/16/2011 Major revision=0 Minor revision=3  (USB)
N  */
N
Ntypedef struct {                            /*!< (@ 0x40080000) USB Structure          */
N  __IO uint32_t DEVCMDSTAT;                 /*!< (@ 0x40080000) USB Device Command/Status register */
X  volatile uint32_t DEVCMDSTAT;                  
N  __IO uint32_t INFO;                       /*!< (@ 0x40080004) USB Info register      */
X  volatile uint32_t INFO;                        
N  __IO uint32_t EPLISTSTART;                /*!< (@ 0x40080008) USB EP Command/Status List start address */
X  volatile uint32_t EPLISTSTART;                 
N  __IO uint32_t DATABUFSTART;               /*!< (@ 0x4008000C) USB Data buffer start address */
X  volatile uint32_t DATABUFSTART;                
N  __IO uint32_t LPM;                        /*!< (@ 0x40080010) Link Power Management register */
X  volatile uint32_t LPM;                         
N  __IO uint32_t EPSKIP;                     /*!< (@ 0x40080014) USB Endpoint skip      */
X  volatile uint32_t EPSKIP;                      
N  __IO uint32_t EPINUSE;                    /*!< (@ 0x40080018) USB Endpoint Buffer in use */
X  volatile uint32_t EPINUSE;                     
N  __IO uint32_t EPBUFCFG;                   /*!< (@ 0x4008001C) USB Endpoint Buffer Configuration register */
X  volatile uint32_t EPBUFCFG;                    
N  __IO uint32_t INTSTAT;                    /*!< (@ 0x40080020) USB interrupt status register */
X  volatile uint32_t INTSTAT;                     
N  __IO uint32_t INTEN;                      /*!< (@ 0x40080024) USB interrupt enable register */
X  volatile uint32_t INTEN;                       
N  __IO uint32_t INTSETSTAT;                 /*!< (@ 0x40080028) USB set interrupt status register */
X  volatile uint32_t INTSETSTAT;                  
N  __IO uint32_t INTROUTING;                 /*!< (@ 0x4008002C) USB interrupt routing register */
X  volatile uint32_t INTROUTING;                  
N  __I  uint32_t RESERVED0[1];
X  volatile const  uint32_t RESERVED0[1];
N  __I  uint32_t EPTOGGLE;                   /*!< (@ 0x40080034) USB Endpoint toggle register */
X  volatile const  uint32_t EPTOGGLE;                    
N} LPC_USB_Type;
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                       GPIO_PORT                                      -----
N// ------------------------------------------------------------------------------------------------
N
N
N/**
N  * @brief Product name title=UM10462 Chapter title=LPC11U1x GPIO Modification date=3/17/2011 Major revision=0 Minor revision=3  (GPIO_PORT)
N  */
N
Ntypedef struct {                            
N  union {
N    struct {
N      __IO uint8_t B0[32];                       /*!< (@ 0x50000000) Byte pin registers port 0; pins PIO0_0 to PIO0_31 */
X      volatile uint8_t B0[32];                        
N      __IO uint8_t B1[32];                       /*!< (@ 0x50000020) Byte pin registers port 1 */
X      volatile uint8_t B1[32];                        
N    };
N    __IO uint8_t B[64];                       /*!< (@ 0x50000000) Byte pin registers port 0/1 */
X    volatile uint8_t B[64];                        
N  };
N  __I  uint32_t RESERVED0[1008];
X  volatile const  uint32_t RESERVED0[1008];
N  union {
N    struct {
N      __IO uint32_t W0[32];                      /*!< (@ 0x50001000) Word pin registers port 0 */
X      volatile uint32_t W0[32];                       
N      __IO uint32_t W1[32];                      /*!< (@ 0x50001080) Word pin registers port 1 */
X      volatile uint32_t W1[32];                       
N    };
N    __IO uint32_t W[64];                       /*!< (@ 0x50001000) Word pin registers port 0/1 */
X    volatile uint32_t W[64];                        
N  };
N       uint32_t RESERVED1[960];
N  __IO uint32_t DIR[2];			/* 0x2000 */
X  volatile uint32_t DIR[2];			 
N       uint32_t RESERVED2[30];
N  __IO uint32_t MASK[2];		/* 0x2080 */
X  volatile uint32_t MASK[2];		 
N       uint32_t RESERVED3[30];
N  __IO uint32_t PIN[2];			/* 0x2100 */
X  volatile uint32_t PIN[2];			 
N       uint32_t RESERVED4[30];
N  __IO uint32_t MPIN[2];		/* 0x2180 */
X  volatile uint32_t MPIN[2];		 
N       uint32_t RESERVED5[30];
N  __IO uint32_t SET[2];			/* 0x2200 */
X  volatile uint32_t SET[2];			 
N       uint32_t RESERVED6[30];
N  __O  uint32_t CLR[2];			/* 0x2280 */
X  volatile  uint32_t CLR[2];			 
N       uint32_t RESERVED7[30];
N  __O  uint32_t NOT[2];			/* 0x2300 */
X  volatile  uint32_t NOT[2];			 
N} LPC_GPIO_Type;
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #pragma no_anon_unions
N#endif
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                 Peripheral memory map                                -----
N// ------------------------------------------------------------------------------------------------
N
N#define LPC_I2C_BASE              (0x40000000)
N#define LPC_WWDT_BASE             (0x40004000)
N#define LPC_USART_BASE            (0x40008000)
N#define LPC_CT16B0_BASE           (0x4000C000)
N#define LPC_CT16B1_BASE           (0x40010000)
N#define LPC_CT32B0_BASE           (0x40014000)
N#define LPC_CT32B1_BASE           (0x40018000)
N#define LPC_ADC_BASE              (0x4001C000)
N#define LPC_PMU_BASE              (0x40038000)
N#define LPC_FLASHCTRL_BASE        (0x4003C000)
N#define LPC_SSP0_BASE             (0x40040000)
N#define LPC_SSP1_BASE             (0x40058000)
N#define LPC_IOCON_BASE            (0x40044000)
N#define LPC_SYSCON_BASE           (0x40048000)
N#define LPC_GPIO_PIN_INT_BASE     (0x4004C000)
N#define LPC_GPIO_GROUP_INT0_BASE  (0x4005C000)
N#define LPC_GPIO_GROUP_INT1_BASE  (0x40060000)
N#define LPC_USB_BASE              (0x40080000)
N#define LPC_GPIO_BASE             (0x50000000)
N
N
N// ------------------------------------------------------------------------------------------------
N// -----                                Peripheral declaration                                -----
N// ------------------------------------------------------------------------------------------------
N
N#define LPC_I2C                   ((LPC_I2C_Type            *) LPC_I2C_BASE)
N#define LPC_WWDT                  ((LPC_WWDT_Type           *) LPC_WWDT_BASE)
N#define LPC_USART                 ((LPC_USART_Type          *) LPC_USART_BASE)
N#define LPC_CT16B0                ((LPC_CTxxBx_Type         *) LPC_CT16B0_BASE)
N#define LPC_CT16B1                ((LPC_CTxxBx_Type         *) LPC_CT16B1_BASE)
N#define LPC_CT32B0                ((LPC_CTxxBx_Type         *) LPC_CT32B0_BASE)
N#define LPC_CT32B1                ((LPC_CTxxBx_Type         *) LPC_CT32B1_BASE)
N#define LPC_ADC                   ((LPC_ADC_Type            *) LPC_ADC_BASE)
N#define LPC_PMU                   ((LPC_PMU_Type            *) LPC_PMU_BASE)
N#define LPC_FLASHCTRL             ((LPC_FLASHCTRL_Type      *) LPC_FLASHCTRL_BASE)
N#define LPC_SSP0                  ((LPC_SSPx_Type           *) LPC_SSP0_BASE)
N#define LPC_SSP1                  ((LPC_SSPx_Type           *) LPC_SSP1_BASE)
N#define LPC_IOCON                 ((LPC_IOCON_Type          *) LPC_IOCON_BASE)
N#define LPC_SYSCON                ((LPC_SYSCON_Type         *) LPC_SYSCON_BASE)
N#define LPC_GPIO_PIN_INT          ((LPC_GPIO_PIN_INT_Type   *) LPC_GPIO_PIN_INT_BASE)
N#define LPC_GPIO_GROUP_INT0       ((LPC_GPIO_GROUP_INTx_Type*) LPC_GPIO_GROUP_INT0_BASE)
N#define LPC_GPIO_GROUP_INT1       ((LPC_GPIO_GROUP_INTx_Type*) LPC_GPIO_GROUP_INT1_BASE)
N#define LPC_USB                   ((LPC_USB_Type            *) LPC_USB_BASE)
N#define LPC_GPIO                  ((LPC_GPIO_Type           *) LPC_GPIO_BASE)
N
N
N/** @} */ /* End of group Device_Peripheral_Registers */
N/** @} */ /* End of group (null) */
N/** @} */ /* End of group LPC11Uxx */
N
N#ifdef __cplusplus
S}
N#endif
N#endif  // __LPC11UXX_H__
N
L 28 "Src\system_LPC11Uxx.c" 2
N#include "Timer16.h"
L 1 ".\Inc\Timer16.h" 1
N/****************************************************************************
N *   $Id:: timer16.h 6956 2011-03-23 23:03:25Z usb00423                     $
N *   Project: NXP LPC11xx software example
N *
N *   Description:
N *     This file contains definition and prototype for 16-bit timer 
N *     configuration.
N *
N ****************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N****************************************************************************/
N#ifndef __TIMER16_H__ 
N#define __TIMER16_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif 
N
N#include "type.h"
N	
N#ifdef __TIMER16_C__
S#define INTERFACE
N#else
N#define INTERFACE extern
N#endif
N
N
N#define Timer16_0 0
N#define Timer16_1 1
N///* For 16-bit timer, make sure that TIME_INTERVAL should be no
N//greater than 0xFFFF. */
N#define Timer16_IntervalmS 1000UL 
N#define Timer16_MHz_Prescale (SystemCoreClock/1000000UL)
N
Ntypedef struct _LPC11Uxx_Timer16_Setting_
N{
N	U32 Timer16_0_Counter[2];
N	U32 Timer16_1_Counter[2];
N	
N} LPC11Uxx_Timer16_Setting;
N
NINTERFACE LPC11Uxx_Timer16_Setting g_Timer16_Setting;
Xextern LPC11Uxx_Timer16_Setting g_Timer16_Setting;
N
NINTERFACE void TIMER16_0_IRQHandler(void);
Xextern void TIMER16_0_IRQHandler(void);
NINTERFACE void TIMER16_1_IRQHandler(void);
Xextern void TIMER16_1_IRQHandler(void);
NINTERFACE void NDrv_Timer16_Enable(U8 timer_num);
Xextern void NDrv_Timer16_Enable(U8 timer_num);
NINTERFACE void NDrv_Timer16_Disable(U8 timer_num);
Xextern void NDrv_Timer16_Disable(U8 timer_num);
NINTERFACE void NDrv_Timer16_Reset(U8 timer_num);
Xextern void NDrv_Timer16_Reset(U8 timer_num);
NINTERFACE void nsAPI_Timer16_Init(U8 timer_num, U32 timer);
Xextern void nsAPI_Timer16_Init(U8 timer_num, U32 timer);
N
N#undef INTERFACE
N#ifdef __cplusplus
S}
N#endif 
N#endif /* end __TIMER16_H */
N
L 29 "Src\system_LPC11Uxx.c" 2
N#include "timer32.h"
L 1 ".\Inc\timer32.h" 1
N/****************************************************************************
N *   $Id:: timer32.h 6956 2011-03-23 23:03:25Z usb00423                     $
N *   Project: NXP LPC11xx software example
N *
N *   Description:
N *     This file contains definition and prototype for 32-bit timer 
N *     configuration.
N *
N ****************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N****************************************************************************/
N#ifndef __TIMER32_H__ 
N#define __TIMER32_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "Type.h"
N
N#ifdef  __TIMER32_C__
S#define INTERFACE
N#else
N#define INTERFACE extern
N#endif
N
N#define EMC0	4
N#define EMC1	6
N#define EMC2	8
N#define EMC3	10
N
N#define MATCH0 BIT0
N#define MATCH1 BIT1
N#define MATCH2 BIT2
N#define MATCH3 BIT3
N
N#define Timer32_0 0
N#define Timer32_1 1
N
N
N
N#define BREATHING_FREQ_GAP 100
N#define BREATHING_DELAY_TIMER 40
N#define BREATHING_STEP 2
N
N#define PWM_MATCH_ENABLE (MATCH2|MATCH1|MATCH0)
N#define Timer32_IntervalmS 1000UL 
N#define Timer32_MHz_Prescale (SystemCoreClock/1000000UL)
N
Ntypedef enum _Timer32_LED_Type_
N{
N	LED_NORMAL = 0,
N	LED_BREATHING   
N}Timer32_LED_Type;
N
N
N#define BREATHING_STEP_RESETTING BIT0
N
Ntypedef struct _LPC11Uxx_TIMER32_LED_SETTING_
N{
N	Timer32_LED_Type LEDStatusType;/* 0 -> Normal : 1 -> Breathing */	
N	U8 BreathingStatusType;/*1 -> Inc : 0 -> Dec*/
N	U8 BreathingStep; 
N	U8 BreathingStepStatus; 
N	U32 BreathingDelayCount;
N	U32 CurBreathingFreq;
N	U32 PreBreathingFreq;	
N}LPC11Uxx_TIMER32_LED_SETTING;
N
NINTERFACE LPC11Uxx_TIMER32_LED_SETTING g_Timer32_LED_Setting; 
Xextern LPC11Uxx_TIMER32_LED_SETTING g_Timer32_LED_Setting; 
N
NINTERFACE void TIMER32_0_IRQHandler(void);
Xextern void TIMER32_0_IRQHandler(void);
NINTERFACE void TIMER32_1_IRQHandler(void);
Xextern void TIMER32_1_IRQHandler(void);
NINTERFACE void NDrv_Timer32_Enable(U8 timer_num);
Xextern void NDrv_Timer32_Enable(U8 timer_num);
NINTERFACE void NDrv_Timer32_Disable(U8 timer_num);
Xextern void NDrv_Timer32_Disable(U8 timer_num);
NINTERFACE void NDrv_Timer32_Reset(U8 timer_num);
Xextern void NDrv_Timer32_Reset(U8 timer_num);
NINTERFACE void nsAPI_Timer32_Setting_MatchFunction(uint8_t timer_num, uint8_t match_enable, uint8_t location);
Xextern void nsAPI_Timer32_Setting_MatchFunction(uint8_t timer_num, uint8_t match_enable, uint8_t location);
NINTERFACE void nsAPI_Timer32PWM_Init(U8 timer_num, U32 period, U8 match_enable);
Xextern void nsAPI_Timer32PWM_Init(U8 timer_num, U32 period, U8 match_enable);
NINTERFACE void NDrv_Timer32PWM_ReSettingMatch(U8 timer_num, U32 period);
Xextern void NDrv_Timer32PWM_ReSettingMatch(U8 timer_num, U32 period);
NINTERFACE void NDrv_Timer32PWM_Breathing(void);
Xextern void NDrv_Timer32PWM_Breathing(void);
NINTERFACE RetU32 nsAPI_Timer32PWM_GetCurBreathingFreqValue(void);
Xextern RetU32 nsAPI_Timer32PWM_GetCurBreathingFreqValue(void);
NINTERFACE void nsAPI_Timer32PWM_Breathing_ReSetting(U8 u8Breathing);
Xextern void nsAPI_Timer32PWM_Breathing_ReSetting(U8 u8Breathing);
Nextern void init_timer32(U32 timer );
N
N#undef INTERFACE
N#ifdef __cplusplus
S}
N#endif
N#endif /* end __TIMER32_H */
N
L 30 "Src\system_LPC11Uxx.c" 2
N#include "Uart.h"
L 1 ".\Inc\Uart.h" 1
N/****************************************************************************
N *   $Id:: uart.h 6172 2011-01-13 18:22:51Z usb00423                        $
N *   Project: NXP LPC11xx software example
N *
N *   Description:
N *     This file contains definition and prototype for UART configuration.
N *
N ****************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N****************************************************************************/
N#ifndef __UART_H__ 
N#define __UART_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "Type.h"
N
N#ifdef __UART_C__
S#define INTERFACE
N#else
N#define INTERFACE extern
N#endif
N
N
N#define RS485_ENABLED 0
N#define TX_INTERRUPT 0/* 0 if TX uses polling, 1 interrupt driven. */
N
N#define IER_RBR BIT0
N#define IER_THRE BIT1
N#define IER_RLS BIT2
N
N#define IIR_PEND (BIT0)
N#define IIR_RLS (BIT1|BIT0)
N#define IIR_RDA (BIT1)
N#define IIR_CTI (BIT2|BIT1)
N#define IIR_THRE (BIT0)
N
N#define LSR_RDR BIT0
N#define LSR_OE BIT1
N#define LSR_PE BIT2
N#define LSR_FE BIT3
N#define LSR_BI BIT4
N#define LSR_THRE BIT5
N#define LSR_TEMT BIT6
N#define LSR_RXFE BIT7
N
N#define UARTBUFSIZE 20
N#define BR 115200
N
N/* RS485 mode definition. */
N#define RS485_NMMEN BIT0
N#define RS485_RXDIS BIT1
N#define RS485_AADEN	BIT2
N#define RS485_SEL BIT3
N#define RS485_DCTRL BIT4
N#define RS485_OINV BIT5
N
Ntypedef struct _LPC11Uxx_Uart_Setting_
N{
N	U32 UartStatus; 
N	U8 UartBuffer[UARTBUFSIZE];
X	U8 UartBuffer[20];
N	U8 UartCount;
N}LPC11Uxx_Uart_Setting;
N
NINTERFACE LPC11Uxx_Uart_Setting g_Uart_Setting;
Xextern LPC11Uxx_Uart_Setting g_Uart_Setting;
N
Nvoid ModemInit( void );
NINTERFACE void nsAPI_UART_Init(uint32_t Baudrate);
Xextern void nsAPI_UART_Init(uint32_t Baudrate);
NINTERFACE void UART_IRQHandler(void);
Xextern void UART_IRQHandler(void);
NINTERFACE void nsAPI_UART_Send(U8 *BufferPtr, U32 Length);
Xextern void nsAPI_UART_Send(U8 *BufferPtr, U32 Length);
NINTERFACE void xprintf(U8 *pFmt,U32 wVal,...);
Xextern void xprintf(U8 *pFmt,U32 wVal,...);
N
N#undef INTERFACE
N#ifdef __cplusplus
S}
N#endif
N#endif /* end __UART_H */
N
L 31 "Src\system_LPC11Uxx.c" 2
N#include "Gpio.h"
L 1 ".\Inc\Gpio.h" 1
N/****************************************************************************
N *   $Id:: gpio.h 6172 2011-01-13 18:22:51Z usb00423                        $
N *   Project: NXP LPC11xx software example
N *
N *   Description:
N *     This file contains definition and prototype for GPIO.
N *
N ****************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N****************************************************************************/
N#ifndef __GPIO_H__ 
N#define __GPIO_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "Type.h"
N
N#ifdef  __GPIO_C__
S#define INTERFACE
N#else
N#define INTERFACE extern
N#endif
N
N#define PORT0 0
N#define PORT1 1
N
N#define GROUP0 0
N#define GROUP1 1
N
N#define GPIOIN 0
N#define GPIOOUT 1
N
N#define GPIO_SCANKEY_NULL 0
N#define GPIO_SCANKEY_PR BIT0
N#define GPIO_SCANKEY_PH BIT1
N#define GPIO_SCANKEY_RELEASE BIT2
N
N#define GPIO0_PR (0xFFFFFFFF)
N//#define GPIO1_PR (BIT20|BIT19|BIT15|BIT14|BIT13) //ori
N#define GPIO1_PR (BIT31|BIT28|BIT27|BIT26|BIT25)
N
Ntypedef enum _QIEStatusIndex_
N{   
N    QIE_STOP = 0x00,
N    QIE_FORWARD = 0x01,
N    QIE_BACKWARD = 0xFF,    
N    QIE_SAME = 0xAA  
N}QIEStatusIndex;
N
N
Ntypedef struct _LPC11Uxx_Gpio_Setting_
N{
N	U16 ButtonStatus; 
N	U16 ButtonEvent;	
N	U16 ButtonEventCount;	
N	U16 PreButtonEvent;	
N	U16 KeycodeTblIdx; 
N	U8  PreQIEStatus;
N}LPC11Uxx_Gpio_Setting;
N
N
NINTERFACE LPC11Uxx_Gpio_Setting g_GpioButtonEvent;
Xextern LPC11Uxx_Gpio_Setting g_GpioButtonEvent;
N
N
N
NINTERFACE void FLEX_INT0_IRQHandler(void);
Xextern void FLEX_INT0_IRQHandler(void);
NINTERFACE void FLEX_INT1_IRQHandler(void);
Xextern void FLEX_INT1_IRQHandler(void);
NINTERFACE void FLEX_INT2_IRQHandler(void);
Xextern void FLEX_INT2_IRQHandler(void);
NINTERFACE void FLEX_INT3_IRQHandler(void);
Xextern void FLEX_INT3_IRQHandler(void);
NINTERFACE void FLEX_INT4_IRQHandler(void);
Xextern void FLEX_INT4_IRQHandler(void);
NINTERFACE void FLEX_INT5_IRQHandler(void);
Xextern void FLEX_INT5_IRQHandler(void);
NINTERFACE void FLEX_INT6_IRQHandler(void);
Xextern void FLEX_INT6_IRQHandler(void);
NINTERFACE void FLEX_INT7_IRQHandler(void);
Xextern void FLEX_INT7_IRQHandler(void);
NINTERFACE void GINT0_IRQHandler(void);
Xextern void GINT0_IRQHandler(void);
NINTERFACE void GINT1_IRQHandler(void);
Xextern void GINT1_IRQHandler(void);
NINTERFACE void nsAPI_GPIO_Init( void );
Xextern void nsAPI_GPIO_Init( void );
NINTERFACE void NDrv_GPIO_SetBitValue(U32 portNum, U32 bitPosi, U32 bitVal );
Xextern void NDrv_GPIO_SetBitValue(U32 portNum, U32 bitPosi, U32 bitVal );
NINTERFACE RetU32 nsAPI_GPIO_GetPinValue( U8 portNum, U32 bitPosi);
Xextern RetU32 nsAPI_GPIO_GetPinValue( U8 portNum, U32 bitPosi);
NINTERFACE void NDrv_GPIO_SetDir( U32 portNum, U32 bitPosi, U32 dir );
Xextern void NDrv_GPIO_SetDir( U32 portNum, U32 bitPosi, U32 dir );
NINTERFACE void nsAPI_GPIO_LEDSetting(U8 uPort, U32 uPosition, U8 uValue);
Xextern void nsAPI_GPIO_LEDSetting(U8 uPort, U32 uPosition, U8 uValue);
NINTERFACE RetU8 nsAPI_GPIO_ScanButton(void);
Xextern RetU8 nsAPI_GPIO_ScanButton(void);
NINTERFACE void nsAPI_GPIO_MouseButtonMonitor(void);
Xextern void nsAPI_GPIO_MouseButtonMonitor(void);
NINTERFACE RetU16 nsAPI_GPIO_ChangingIndex(U16 u16Index);
Xextern RetU16 nsAPI_GPIO_ChangingIndex(U16 u16Index);
NINTERFACE U8 nsAPI_GPIO_Get_QIE(void);
Xextern U8 nsAPI_GPIO_Get_QIE(void);
NINTERFACE void nsAPI_GPIO_QIE_Monitor(void);
Xextern void nsAPI_GPIO_QIE_Monitor(void);
NINTERFACE void nsAPI_GPIO_Macrokey_Monitor(void);
Xextern void nsAPI_GPIO_Macrokey_Monitor(void);
N
N#undef INTERFACE
N#ifdef __cplusplus
S}
N#endif
N#endif /* end __GPIO_H */
N
L 32 "Src\system_LPC11Uxx.c" 2
N#include "Usbhw.h"
L 1 ".\Inc\Usbhw.h" 1
N/****************************************************************************
N *   $Id:: usbhw.h 6446 2011-02-12 03:00:16Z usb00423                        $
N *   Project: NXP LPC11Uxx USB example
N *
N *   Description:
N *     This file contains LPC11Uxx USB H/W layer definitions, data structure,
N *     and USB hardware API prototyping.
N *
N ****************************************************************************
N * Software that is described herein is for illustrative purposes only
N * which provides customers with programming information regarding the
N * products. This software is supplied "AS IS" without any warranties.
N * NXP Semiconductors assumes no responsibility or liability for the
N * use of the software, conveys no license or title under any patent,
N * copyright, or mask work right to the product. NXP Semiconductors
N * reserves the right to make changes in the software without
N * notification. NXP Semiconductors also make no representation or
N * warranty that such application will be suitable for the specified
N * use without further testing or modification.
N****************************************************************************/
N#ifndef __USBHW_H__
N#define __USBHW_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "Type.h"
N#include "Usb.h"
L 1 ".\Inc\Usb.h" 1
N/*----------------------------------------------------------------------------
N *      U S B  -  K e r n e l
N *----------------------------------------------------------------------------
N * Name:    usb.h
N * Purpose: USB Definitions
N * Version: V1.20
N *----------------------------------------------------------------------------
N *      This software is supplied "AS IS" without any warranties, express,
N *      implied or statutory, including but not limited to the implied
N *      warranties of fitness for purpose, satisfactory quality and
N *      noninfringement. Keil extends you a royalty-free right to reproduce
N *      and distribute executable files created using this software for use
N *      on NXP Semiconductors LPC family microcontroller devices only. Nothing 
N *      else gives you the right to use this software.
N *
N * Copyright (c) 2009 Keil - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#ifndef __USB_H__
N#define __USB_H__
N
N#include "Type.h"
N
N#define ALIGNED(n) __align(n)
N
Ntypedef __packed union
N{
N	U16 W;
N	__packed struct
N	{
N		U8 L;
N		U8 H;
N	} WB;
N} WORD_BYTE;
N
N/* bmRequestType.Dir */
N#define REQUEST_HOST_TO_DEVICE 0
N#define REQUEST_DEVICE_TO_HOST 1
N/* bmRequestType.Type */
N#define REQUEST_STANDARD 0
N#define REQUEST_CLASS 1
N#define REQUEST_VENDOR 2
N#define REQUEST_RESERVED 3
N/* bmRequestType.Recipient */
N#define REQUEST_TO_DEVICE 0
N#define REQUEST_TO_INTERFACE 1
N#define REQUEST_TO_ENDPOINT 2
N#define REQUEST_TO_OTHER 3
N
N/* bmRequestType Definition */
Ntypedef __packed union _REQUEST_TYPE_
N{
N	__packed struct _BM_
N	{
N		uint8_t Recipient : 5;
N		uint8_t Type : 2;
N		uint8_t Dir : 1;
N	} BM;
N	uint8_t B;
N} REQUEST_TYPE;
N
N/* USB Standard Request Codes */
N#define USB_REQUEST_GET_STATUS 0
N#define USB_REQUEST_CLEAR_FEATURE 1
N#define USB_REQUEST_SET_FEATURE 3
N#define USB_REQUEST_SET_ADDRESS 5
N#define USB_REQUEST_GET_DESCRIPTOR 6
N#define USB_REQUEST_SET_DESCRIPTOR 7
N#define USB_REQUEST_GET_CONFIGURATION 8
N#define USB_REQUEST_SET_CONFIGURATION 9
N#define USB_REQUEST_GET_INTERFACE 10
N#define USB_REQUEST_SET_INTERFACE 11
N#define USB_REQUEST_SYNC_FRAME 12
N/* USB GET_STATUS Bit Values */
N#define USB_GETSTATUS_SELF_POWERED BIT0
N#define USB_GETSTATUS_REMOTE_WAKEUP BIT1
N#define USB_GETSTATUS_ENDPOINT_STALL BIT0
N/* USB Standard Feature selectors */
N#define USB_FEATURE_ENDPOINT_STALL 0
N#define USB_FEATURE_REMOTE_WAKEUP BIT0
N
N/* USB Default Control Pipe Setup Packet */
Ntypedef __packed struct _USB_SETUP_PACKET_ 
N{
N	REQUEST_TYPE bmRequestType;
N	U8 bRequest;
N	WORD_BYTE wValue;
N	WORD_BYTE wIndex;
N	U16 wLength;
N} USB_SETUP_PACKET;
N
N
N/* USB Descriptor Types */
N#define USB_DEVICE_DESCRIPTOR_TYPE 1
N#define USB_CONFIGURATION_DESCRIPTOR_TYPE 2
N#define USB_STRING_DESCRIPTOR_TYPE 3
N#define USB_INTERFACE_DESCRIPTOR_TYPE 4
N#define USB_ENDPOINT_DESCRIPTOR_TYPE 5
N#define USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE 6
N#define USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE 7
N#define USB_INTERFACE_POWER_DESCRIPTOR_TYPE 8
N#define USB_OTG_DESCRIPTOR_TYPE 9
N#define USB_DEBUG_DESCRIPTOR_TYPE 10
N#define USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE 11 
N/* Wireless USB extension Descriptor Type. */
N#define USB_SECURITY_TYPE 12
N#define USB_KEY_TYPE 13
N#define USB_ENCRIPTION_TYPE 14
N#define USB_BOS_TYPE 15
N#define USB_DEVICE_CAPABILITY_TYPE 16
N#define USB_WIRELESS_ENDPOINT_COMPANION_TYPE 17
N
N/* USB Device Classes */
N#define USB_DEVICE_CLASS_RESERVED 0x00
N#define USB_DEVICE_CLASS_AUDIO 0x01
N#define USB_DEVICE_CLASS_COMMUNICATIONS 0x02
N#define USB_DEVICE_CLASS_HUMAN_INTERFACE 0x03
N#define USB_DEVICE_CLASS_MONITOR 0x04
N#define USB_DEVICE_CLASS_PHYSICAL_INTERFACE 0x05
N#define USB_DEVICE_CLASS_POWER 0x06
N#define USB_DEVICE_CLASS_PRINTER 0x07
N#define USB_DEVICE_CLASS_STORAGE 0x08
N#define USB_DEVICE_CLASS_HUB 0x09
N#define USB_DEVICE_CLASS_MISCELLANEOUS 0xEF
N#define USB_DEVICE_CLASS_VENDOR_SPECIFIC 0xFF
N/* bmAttributes in Configuration Descriptor */
N#define USB_CONFIG_POWERED_MASK 0x40
N#define USB_CONFIG_BUS_POWERED 0x80
N#define USB_CONFIG_SELF_POWERED 0xC0
N#define USB_CONFIG_REMOTE_WAKEUP 0x20
N/* bMaxPower in Configuration Descriptor */
N#define USB_CONFIG_POWER_MA(mA) ((mA)/2)
N/* bEndpointAddress in Endpoint Descriptor */
N#define USB_ENDPOINT_DIRECTION_MASK 0x80
N#define USB_ENDPOINT_OUT(addr) ((addr)|0x00)
N#define USB_ENDPOINT_IN(addr) ((addr)|0x80)
N/* bmAttributes in Endpoint Descriptor */
N#define USB_ENDPOINT_TYPE_MASK 0x03
N#define USB_ENDPOINT_TYPE_CONTROL 0x00
N#define USB_ENDPOINT_TYPE_ISOCHRONOUS 0x01
N#define USB_ENDPOINT_TYPE_BULK 0x02
N#define USB_ENDPOINT_TYPE_INTERRUPT 0x03
N#define USB_ENDPOINT_SYNC_MASK 0x0C
N#define USB_ENDPOINT_SYNC_NO_SYNCHRONIZATION 0x00
N#define USB_ENDPOINT_SYNC_ASYNCHRONOUS 0x04
N#define USB_ENDPOINT_SYNC_ADAPTIVE 0x08
N#define USB_ENDPOINT_SYNC_SYNCHRONOUS 0x0C
N#define USB_ENDPOINT_USAGE_MASK 0x30
N#define USB_ENDPOINT_USAGE_DATA 0x00
N#define USB_ENDPOINT_USAGE_FEEDBACK 0x10
N#define USB_ENDPOINT_USAGE_IMPLICIT_FEEDBACK 0x20
N#define USB_ENDPOINT_USAGE_RESERVED 0x30
N/* USB Standard Device Descriptor */
Ntypedef __packed struct _USB_DEVICE_DESCRIPTOR_
N{
N	uint8_t  bLength;
N	uint8_t  bDescriptorType;
N	uint16_t  bcdUSB;
N	uint8_t  bDeviceClass;
N	uint8_t  bDeviceSubClass;
N	uint8_t  bDeviceProtocol;
N	uint8_t  bMaxPacketSize0;
N	uint16_t  idVendor;
N	uint16_t  idProduct;
N	uint16_t  bcdDevice;
N	uint8_t  iManufacturer;
N	uint8_t  iProduct;
N	uint8_t  iSerialNumber;
N	uint8_t  bNumConfigurations;
N} USB_DEVICE_DESCRIPTOR;
N
N/* USB 2.0 Device Qualifier Descriptor */
Ntypedef __packed struct _USB_DEVICE_QUALIFIER_DESCRIPTOR_
N{
N	uint8_t  bLength;
N	uint8_t  bDescriptorType;
N	uint16_t  bcdUSB;
N	uint8_t  bDeviceClass;
N	uint8_t  bDeviceSubClass;
N	uint8_t  bDeviceProtocol;
N	uint8_t  bMaxPacketSize0;
N	uint8_t  bNumConfigurations;
N	uint8_t  bReserved;
N} USB_DEVICE_QUALIFIER_DESCRIPTOR;
N
N/* USB Standard Configuration Descriptor */
Ntypedef __packed struct _USB_CONFIGURATION_DESCRIPTOR_
N{
N	uint8_t  bLength;
N	uint8_t  bDescriptorType;
N	uint16_t  wTotalLength;
N	uint8_t  bNumInterfaces;
N	uint8_t  bConfigurationValue;
N	uint8_t  iConfiguration;
N	uint8_t  bmAttributes;
N	uint8_t  bMaxPower;
N} USB_CONFIGURATION_DESCRIPTOR;
N
N/* USB Standard Interface Descriptor */
Ntypedef __packed struct _USB_INTERFACE_DESCRIPTOR_
N{
N	uint8_t  bLength;
N	uint8_t  bDescriptorType;
N	uint8_t  bInterfaceNumber;
N	uint8_t  bAlternateSetting;
N	uint8_t  bNumEndpoints;
N	uint8_t  bInterfaceClass;
N	uint8_t  bInterfaceSubClass;
N	uint8_t  bInterfaceProtocol;
N	uint8_t  iInterface;
N} USB_INTERFACE_DESCRIPTOR;
N
N/* USB Standard Endpoint Descriptor */
Ntypedef __packed struct _USB_ENDPOINT_DESCRIPTOR_
N{
N	uint8_t  bLength;
N	uint8_t  bDescriptorType;
N	uint8_t  bEndpointAddress;
N	uint8_t  bmAttributes;
N	uint16_t  wMaxPacketSize;
N	uint8_t  bInterval;
N} USB_ENDPOINT_DESCRIPTOR;
N
N/* USB String Descriptor */
Ntypedef __packed struct _USB_STRING_DESCRIPTOR_
N{
N	uint8_t  bLength;
N	uint8_t  bDescriptorType;
N	uint16_t  bString/*[]*/;
N} USB_STRING_DESCRIPTOR;
N
N/* USB Common Descriptor */
Ntypedef __packed struct _USB_COMMON_DESCRIPTOR_
N{
N	uint8_t  bLength;
N	uint8_t  bDescriptorType;
N} USB_COMMON_DESCRIPTOR;
N
N/* USB BOS Descriptor. */
Ntypedef __packed struct _USB_BOS_DESCRIPTOR_
N{
N	uint8_t  bLength;
N	uint8_t  bDescriptorType;
N	uint16_t wTotalLength;
N	uint8_t  bNumDeviceCaps;
N} USB_BOS_DESCRIPTOR;
N
N/* USB Super Speed Device Capability Descriptor. */
Ntypedef __packed struct _USB_SS_DEVICE_CAPABLITY_DESCRIPTOR_
N{
N	uint8_t  bLength;
N	uint8_t  bDescriptorType;
N	uint8_t  bDeviceCapabilityType;
N	uint8_t  bAttributes;
N	uint16_t wSpeedsSupported;
N	uint8_t  bFunctionalitySupport;
N	uint8_t  bU1DevExitLat;
N	uint16_t bU2DevExitLat;
N} USB_SS_DEVICE_CAPABILITY_DESCRIPTOR;
N
N/* USB Device Capability Descriptor, USB 2.0 extension for LPM. */
Ntypedef __packed struct _USB_DEVICE_CAPABLITY_DESCRIPTOR_
N{
N	uint8_t  bLength;
N	uint8_t  bDescriptorType;
N	uint8_t  bDeviceCapabilityType;
N	uint32_t bmAttributes;
N} USB_DEVICE_CAPABILITY_DESCRIPTOR;
N#endif  /* __USB_H__ */
N
L 30 ".\Inc\Usbhw.h" 2
N#include "usbcfg.h"
L 1 ".\Inc\usbcfg.h" 1
N/*----------------------------------------------------------------------------
N *      U S B  -  K e r n e l
N *----------------------------------------------------------------------------
N * Name:    usbcfg.h
N * Purpose: USB Custom Configuration
N * Version: V1.20
N *----------------------------------------------------------------------------
N *      This software is supplied "AS IS" without any warranties, express,
N *      implied or statutory, including but not limited to the implied
N *      warranties of fitness for purpose, satisfactory quality and
N *      noninfringement. Keil extends you a royalty-free right to reproduce
N *      and distribute executable files created using this software for use
N *      on NXP Semiconductors LPC family microcontroller devices only. Nothing 
N *      else gives you the right to use this software.
N *
N * Copyright (c) 2009 Keil - An ARM Company. All rights reserved.
N *----------------------------------------------------------------------------
N * History:
N *          V1.20 Added vendor specific support
N *          V1.00 Initial Version
N *----------------------------------------------------------------------------*/
N
N#ifndef __USBCFG_H__
N#define __USBCFG_H__
N
N
N//*** <<< Use Configuration Wizard in Context Menu >>> ***
N
N
N/*
N// <h> USB Configuration
N//   <o0> USB Power
N//        <i> Default Power Setting
N//        <0=> Bus-powered
N//        <1=> Self-powered
N//   <o1> Max Number of Interfaces <1-256>
N//   <o2> Max Number of Endpoints  <1-32>
N//   <o3> Max Setup Packet Size
N//        <8=> 8 Bytes <16=> 16 Bytes <32=> 32 Bytes <64=> 64 Bytes
N//   <o4> Max Endpoint 0 Packet Size
N//        <8=> 8 Bytes <16=> 16 Bytes <32=> 32 Bytes <64=> 64 Bytes
N//   <o5> Maximum non-isochronous packet size  <1-64>
N//   <o6> Maximum isochronous packet size  <1-1023>
N
N// </h>
N*/
N
N#define USB_POWER 0
N#define USB_IF_NUM 1
N#define USB_EP_NUM 4 // 10 dennis
N#define USB_SETUP_PACKET_SIZE 8
N#define USB_MAX_PACKET0 64
N#define USB_MAX_NON_ISO_SIZE 64
N#define USB_MAX_ISO_SIZE 1023
N#define USB_LOGIC_EP_NUM 5
N
N
N#if 1 // dennis 6/5/2014
N	#define USB_PACKET_SIZE 0x12
N#else
S	#define USB_PACKET_SIZE 8
N#endif	  
N
N/*
N// <h> Miscellaneous USB support
N//     <o0.0> Power Down USB Wake-up
N//     <o1.0> Remote Wake-up enable
N//     <o2.0> Use double-buffered endpoints
N//     <o3.0> Link Power Management Support
N//     <o4.0> Isochronous communications
N//     <o5.0> Use Debug
N// </h>
N*/
N
N/* If REMOTE_WAKEUP_ENABLE is set to 1, set POWERDOWN_MODE_USB_WAKEUP flag to 0.
N   Don't turn on both flags at the same time. */
N#define POWERDOWN_MODE_USB_WAKEUP   0
N#define REMOTE_WAKEUP_ENABLE        0
N#define USE_DOUBLE_BUFFER           0
N#define LPM_SUPPORT                 0	/* Link Power Management */
N#define USB_ISO_COMMUNICATION       0
N
N/*
N// <h> USB Event Handlers
N//   <h> Device Events
N//     <o0.0> Power Event
N//     <o1.0> Reset Event
N//     <o2.0> Suspend Event
N//     <o3.0> Resume Event
N//     <o4.0> Remote Wakeup Event
N//     <o5.0> Start of Frame Event
N//     <o6.0> Error Event
N//   </h>
N//   <h> Endpoint Events
N//     <o7.0>  Endpoint 0 Event
N//     <o7.1>  Endpoint 1 Event
N//     <o7.2>  Endpoint 2 Event
N//     <o7.3>  Endpoint 3 Event
N//     <o7.4>  Endpoint 4 Event
N//   </h>
N//   <h> USB Core Events
N//     <o8.0>  Set Configuration Event
N//     <o9.0>  Set Interface Event
N//     <o10.0> Set/Clear Feature Event
N//   </h>
N// </h>
N*/
N
N#define USB_POWER_EVENT     0
N#define USB_RESET_EVENT     1
N#define USB_SUSPEND_EVENT   1
N#define USB_RESUME_EVENT    1
N#define USB_WAKEUP_EVENT    0
N#define USB_SOF_EVENT       0
N#define USB_ERROR_EVENT     0
N#define USB_EP_EVENT 0x0003
N#define USB_CONFIGURE_EVENT 1
N#define USB_INTERFACE_EVENT 0
N#define USB_FEATURE_EVENT   0
N#define USB_FIQ_EVENT		0
N
N
N/*
N// <e0> USB Class Support
N//   <i> enables USB Class specific Requests
N//   <e1> Human Interface Device (HID)
N//     <o2> Interface Number <0-255>
N//   </e>
N//   <e3> Mass Storage
N//     <o4> Interface Number <0-255>
N//   </e>
N//   <e5> Audio Device
N//     <o6> Control Interface Number <0-255>
N//     <o7> Streaming Interface 1 Number <0-255>
N//     <o8> Streaming Interface 2 Number <0-255>
N//   </e>
N//   <e9> Communication Device
N//     <o10> Control Interface Number <0-255>
N//     <o11> Bulk Interface Number <0-255>
N//     <o12> Max Communication Device Buffer Size
N//        <8=> 8 Bytes <16=> 16 Bytes <32=> 32 Bytes <64=> 64 Bytes 
N//   </e>
N// </e>
N*/
N
N#define USB_CLASS 1
N#define USB_HID 1
N#define USB_HID_IF_NUM 0
N
N/*
N// <e0> USB Vendor Support
N//   <i> enables USB Vendor specific Requests
N// </e>
N*/
N#define USB_VENDOR 0
N#endif  /* __USBCFG_H__ */
N
L 31 ".\Inc\Usbhw.h" 2
N
N#ifdef  __USBHW_C__
S#define INTERFACE
N#else
N#define INTERFACE extern
N#endif
N
N
Ntypedef struct _EP_LIST
N{
N	U32 buf_ptr;
N	U32 buf_length;
N} EP_LIST;
N
Ntypedef struct _LPC11Uxx_USBHW_SETTING_
N{
N	/* The BufferUsed flag is to deal with double buffer situation, This is a bit mask
N	flag for non-zero EPs. If BufferUsed bit is set, buffer 0 is used, switch to buffer 1.
N	If BufferUsed flag is not set, buffer 0 can be used. */
N	volatile U32 BufferUsed;
N
N	/* The ActiveFlag is to deal with STALL situation, if STALL happens during
N	WriteEP(), don't set the ACTIVE bit in EPList CommandStatus immediately but
N	this flag only, ACTIVE bit will be set after ClearStallEP() that data is ready
N	to be sent. This is a bit mask flag for non-zero EPs. */
N	volatile U32 EPActiveFlag;
N
N	/* EP buffer address and length default setting */
N	volatile EP_LIST EPList[USB_EP_NUM*2];/* Consider double buffer for non zero EPs */
X	volatile EP_LIST EPList[4*2]; 
N}LPC11Uxx_USBHW_SETTING;
N
NINTERFACE LPC11Uxx_USBHW_SETTING g_USBHW_Setting;
Xextern LPC11Uxx_USBHW_SETTING g_USBHW_Setting;
N
N#define USB_EPLIST_ADDR 0x10001800
N#define USB_EPDATA_ADDR (USB_EPLIST_ADDR + 0x100)
N#define USB_EPDATA_PAGE (USB_EPDATA_ADDR&0xFFC00000)/* Bit 22~31 is the page */
N#define USB_RAM_LIMIT 0x800/* maximum USB RAM size is 2K */
N
N#if 0
S/* Be careful if ISO communication is used that it could allocate more than 64 bytes. */
S#define USB_EP0DATA_OUT		(USB_EPDATA_ADDR + 0x00)
S#define USB_SETUP_BUF		(USB_EPDATA_ADDR + 0x40)
S#define USB_EP0DATA_IN		(USB_EPDATA_ADDR + 0x80)
S
S#define USB_EP1DATA_OUT0	(USB_EPDATA_ADDR + 0x100)		/* INT/BULK EPs, max EP 64 bytes */
S#define USB_EP1DATA_OUT1	(USB_EPDATA_ADDR + 0x140)
S#define USB_EP1DATA_IN0		(USB_EPDATA_ADDR + 0x180)
S#define USB_EP1DATA_IN1		(USB_EPDATA_ADDR + 0x1C0)
S
S#define USB_EP2DATA_OUT0	(USB_EPDATA_ADDR + 0x200)
S#define USB_EP2DATA_OUT1	(USB_EPDATA_ADDR + 0x240)
S#define USB_EP2DATA_IN0		(USB_EPDATA_ADDR + 0x280)
S#define USB_EP2DATA_IN1		(USB_EPDATA_ADDR + 0x2C0)
S
S#define USB_EP3DATA_OUT0	(USB_EPDATA_ADDR + 0x300)
S#define USB_EP3DATA_OUT1	(USB_EPDATA_ADDR + 0x340)
S#define USB_EP3DATA_IN0		(USB_EPDATA_ADDR + 0x380)
S#define USB_EP3DATA_IN1		(USB_EPDATA_ADDR + 0x3C0)
S
S#define USB_EP4DATA_OUT0	(USB_EPDATA_ADDR + 0x400)
S#define USB_EP4DATA_OUT1	(USB_EPDATA_ADDR + 0x440)
S#define USB_EP4DATA_IN0		(USB_EPDATA_ADDR + 0x480)
S#define USB_EP4DATA_IN1		(USB_EPDATA_ADDR + 0x4C0)
N#endif
N
N#define BUF_ACTIVE BIT31
N#define EP_DISABLED BIT30
N#define EP_STALL BIT29
N#define EP_RESET BIT28
N#define EP_ISO_TYPE BIT26
N
N/* USB Device Command Status */
N#define USB_EN BIT7/* Device Enable */
N#define USB_SETUP_RCVD BIT8/* SETUP token received */
N#define USB_PLL_ON BIT9/* PLL is always ON */
N#define USB_LPM BIT11/* LPM is supported */
N#define USB_IntOnNAK_AO BIT12/* Device Interrupt on NAK BULK OUT */
N#define USB_IntOnNAK_AI BIT13/* Device Interrupt on NAK BULK IN */
N#define USB_IntOnNAK_CO BIT14/* Device Interrupt on NAK CTRL OUT */
N#define USB_IntOnNAK_CI BIT15/* Device Interrupt on NAK CTRL IN */
N#define USB_DCON BIT16/* Device connect */
N#define USB_DSUS BIT17/* Device Suspend */
N#define USB_LPM_SUS BIT19/* LPM suspend */
N#define USB_REMOTE_WAKE BIT20/* LPM Remote Wakeup */
N#define USB_DCON_C BIT24/* Device connection change */
N#define USB_DSUS_C BIT25/* Device SUSPEND change */
N#define USB_DRESET_C BIT26/* Device RESET */
N#define USB_VBUS_DBOUNCE BIT28/* Device VBUS detect */
N
N/* Device Interrupt Bit Definitions */
N#define EP0_INT BIT0
N#define EP1_INT BIT1
N#define EP2_INT BIT2
N#define EP3_INT BIT3
N#define EP4_INT BIT4
N#define EP5_INT BIT5
N#define EP6_INT BIT6
N#define EP7_INT BIT7
N#define EP8_INT BIT8
N#define EP9_INT BIT9
N#define FRAME_INT BIT30
N#define DEV_STAT_INT (0x80000000)
N
N/* Rx & Tx Packet Length Definitions */
N#define PKT_LNGTH_MASK 0x000003FF
N
N/* Error Status Register Definitions */
N#define ERR_NOERROR 0x00
N#define ERR_PID_ENCODE 0x01
N#define ERR_UNKNOWN_PID 0x02
N#define ERR_UNEXPECT_PKT 0x03
N#define ERR_TCRC 0x04
N#define ERR_DCRC 0x05
N#define ERR_TIMEOUT 0x06
N#define ERR_BABBIE 0x07
N#define ERR_EOF_PKT 0x08
N#define ERR_TX_RX_NAK 0x09
N#define ERR_SENT_STALL 0x0A
N#define ERR_BUF_OVERRUN 0x0B
N#define ERR_SENT_EPT_PKT 0x0C
N#define ERR_BIT_STUFF 0x0D
N#define ERR_SYNC 0x0E
N#define ERR_TOGGLE_BIT 0x0F
N
N/* USB Hardware Functions */
NINTERFACE void NDrv_USB_IOClkConfig(void);
Xextern void NDrv_USB_IOClkConfig(void);
NINTERFACE void nsAPI_USB_Init(void);
Xextern void nsAPI_USB_Init(void);
NINTERFACE void NDrv_USB_EPInit(void);
Xextern void NDrv_USB_EPInit(void);
NINTERFACE void NDrv_USB_Connect(U8 con);
Xextern void NDrv_USB_Connect(U8 con);
NINTERFACE void NDrv_USB_Reset(void);
Xextern void NDrv_USB_Reset(void);
NINTERFACE void USB_Suspend(void);
Xextern void USB_Suspend(void);
NINTERFACE void USB_Resume(void);
Xextern void USB_Resume(void);
NINTERFACE void USB_WakeUp(void);
Xextern void USB_WakeUp(void);
NINTERFACE void NDrv_USB_WakeUpCfg(U8 cfg);
Xextern void NDrv_USB_WakeUpCfg(U8 cfg);
NINTERFACE void nsAPI_USB_SetAddress(U32 adr);
Xextern void nsAPI_USB_SetAddress(U32 adr);
NINTERFACE void NDrv_USB_Configure(U8 cfg);
Xextern void NDrv_USB_Configure(U8 cfg);
N//INTERFACE void  nsAPI_USB_ConfigEP(USB_ENDPOINT_DESCRIPTOR *pEPD);
N//INTERFACE void  USB_DirCtrlEP  (uint32_t dir);
NINTERFACE void  nsAPI_USB_EnableEP(U32 EPNum);
Xextern void  nsAPI_USB_EnableEP(U32 EPNum);
NINTERFACE void  nsAPI_USB_DisableEP(U32 EPNum);
Xextern void  nsAPI_USB_DisableEP(U32 EPNum);
NINTERFACE void  nsAPI_USB_ResetEP(U32 EPNum);
Xextern void  nsAPI_USB_ResetEP(U32 EPNum);
NINTERFACE void  nsAPI_USB_SetStallEP(U32 EPNum);
Xextern void  nsAPI_USB_SetStallEP(U32 EPNum);
NINTERFACE void  nsAPI_USB_ClrStallEP(U32 EPNum);
Xextern void  nsAPI_USB_ClrStallEP(U32 EPNum);
N//INTERFACE void  USB_ClearEPBuf (uint32_t EPNum);
NINTERFACE void nsAPI_USB_ReadSetupEP(U32 EPNum, U8 *pData);
Xextern void nsAPI_USB_ReadSetupEP(U32 EPNum, U8 *pData);
NINTERFACE RetU32 nsAPI_USB_ReadEP(U32 EPNum, U8 *pData);
Xextern RetU32 nsAPI_USB_ReadEP(U32 EPNum, U8 *pData);
NINTERFACE RetU32 nsAPI_USB_WriteEP(U32 EPNum, U8 *pData, U32 cnt);
Xextern RetU32 nsAPI_USB_WriteEP(U32 EPNum, U8 *pData, U32 cnt);
NINTERFACE void  USB_IRQHandler (void);
Xextern void  USB_IRQHandler (void);
NINTERFACE void  USBWakeup_IRQHandler(void);
Xextern void  USBWakeup_IRQHandler(void);
NINTERFACE void RemoteWakeupEvent ( void );
Xextern void RemoteWakeupEvent ( void );
NINTERFACE void wnDrv_Usb_ClrGetReqStatus(U32 EPNum);
Xextern void wnDrv_Usb_ClrGetReqStatus(U32 EPNum);
NINTERFACE Boolean wnDrv_Usb_EP_Status(U32 EPNum);
Xextern Boolean wnDrv_Usb_EP_Status(U32 EPNum);
N
N#undef INTERFACE
N#ifdef __cplusplus
S}
N#endif
N#endif  /* __USBHW_H__ */
L 33 "Src\system_LPC11Uxx.c" 2
N#include "Systick.h"
L 1 ".\Inc\Systick.h" 1
N#ifndef __SYSTICK_H__ 
N#define __SYSTICK_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif 
N
N#include "type.h"
N	
N#ifdef __SYSTICK_C__
S#define INTERFACE
N#else
N#define INTERFACE extern
N#endif
N
N#define SYSTICK_TIMER (SystemCoreClock /1000)/*1ms*/ 
N//#define SYSTICK_TIMER (SystemCoreClock /1000000)/*1ms*/ 
N
NINTERFACE void SysTick_Handler(void);
Xextern void SysTick_Handler(void);
NINTERFACE void nsAPI_SysTick_Init(void);
Xextern void nsAPI_SysTick_Init(void);
N
N#undef INTERFACE
N#ifdef __cplusplus
S}
N#endif 
N#endif /* end __SYSTICK_H */
N
N
L 34 "Src\system_LPC11Uxx.c" 2
N#include "Ssp.h"
L 1 ".\Inc\Ssp.h" 1
N#ifndef __SSP_H__
N#define __SSP_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "Type.h"
N#include "Gpio.h"
N
N#ifdef  __SSP_C__
S#define INTERFACE
N#else
N#define INTERFACE extern
N#endif
N
N#if 0
S#define _DEBUG_SSP_(x) x
N#else
N#define _DEBUG_SSP_(x) 
N#endif
N
N
N/* SSP Clock div (0..255) */
N#define SCB_CLKDIV_DISABLE (0x00000000)
N#define SCB_CLKDIV_DIV1 (0x00000001)
N#define SCB_CLKDIV_DIV2 (0x00000002)
N#define SCB_CLKDIV_DIV3 (0x00000003)
N#define SCB_CLKDIV_DIV4 (0x00000004)
N#define SCB_CLKDIV_DIV5 (0x00000005)
N#define SCB_CLKDIV_DIV6 (0x00000006)
N#define SCB_CLKDIV_DIV7 (0x00000007)
N#define SCB_CLKDIV_DIV8 (0x00000008)
N#define SCB_CLKDIV_DIV9 (0x00000009)
N#define SCB_CLKDIV_DIV10 (0x0000000A)
N#define SCB_CLKDIV_DIV11 (0x0000000B)
N#define SCB_CLKDIV_DIV12 (0x0000000C)
N#define SCB_CLKDIV_DIV13 (0x0000000D)
N#define SCB_CLKDIV_DIV14 (0x0000000E)
N#define SCB_CLKDIV_DIV15 (0x0000000F)
N#define SCB_CLKDIV_DIV20 (0x00000014)
N#define SCB_CLKDIV_DIV25 (0x00000019)
N#define SCB_CLKDIV_DIV30 (0x0000001E)
N#define SCB_CLKDIV_DIV35 (0x00000033)
N#define SCB_CLKDIV_DIV40 (0x00000028)
N#define SCB_CLKDIV_DIV45 (0x0000002D)
N#define SCB_CLKDIV_MASK (0x000000FF)
N
N/* SSP Serial Clock Rate Values */
N#define SSP_SCR_1 (0x00000100)
N#define SSP_SCR_2 (0x00000200)
N#define SSP_SCR_3 (0x00000300)
N#define SSP_SCR_4 (0x00000400)
N#define SSP_SCR_5 (0x00000500)
N#define SSP_SCR_6 (0x00000600)
N#define SSP_SCR_7 (0x00000700)
N#define SSP_SCR_8 (0x00000800)
N#define SSP_SCR_9 (0x00000900)
N#define SSP_SCR_10 (0x00000A00)
N#define SSP_SCR_11 (0x00000B00)
N#define SSP_SCR_12 (0x00000C00)
N#define SSP_SCR_13 (0x00000D00)
N#define SSP_SCR_14 (0x00000E00)
N#define SSP_SCR_15 (0x00000F00)
N#define SSP_SCR_16 (0x00001000)
N#define SSP_SCR_23 (0x00001700)
N#define SSP_SCR_47 (0x00003F00)
N
N
N
N/*  Current status of the SSP controller.  */
N#define SSP_SR_TFE_MASK (0x00000001) // Transmit FIFO empty
N#define SSP_SR_TFE_EMPTY (0x00000001)
N#define SSP_SR_TFE_NOTEMPTY (0x00000000)
N#define SSP_SR_TNF_MASK (0x00000002) // Transmit FIFO not full
N#define SSP_SR_TNF_NOTFULL (0x00000002)
N#define SSP_SR_TNF_FULL (0x00000000)
N#define SSP_SR_RNE_MASK (0x00000004) // Receive FIFO not empty
N#define SSP_SR_RNE_NOTEMPTY (0x00000004)
N#define SSP_SR_RNE_EMPTY (0x00000000)
N#define SSP_SR_RFF_MASK (0x00000008) // Receive FIFO full
N#define SSP_SR_RFF_FULL (0x00000008)
N#define SSP_SR_RFF_NOTFULL (0x00000000)
N#define SSP_SR_BSY_MASK (0x00000010) // Busy Flag
N#define SSP_SR_BSY_IDLE (0x00000000)
N#define SSP_SR_BSY_BUSY (0x00000010)
N
N/* Control Register 1 */
N#define SSP_CR1_LBM_MASK BIT0 // Loop back mode
N#define SSP_CR1_LBM_NORMAL (0)
N#define SSP_CR1_LBM_INVERTED BIT0 // MISO/MOSI are reversed
N#define SSP_CR1_SSE_MASK BIT1 // SSP enable
N#define SSP_CR1_SSE_DISABLED (0)
N#define SSP_CR1_SSE_ENABLED BIT1
N#define SSP_CR1_MS_MASK BIT2 // Master/Slave Mode
N#define SSP_CR1_MS_MASTER (0)
N#define SSP_CR1_MS_SLAVE BIT2
N#define SSP_CR1_SOD_MASK BIT2 // Slave output disable
N
N
N 
N
NINTERFACE void SSP0_IRQHandler(void); 
Xextern void SSP0_IRQHandler(void); 
NINTERFACE void SSP1_IRQHandler(void); 
Xextern void SSP1_IRQHandler(void); 
NINTERFACE void nsAPI_SSP_Init(void);
Xextern void nsAPI_SSP_Init(void);
NINTERFACE void nsAPI_SSP_Send(U8 *buf, U16 length);
Xextern void nsAPI_SSP_Send(U8 *buf, U16 length);
NINTERFACE void nsAPI_SSP_Receive(U8 *buf, U16 length);
Xextern void nsAPI_SSP_Receive(U8 *buf, U16 length);
N
N 
N#undef INTERFACE
N#ifdef __cplusplus
S}
N#endif
N#endif
L 35 "Src\system_LPC11Uxx.c" 2
N#include "I2c.h"
L 1 ".\Inc\I2c.h" 1
N/*****************************************************************************
N *   i2c.h:  Header file for NXP LPC11xx Family Microprocessors
N *
N *   Copyright(C) 2006, NXP Semiconductor
N *   All rights reserved.
N *
N *   History
N *   2006.07.19  ver 1.00    Preliminary version, first Release
N *
N******************************************************************************/
N#ifndef __I2C_H__ 
N#define __I2C_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "Type.h"
N
N#ifdef  __I2C_C__
S#define INTERFACE
N#else
N#define INTERFACE extern
N#endif
N
N#if 0
S#define _DEBUG_I2C_(x) x
N#else
N#define _DEBUG_I2C_(x) 
N#endif
N
N#define I2CBUFSIZE 4
N#define MAX_TIMEOUT 0x00FFFFFF
N
N#define AT24C512_ADDR 0xA0
N#define READ_STATUS 0x01
N
N#define I2C_BUS_IDLE 0
N#define I2C_BUS_WRITE 1
N#define I2C_BUS_READ 2
N
N#define I2C_IDLE 0
N#define I2C_DEVICEARD 1
N#define I2C_FWORDARD 2
N#define I2C_SWORDARD 3
N#define I2C_RESTARTED 4
N#define I2C_REPEATED_START 5
N#define DATA_ACK 6
N#define DATA_NACK 7
N
N#define I2CONSET_I2EN BIT6/* I2C Control Set Register */
N#define I2CONSET_AA BIT2
N#define I2CONSET_SI BIT3
N#define I2CONSET_STO BIT4
N#define I2CONSET_STA BIT5
N
N#define I2CONCLR_AAC BIT2/* I2C Control clear Register */
N#define I2CONCLR_SIC BIT3
N#define I2CONCLR_STAC BIT5
N#define I2CONCLR_I2ENC BIT6
N
N#define I2C_SPEED 400000UL//400K
N#define I2SCLH_SCLH (SystemCoreClock / I2C_SPEED) / 2/* I2C SCL Duty Cycle High Reg */
N#define I2SCLL_SCLL I2SCLH_SCLH/* I2C SCL Duty Cycle Low Reg */
N
Ntypedef struct _LPC11Uxx_I2C_Setting_
N{	
N	U8 I2CMasterState;
N	U8 I2CDeviceAdr;
N	U8 I2CBusState;		
N	U8 I2CMasterBuffer[I2CBUFSIZE];
X	U8 I2CMasterBuffer[4];
N	U8 I2CSlaveBuffer[I2CBUFSIZE];
X	U8 I2CSlaveBuffer[4];
N	U8 I2CReadLength;
N	U8 I2CWriteLength;	
N	U8 RdIndex;
N	U8 WrIndex;	
N	U16 I2CWordAdr;
N} LPC11Uxx_I2C_Setting;
N
NINTERFACE LPC11Uxx_I2C_Setting g_I2C_Setting;
Xextern LPC11Uxx_I2C_Setting g_I2C_Setting;
N
NINTERFACE void I2C_IRQHandler(void);
Xextern void I2C_IRQHandler(void);
NINTERFACE void nsAPI_I2C_Init(void);
Xextern void nsAPI_I2C_Init(void);
NINTERFACE void NDrv_API_I2C_Stop(void);
Xextern void NDrv_API_I2C_Stop(void);
NINTERFACE void nsAPI_I2C_Write(void);
Xextern void nsAPI_I2C_Write(void);
NINTERFACE void nsAPI_I2C_Read(void);
Xextern void nsAPI_I2C_Read(void);
NINTERFACE void nsAPI_I2C_Write_Database(U16 u16Adr,U8 *pBuf);
Xextern void nsAPI_I2C_Write_Database(U16 u16Adr,U8 *pBuf);
NINTERFACE RetU8 nsAPI_I2C_Read_Database(U16 u16Adr);
Xextern RetU8 nsAPI_I2C_Read_Database(U16 u16Adr);
N
N#undef INTERFACE
N#ifdef __cplusplus
S}
N#endif
N#endif /* end __I2C_H */
N
L 36 "Src\system_LPC11Uxx.c" 2
N
N/*----------------------------------------------------------------------------
N  Clock functions
N *----------------------------------------------------------------------------*/
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System.
N */
Nvoid nsAPI_System_Init(void)
N{
N	U8 i;
N
N	LPC_SYSCON->PDRUNCFG &= ~BIT5;				//Power-up System Osc
X	((LPC_SYSCON_Type *) (0x40048000))->PDRUNCFG &= ~(1 << 5);				
N	LPC_SYSCON->SYSOSCCTRL = SYSOSCCTRL_Val;
X	((LPC_SYSCON_Type *) (0x40048000))->SYSOSCCTRL = 0x00000000;
N	for (i = 0; i < 200; i++) __NOP();
X	for (i = 0; i < 200; i++) __nop();
N
N	LPC_SYSCON->SYSPLLCLKSEL = SYSPLLCLKSEL_Val;//Select PLL Input
X	((LPC_SYSCON_Type *) (0x40048000))->SYSPLLCLKSEL = 0x00000001;
N	LPC_SYSCON->SYSPLLCLKUEN = 0x01;			//Update Clock Source
X	((LPC_SYSCON_Type *) (0x40048000))->SYSPLLCLKUEN = 0x01;			
N	LPC_SYSCON->SYSPLLCLKUEN = 0x00;			//Toggle Update Register
X	((LPC_SYSCON_Type *) (0x40048000))->SYSPLLCLKUEN = 0x00;			
N	LPC_SYSCON->SYSPLLCLKUEN = 0x01;
X	((LPC_SYSCON_Type *) (0x40048000))->SYSPLLCLKUEN = 0x01;
N	while(!(LPC_SYSCON->SYSPLLCLKUEN & BIT0)){}	//Wait Until Updated
X	while(!(((LPC_SYSCON_Type *) (0x40048000))->SYSPLLCLKUEN & (1 << 0))){}	
N
N	LPC_SYSCON->SYSPLLCTRL = SYSPLLCTRL_Val;	//Main Clock is PLL Out
X	((LPC_SYSCON_Type *) (0x40048000))->SYSPLLCTRL = 0x00000023;	
N	LPC_SYSCON->PDRUNCFG &= ~BIT7;				//Power-up SYSPLL
X	((LPC_SYSCON_Type *) (0x40048000))->PDRUNCFG &= ~(1 << 7);				
N	while(!(LPC_SYSCON->SYSPLLSTAT & BIT0)){}	//Wait Until PLL Locked
X	while(!(((LPC_SYSCON_Type *) (0x40048000))->SYSPLLSTAT & (1 << 0))){}	
N
N	LPC_SYSCON->MAINCLKSEL = MAINCLKSEL_Val;	//Select PLL Clock Output
X	((LPC_SYSCON_Type *) (0x40048000))->MAINCLKSEL = 0x00000003;	
N	LPC_SYSCON->MAINCLKUEN = 0x01;				//Update MCLK Clock Source
X	((LPC_SYSCON_Type *) (0x40048000))->MAINCLKUEN = 0x01;				
N	LPC_SYSCON->MAINCLKUEN = 0x00;				//Toggle Update Register
X	((LPC_SYSCON_Type *) (0x40048000))->MAINCLKUEN = 0x00;				
N	LPC_SYSCON->MAINCLKUEN = 0x01;
X	((LPC_SYSCON_Type *) (0x40048000))->MAINCLKUEN = 0x01;
N	while (!(LPC_SYSCON->MAINCLKUEN & BIT0)){}	//Wait Until Updated
X	while (!(((LPC_SYSCON_Type *) (0x40048000))->MAINCLKUEN & (1 << 0))){}	
N
N	LPC_SYSCON->SYSAHBCLKDIV  = SYSAHBCLKDIV_Val;
X	((LPC_SYSCON_Type *) (0x40048000))->SYSAHBCLKDIV  = 0x00000001;
N	LPC_SYSCON->PDRUNCFG &= ~BIT10;				//Power-up USB PHY
X	((LPC_SYSCON_Type *) (0x40048000))->PDRUNCFG &= ~(1 << 10);				
N	LPC_SYSCON->PDRUNCFG &= ~BIT8;				//Power-up USB PLL
X	((LPC_SYSCON_Type *) (0x40048000))->PDRUNCFG &= ~(1 << 8);				
N	LPC_SYSCON->USBPLLCLKSEL = USBPLLCLKSEL_Val;//Select PLL Input
X	((LPC_SYSCON_Type *) (0x40048000))->USBPLLCLKSEL = 0x00000001;
N	LPC_SYSCON->USBPLLCLKUEN = 0x01;			//Update Clock Source
X	((LPC_SYSCON_Type *) (0x40048000))->USBPLLCLKUEN = 0x01;			
N	LPC_SYSCON->USBPLLCLKUEN = 0x00;			//Toggle Update Register
X	((LPC_SYSCON_Type *) (0x40048000))->USBPLLCLKUEN = 0x00;			
N	LPC_SYSCON->USBPLLCLKUEN = 0x01;
X	((LPC_SYSCON_Type *) (0x40048000))->USBPLLCLKUEN = 0x01;
N
N	while (!(LPC_SYSCON->USBPLLCLKUEN & BIT0)){}//Wait Until Updated
X	while (!(((LPC_SYSCON_Type *) (0x40048000))->USBPLLCLKUEN & (1 << 0))){}
N	LPC_SYSCON->USBPLLCTRL = USBPLLCTRL_Val;
X	((LPC_SYSCON_Type *) (0x40048000))->USBPLLCTRL = 0x00000023;
N
N	while (!(LPC_SYSCON->USBPLLSTAT & BIT0)){}	//Wait Until PLL Locked
X	while (!(((LPC_SYSCON_Type *) (0x40048000))->USBPLLSTAT & (1 << 0))){}	
N	LPC_SYSCON->USBCLKSEL = 0x00;				//Select USB PLL
X	((LPC_SYSCON_Type *) (0x40048000))->USBCLKSEL = 0x00;				
N	LPC_SYSCON->USBCLKSEL = USBCLKSEL_Val;		//Select USB Clock
X	((LPC_SYSCON_Type *) (0x40048000))->USBCLKSEL = 0x00000000;		
N	LPC_SYSCON->USBCLKDIV = USBCLKDIV_Val;		//Set USB clock divider
X	((LPC_SYSCON_Type *) (0x40048000))->USBCLKDIV = 0x00000001;		
N
N	//System clock to the IOCON needs to be enabled or
N	//most of the I/O related peripherals won't work.
N	LPC_SYSCON->SYSAHBCLKCTRL |= BIT16;
X	((LPC_SYSCON_Type *) (0x40048000))->SYSAHBCLKCTRL |= (1 << 16);
N
N	SystemCoreClock = (__SYS_OSC_CLK * ((LPC_SYSCON->SYSPLLCTRL & 0x01F) + 1));
X	SystemCoreClock = (((12000000UL)) * ((((LPC_SYSCON_Type *) (0x40048000))->SYSPLLCTRL & 0x01F) + 1));
N	SystemCoreClock /= LPC_SYSCON->SYSAHBCLKDIV;
X	SystemCoreClock /= ((LPC_SYSCON_Type *) (0x40048000))->SYSAHBCLKDIV;
N
N	nsAPI_UART_Init(BR);
X	nsAPI_UART_Init(115200);
N	nsAPI_I2C_Init();
N	nsAPI_GPIO_Init();
N	nsAPI_USB_Init();							// USB Initialization
N	nsAPI_Timer16_Init(Timer16_0,1); 			// ms resolution setup
X	nsAPI_Timer16_Init(0,1); 			
N	nsAPI_SysTick_Init();
N	nsAPI_SSP_Init(); //SPI init
N	//xprintf("\r\n SystemCoreClock = %d MHz", SystemCoreClock / 1000000UL);
N}
