; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\obj\uart.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\INC\NXP\LPC11Uxx -D__MICROLIB -D__UVISION_VERSION=536 -D__DEBUG_FLASH --omf_browse=.\obj\uart.crf Src\uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  UART_IRQHandler PROC
;;;35     *****************************************************************************/
;;;36     void UART_IRQHandler(void)
000000  b530              PUSH     {r4,r5,lr}
;;;37     {
;;;38     	U8 IIRValue, LSRValue,Dummy;
;;;39     
;;;40     	IIRValue = LPC_USART->IIR;
000002  4bb0              LDR      r3,|L1.708|
000004  689b              LDR      r3,[r3,#8]
000006  b2da              UXTB     r2,r3
;;;41     
;;;42     	IIRValue >>= 1;/* skip pending bit in IIR */
000008  1052              ASRS     r2,r2,#1
;;;43     	IIRValue &= 0x07;/* check bit 1~3, interrupt identification */
00000a  0752              LSLS     r2,r2,#29
00000c  0f52              LSRS     r2,r2,#29
;;;44       
;;;45     	switch(IIRValue)
00000e  2a01              CMP      r2,#1
000010  d061              BEQ      |L1.214|
000012  2a02              CMP      r2,#2
000014  d038              BEQ      |L1.136|
000016  2a03              CMP      r2,#3
000018  d002              BEQ      |L1.32|
00001a  2a06              CMP      r2,#6
00001c  d16d              BNE      |L1.250|
00001e  e052              B        |L1.198|
                  |L1.32|
;;;46     	{
;;;47     		case  IIR_RLS:/* Receive Line Status */	
;;;48     		LSRValue = LPC_USART->LSR;
000020  4ba8              LDR      r3,|L1.708|
000022  695b              LDR      r3,[r3,#0x14]
000024  b2d9              UXTB     r1,r3
;;;49     		/* Receive Line Status */
;;;50     		if(LSRValue & (LSR_OE | LSR_PE | LSR_FE | LSR_RXFE | LSR_BI))
000026  239e              MOVS     r3,#0x9e
000028  400b              ANDS     r3,r3,r1
00002a  2b00              CMP      r3,#0
00002c  d005              BEQ      |L1.58|
;;;51     		{
;;;52     			/* There are errors or break interrupt */
;;;53     			/* Read LSR will clear the interrupt */
;;;54     			g_Uart_Setting.UartStatus = LSRValue;
00002e  4ba6              LDR      r3,|L1.712|
000030  6019              STR      r1,[r3,#0]  ; g_Uart_Setting
;;;55     			Dummy = LPC_USART->RBR;	/* Dummy read on RX to clear 
000032  4ba4              LDR      r3,|L1.708|
000034  681b              LDR      r3,[r3,#0]
000036  b2d8              UXTB     r0,r3
;;;56     			interrupt, then bail out */
;;;57     			break;
000038  e05f              B        |L1.250|
                  |L1.58|
;;;58     		}
;;;59     		
;;;60     		if(LSRValue & LSR_RDR)	/* Receive Data Ready */			
00003a  07cb              LSLS     r3,r1,#31
00003c  0fdb              LSRS     r3,r3,#31
00003e  2b00              CMP      r3,#0
000040  d021              BEQ      |L1.134|
;;;61     		{
;;;62     			/* If no error on RLS, normal ready, save into the data buffer. */
;;;63     			/* Note: read RBR will clear the interrupt */
;;;64     			g_Uart_Setting.UartBuffer[g_Uart_Setting.UartCount] = LPC_USART->RBR;
000042  4ba0              LDR      r3,|L1.708|
000044  681b              LDR      r3,[r3,#0]
000046  b2dc              UXTB     r4,r3
000048  4b9f              LDR      r3,|L1.712|
00004a  7e1d              LDRB     r5,[r3,#0x18]  ; g_Uart_Setting
00004c  1d1b              ADDS     r3,r3,#4
00004e  555c              STRB     r4,[r3,r5]
;;;65     			g_Uart_Setting.UartCount++;
000050  1f1b              SUBS     r3,r3,#4
000052  7e1b              LDRB     r3,[r3,#0x18]  ; g_Uart_Setting
000054  1c5b              ADDS     r3,r3,#1
000056  4c9c              LDR      r4,|L1.712|
000058  7623              STRB     r3,[r4,#0x18]
;;;66     
;;;67     			if (g_Uart_Setting.UartCount > UARTBUFSIZE)   
00005a  4623              MOV      r3,r4
00005c  7e1b              LDRB     r3,[r3,#0x18]  ; g_Uart_Setting
00005e  2b14              CMP      r3,#0x14
000060  dd11              BLE      |L1.134|
;;;68     			{
;;;69     				g_Uart_Setting.UartCount = 0;/*buffer overflow*/
000062  2300              MOVS     r3,#0
000064  7623              STRB     r3,[r4,#0x18]
;;;70     				g_Uart_Setting.UartStatus |= LSR_OE;
000066  4623              MOV      r3,r4
000068  681b              LDR      r3,[r3,#0]  ; g_Uart_Setting
00006a  2402              MOVS     r4,#2
00006c  4323              ORRS     r3,r3,r4
00006e  4c96              LDR      r4,|L1.712|
000070  6023              STR      r3,[r4,#0]  ; g_Uart_Setting
;;;71     
;;;72     				for(Dummy = 0; Dummy < UARTBUFSIZE; Dummy++)
000072  2000              MOVS     r0,#0
000074  e005              B        |L1.130|
                  |L1.118|
;;;73     				g_Uart_Setting.UartBuffer[Dummy] = 0xFF;	
000076  24ff              MOVS     r4,#0xff
000078  4b93              LDR      r3,|L1.712|
00007a  1d1b              ADDS     r3,r3,#4
00007c  541c              STRB     r4,[r3,r0]
00007e  1c43              ADDS     r3,r0,#1              ;72
000080  b2d8              UXTB     r0,r3                 ;72
                  |L1.130|
000082  2814              CMP      r0,#0x14              ;72
000084  dbf7              BLT      |L1.118|
                  |L1.134|
;;;74     			}			
;;;75     		}
;;;76     		break;
000086  e038              B        |L1.250|
                  |L1.136|
;;;77     	
;;;78     		case IIR_RDA:/* Receive Data Available */	
;;;79     		/* Receive Data Available */
;;;80     		g_Uart_Setting.UartBuffer[g_Uart_Setting.UartCount] = LPC_USART->RBR;
000088  4b8e              LDR      r3,|L1.708|
00008a  681b              LDR      r3,[r3,#0]
00008c  b2dc              UXTB     r4,r3
00008e  4b8e              LDR      r3,|L1.712|
000090  7e1d              LDRB     r5,[r3,#0x18]  ; g_Uart_Setting
000092  1d1b              ADDS     r3,r3,#4
000094  555c              STRB     r4,[r3,r5]
;;;81     		g_Uart_Setting.UartCount++;
000096  1f1b              SUBS     r3,r3,#4
000098  7e1b              LDRB     r3,[r3,#0x18]  ; g_Uart_Setting
00009a  1c5b              ADDS     r3,r3,#1
00009c  4c8a              LDR      r4,|L1.712|
00009e  7623              STRB     r3,[r4,#0x18]
;;;82     
;;;83     		if(g_Uart_Setting.UartCount > UARTBUFSIZE)   
0000a0  4623              MOV      r3,r4
0000a2  7e1b              LDRB     r3,[r3,#0x18]  ; g_Uart_Setting
0000a4  2b14              CMP      r3,#0x14
0000a6  dd0d              BLE      |L1.196|
;;;84     		{
;;;85     			g_Uart_Setting.UartCount = 0;/* buffer overflow */	
0000a8  2300              MOVS     r3,#0
0000aa  7623              STRB     r3,[r4,#0x18]
;;;86     			g_Uart_Setting.UartStatus = LSR_OE;
0000ac  2302              MOVS     r3,#2
0000ae  6023              STR      r3,[r4,#0]  ; g_Uart_Setting
;;;87     
;;;88     			for(Dummy = 0; Dummy< UARTBUFSIZE; Dummy++)
0000b0  2000              MOVS     r0,#0
0000b2  e005              B        |L1.192|
                  |L1.180|
;;;89     			g_Uart_Setting.UartBuffer[Dummy] = 0xFF;	
0000b4  24ff              MOVS     r4,#0xff
0000b6  4b84              LDR      r3,|L1.712|
0000b8  1d1b              ADDS     r3,r3,#4
0000ba  541c              STRB     r4,[r3,r0]
0000bc  1c43              ADDS     r3,r0,#1              ;88
0000be  b2d8              UXTB     r0,r3                 ;88
                  |L1.192|
0000c0  2814              CMP      r0,#0x14              ;88
0000c2  dbf7              BLT      |L1.180|
                  |L1.196|
;;;90     		}
;;;91     		break;
0000c4  e019              B        |L1.250|
                  |L1.198|
;;;92     	
;;;93     		case IIR_CTI:	/* Character timeout indicator */	
;;;94     		/* Character Time-out indicator */
;;;95     		g_Uart_Setting.UartStatus |= 0x100;/* Bit 9 as the CTI error */
0000c6  4b80              LDR      r3,|L1.712|
0000c8  681b              LDR      r3,[r3,#0]  ; g_Uart_Setting
0000ca  24ff              MOVS     r4,#0xff
0000cc  3401              ADDS     r4,#1
0000ce  4323              ORRS     r3,r3,r4
0000d0  4c7d              LDR      r4,|L1.712|
0000d2  6023              STR      r3,[r4,#0]  ; g_Uart_Setting
;;;96     		break;
0000d4  e011              B        |L1.250|
                  |L1.214|
;;;97     	
;;;98     		case IIR_THRE:/* THRE, transmit holding register empty */	
;;;99     		/* THRE interrupt */
;;;100    		LSRValue = LPC_USART->LSR;/* Check status in the LSR to see if valid data in U0THR or not */
0000d6  4b7b              LDR      r3,|L1.708|
0000d8  695b              LDR      r3,[r3,#0x14]
0000da  b2d9              UXTB     r1,r3
;;;101    
;;;102    		if(LSRValue & LSR_THRE)   
0000dc  2320              MOVS     r3,#0x20
0000de  400b              ANDS     r3,r3,r1
0000e0  2b00              CMP      r3,#0
0000e2  d003              BEQ      |L1.236|
;;;103    		g_Uart_Setting.UartStatus = LSR_THRE;	    
0000e4  2320              MOVS     r3,#0x20
0000e6  4c78              LDR      r4,|L1.712|
0000e8  6023              STR      r3,[r4,#0]  ; g_Uart_Setting
0000ea  e005              B        |L1.248|
                  |L1.236|
;;;104    		else   
;;;105    		g_Uart_Setting.UartStatus &= ~LSR_THRE;	 
0000ec  4b76              LDR      r3,|L1.712|
0000ee  681b              LDR      r3,[r3,#0]  ; g_Uart_Setting
0000f0  2420              MOVS     r4,#0x20
0000f2  43a3              BICS     r3,r3,r4
0000f4  4c74              LDR      r4,|L1.712|
0000f6  6023              STR      r3,[r4,#0]  ; g_Uart_Setting
                  |L1.248|
;;;106    		break;
0000f8  bf00              NOP      
                  |L1.250|
0000fa  bf00              NOP                            ;57
;;;107    	}
;;;108    }
0000fc  bd30              POP      {r4,r5,pc}
;;;109    
                          ENDP

                  nsAPI_UART_Init PROC
;;;119    *****************************************************************************/
;;;120    void nsAPI_UART_Init(U32 baudrate)
0000fe  b5f8              PUSH     {r3-r7,lr}
;;;121    {
000100  4605              MOV      r5,r0
;;;122    	U32 Fdiv,regVal;  
;;;123    
;;;124    	g_Uart_Setting.UartStatus = LSR_THRE;	
000102  2020              MOVS     r0,#0x20
000104  4970              LDR      r1,|L1.712|
000106  6008              STR      r0,[r1,#0]  ; g_Uart_Setting
;;;125    	g_Uart_Setting.UartCount = 0;
000108  2000              MOVS     r0,#0
00010a  7608              STRB     r0,[r1,#0x18]
;;;126    
;;;127    	for(Fdiv = 0; Fdiv < UARTBUFSIZE; Fdiv++)
00010c  2400              MOVS     r4,#0
00010e  e004              B        |L1.282|
                  |L1.272|
;;;128    	g_Uart_Setting.UartBuffer[Fdiv] = 0xFF;	
000110  21ff              MOVS     r1,#0xff
000112  486d              LDR      r0,|L1.712|
000114  1d00              ADDS     r0,r0,#4
000116  5501              STRB     r1,[r0,r4]
000118  1c64              ADDS     r4,r4,#1              ;127
                  |L1.282|
00011a  2c14              CMP      r4,#0x14              ;127
00011c  d3f8              BCC      |L1.272|
;;;129    
;;;130    	NVIC_DisableIRQ(UART_IRQn);
00011e  2015              MOVS     r0,#0x15
000120  2101              MOVS     r1,#1
000122  4081              LSLS     r1,r1,r0
000124  4a69              LDR      r2,|L1.716|
000126  6011              STR      r1,[r2,#0]
000128  bf00              NOP      
;;;131    	/* Select only one location from below. */
;;;132    
;;;133    	LPC_IOCON->PIO0_18 &= ~0x07;/*UART I/O config*/
00012a  4869              LDR      r0,|L1.720|
00012c  6880              LDR      r0,[r0,#8]
00012e  08c0              LSRS     r0,r0,#3
000130  00c0              LSLS     r0,r0,#3
000132  4967              LDR      r1,|L1.720|
000134  6088              STR      r0,[r1,#8]
;;;134    	LPC_IOCON->PIO0_18 |= 0x01;/*UART RXD*/
000136  4608              MOV      r0,r1
000138  6880              LDR      r0,[r0,#8]
00013a  2101              MOVS     r1,#1
00013c  4308              ORRS     r0,r0,r1
00013e  4964              LDR      r1,|L1.720|
000140  6088              STR      r0,[r1,#8]
;;;135    	LPC_IOCON->PIO0_19 &= ~0x07;	
000142  4608              MOV      r0,r1
000144  68c0              LDR      r0,[r0,#0xc]
000146  08c0              LSRS     r0,r0,#3
000148  00c0              LSLS     r0,r0,#3
00014a  60c8              STR      r0,[r1,#0xc]
;;;136    	LPC_IOCON->PIO0_19 |= 0x01;/*UART TXD*/
00014c  4608              MOV      r0,r1
00014e  68c0              LDR      r0,[r0,#0xc]
000150  2101              MOVS     r1,#1
000152  4308              ORRS     r0,r0,r1
000154  495e              LDR      r1,|L1.720|
000156  60c8              STR      r0,[r1,#0xc]
;;;137    
;;;138    	/* Enable UART clock */
;;;139    	LPC_SYSCON->SYSAHBCLKCTRL |= BIT12;
000158  485e              LDR      r0,|L1.724|
00015a  6800              LDR      r0,[r0,#0]
00015c  2101              MOVS     r1,#1
00015e  0309              LSLS     r1,r1,#12
000160  4308              ORRS     r0,r0,r1
000162  495c              LDR      r1,|L1.724|
000164  6008              STR      r0,[r1,#0]
;;;140    	LPC_SYSCON->UARTCLKDIV = BIT0;/* divided by 1 */
000166  2001              MOVS     r0,#1
000168  6188              STR      r0,[r1,#0x18]
;;;141    
;;;142    	LPC_USART->LCR = 0x83;/* 8 bits, no Parity, 1 Stop bit */
00016a  2083              MOVS     r0,#0x83
00016c  4955              LDR      r1,|L1.708|
00016e  60c8              STR      r0,[r1,#0xc]
;;;143    	regVal = LPC_SYSCON->UARTCLKDIV;
000170  4858              LDR      r0,|L1.724|
000172  6986              LDR      r6,[r0,#0x18]
;;;144    	Fdiv = ((SystemCoreClock/regVal)/16)/baudrate;/*baud rate */
000174  4631              MOV      r1,r6
000176  4858              LDR      r0,|L1.728|
000178  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00017a  f7fffffe          BL       __aeabi_uidivmod
00017e  0907              LSRS     r7,r0,#4
000180  4629              MOV      r1,r5
000182  4638              MOV      r0,r7
000184  f7fffffe          BL       __aeabi_uidivmod
000188  4604              MOV      r4,r0
;;;145    
;;;146    	LPC_USART->DLM = Fdiv >> 8;							
00018a  0a20              LSRS     r0,r4,#8
00018c  494d              LDR      r1,|L1.708|
00018e  6048              STR      r0,[r1,#4]
;;;147    	LPC_USART->DLL = Fdiv % 256;
000190  b2e0              UXTB     r0,r4
000192  6008              STR      r0,[r1,#0]
;;;148    	LPC_USART->LCR = 0x03;/* DLAB = 0 */
000194  2003              MOVS     r0,#3
000196  60c8              STR      r0,[r1,#0xc]
;;;149    	LPC_USART->FCR = 0x07;/* Enable and reset TX and RX FIFO. */
000198  2007              MOVS     r0,#7
00019a  6088              STR      r0,[r1,#8]
;;;150    
;;;151    	/* Read to clear the line status */
;;;152    	regVal = LPC_USART->LSR;
00019c  4608              MOV      r0,r1
00019e  6946              LDR      r6,[r0,#0x14]
;;;153    
;;;154    	/* Ensure a clean start, no data in either TX or RX FIFO. */
;;;155    	while(( LPC_USART->LSR & (LSR_THRE|LSR_TEMT)) != (LSR_THRE|LSR_TEMT)){}
0001a0  bf00              NOP      
                  |L1.418|
0001a2  4848              LDR      r0,|L1.708|
0001a4  6940              LDR      r0,[r0,#0x14]
0001a6  2160              MOVS     r1,#0x60
0001a8  4008              ANDS     r0,r0,r1
0001aa  2860              CMP      r0,#0x60
0001ac  d1f9              BNE      |L1.418|
;;;156    	while(LPC_USART->LSR & LSR_RDR )
0001ae  e001              B        |L1.436|
                  |L1.432|
;;;157    	{
;;;158    		regVal = LPC_USART->RBR;	/* Dump data from RX FIFO */
0001b0  4844              LDR      r0,|L1.708|
0001b2  6806              LDR      r6,[r0,#0]
                  |L1.436|
0001b4  4843              LDR      r0,|L1.708|
0001b6  6940              LDR      r0,[r0,#0x14]         ;156
0001b8  07c0              LSLS     r0,r0,#31             ;156
0001ba  0fc0              LSRS     r0,r0,#31             ;156
0001bc  2800              CMP      r0,#0                 ;156
0001be  d1f7              BNE      |L1.432|
;;;159    	}
;;;160    
;;;161    	/* Enable the UART Interrupt */
;;;162    	NVIC_EnableIRQ(UART_IRQn);
0001c0  2015              MOVS     r0,#0x15
0001c2  2101              MOVS     r1,#1
0001c4  4081              LSLS     r1,r1,r0
0001c6  4a41              LDR      r2,|L1.716|
0001c8  3a80              SUBS     r2,r2,#0x80
0001ca  6011              STR      r1,[r2,#0]
0001cc  bf00              NOP      
;;;163    
;;;164    #if TX_INTERRUPT
;;;165    	LPC_USART->IER = IER_RBR | IER_THRE | IER_RLS;/* Enable UART interrupt */
;;;166    #else
;;;167    	LPC_USART->IER = IER_RBR | IER_RLS;/* Enable UART interrupt */
0001ce  2005              MOVS     r0,#5
0001d0  493c              LDR      r1,|L1.708|
0001d2  6048              STR      r0,[r1,#4]
;;;168    #endif
;;;169    }
0001d4  bdf8              POP      {r3-r7,pc}
;;;170    
                          ENDP

                  nsAPI_UART_Send PROC
;;;180    *****************************************************************************/
;;;181    void nsAPI_UART_Send(U8 *BufferPtr, U32 Length)
0001d6  e00b              B        |L1.496|
                  |L1.472|
;;;182    {  
;;;183    	while(Length != 0)
;;;184    	{
;;;185    		/* THRE status, contain valid data */
;;;186    #if !TX_INTERRUPT
;;;187    		while(!(LPC_USART->LSR & LSR_THRE)){}
0001d8  bf00              NOP      
                  |L1.474|
0001da  4a3a              LDR      r2,|L1.708|
0001dc  6952              LDR      r2,[r2,#0x14]
0001de  2320              MOVS     r3,#0x20
0001e0  401a              ANDS     r2,r2,r3
0001e2  2a00              CMP      r2,#0
0001e4  d0f9              BEQ      |L1.474|
;;;188    		LPC_USART->THR = *BufferPtr;
0001e6  7802              LDRB     r2,[r0,#0]
0001e8  4b36              LDR      r3,|L1.708|
0001ea  601a              STR      r2,[r3,#0]
;;;189    #else
;;;190    		/* Below flag is set inside the interrupt handler when THRE occurs. */
;;;191    		while (!(g_Uart_Setting.UartStatus & LSR_THRE)){}
;;;192    		LPC_USART->THR = *BufferPtr;
;;;193    		g_Uart_Setting.UartStatus &= ~LSR_THRE; /* not empty in the THR until it shifts out */
;;;194    #endif
;;;195    		BufferPtr++;
0001ec  1c40              ADDS     r0,r0,#1
;;;196    		Length--;
0001ee  1e49              SUBS     r1,r1,#1
                  |L1.496|
0001f0  2900              CMP      r1,#0                 ;183
0001f2  d1f1              BNE      |L1.472|
;;;197    	}
;;;198    }
0001f4  4770              BX       lr
;;;199    
                          ENDP

                  xprintf PROC
;;;200    void xprintf(U8 *pFmt,U32 wVal,...)
0001f6  b5f0              PUSH     {r4-r7,lr}
;;;201    {
0001f8  b085              SUB      sp,sp,#0x14
0001fa  4604              MOV      r4,r0
0001fc  460f              MOV      r7,r1
;;;202    	U8 ucBff,ucDisp;
;;;203    	U8 bHex = FALSE,u8Into = 0,bNotZero = FALSE;   
0001fe  2000              MOVS     r0,#0
000200  9002              STR      r0,[sp,#8]
000202  9001              STR      r0,[sp,#4]
000204  9000              STR      r0,[sp,#0]
;;;204    	U32 wDivider = 10000000;	
000206  4e35              LDR      r6,|L1.732|
;;;205    
;;;206    
;;;207    	//LPC_USART->IER = IER_THRE | IER_RLS;/* Disable RBR */
;;;208    
;;;209    	while((ucBff =*(pFmt++)) > 0)
000208  e054              B        |L1.692|
                  |L1.522|
;;;210    	{	
;;;211    		if(ucBff == '%') // check special case
00020a  4668              MOV      r0,sp
00020c  7b00              LDRB     r0,[r0,#0xc]
00020e  2825              CMP      r0,#0x25
000210  d14c              BNE      |L1.684|
;;;212    		{
;;;213    			u8Into++;  		 
000212  9801              LDR      r0,[sp,#4]
000214  1c40              ADDS     r0,r0,#1
000216  b2c0              UXTB     r0,r0
000218  9001              STR      r0,[sp,#4]
;;;214    			switch(*(pFmt++)) // check next character
00021a  7821              LDRB     r1,[r4,#0]
00021c  1c64              ADDS     r4,r4,#1
00021e  2958              CMP      r1,#0x58
000220  d006              BEQ      |L1.560|
000222  2964              CMP      r1,#0x64
000224  d009              BEQ      |L1.570|
000226  2969              CMP      r1,#0x69
000228  d008              BEQ      |L1.572|
00022a  2978              CMP      r1,#0x78
00022c  d13d              BNE      |L1.682|
;;;215    			{
;;;216    				case 'x': // hexadecimal number
;;;217    				case 'X':
00022e  bf00              NOP      
                  |L1.560|
;;;218    				wDivider = 0x10000000;
000230  2601              MOVS     r6,#1
000232  0736              LSLS     r6,r6,#28
;;;219    				bHex = TRUE;
000234  2001              MOVS     r0,#1
000236  9002              STR      r0,[sp,#8]
;;;220    				case 'd': // decimal number
000238  bf00              NOP      
                  |L1.570|
;;;221    				case 'i':
00023a  bf00              NOP      
                  |L1.572|
;;;222    
;;;223    				if(wVal)
00023c  2f00              CMP      r7,#0
00023e  d02d              BEQ      |L1.668|
;;;224    				{
;;;225    					while(wDivider)
000240  e029              B        |L1.662|
                  |L1.578|
;;;226    					{
;;;227    						ucDisp = wVal / wDivider;
000242  4631              MOV      r1,r6
000244  4638              MOV      r0,r7
000246  f7fffffe          BL       __aeabi_uidivmod
00024a  b2c5              UXTB     r5,r0
;;;228    						wVal = wVal % wDivider;
00024c  4631              MOV      r1,r6
00024e  4638              MOV      r0,r7
000250  f7fffffe          BL       __aeabi_uidivmod
000254  460f              MOV      r7,r1
;;;229    
;;;230    						if(ucDisp)
000256  2d00              CMP      r5,#0
000258  d001              BEQ      |L1.606|
;;;231    						bNotZero=TRUE;					
00025a  2001              MOVS     r0,#1
00025c  9000              STR      r0,[sp,#0]
                  |L1.606|
;;;232    
;;;233    						if(bNotZero)
00025e  9800              LDR      r0,[sp,#0]
000260  2800              CMP      r0,#0
000262  d00e              BEQ      |L1.642|
;;;234    						{
;;;235    							if(ucDisp > 9)
000264  2d09              CMP      r5,#9
000266  dd04              BLE      |L1.626|
;;;236    							ucBff = ucDisp-0x0a+'A';
000268  4628              MOV      r0,r5
00026a  3037              ADDS     r0,r0,#0x37
00026c  b2c0              UXTB     r0,r0
00026e  9003              STR      r0,[sp,#0xc]
000270  e003              B        |L1.634|
                  |L1.626|
;;;237    							else
;;;238    							ucBff = ucDisp+'0';
000272  4628              MOV      r0,r5
000274  3030              ADDS     r0,r0,#0x30
000276  b2c0              UXTB     r0,r0
000278  9003              STR      r0,[sp,#0xc]
                  |L1.634|
;;;239    
;;;240    							nsAPI_UART_Send(&ucBff,1);
00027a  2101              MOVS     r1,#1
00027c  a803              ADD      r0,sp,#0xc
00027e  f7fffffe          BL       nsAPI_UART_Send
                  |L1.642|
;;;241    						}					
;;;242    
;;;243    						if(bHex)
000282  9802              LDR      r0,[sp,#8]
000284  2800              CMP      r0,#0
000286  d001              BEQ      |L1.652|
;;;244    						wDivider /= 0x10;
000288  0936              LSRS     r6,r6,#4
00028a  e004              B        |L1.662|
                  |L1.652|
;;;245    						else
;;;246    						wDivider /= 10;
00028c  210a              MOVS     r1,#0xa
00028e  4630              MOV      r0,r6
000290  f7fffffe          BL       __aeabi_uidivmod
000294  4606              MOV      r6,r0
                  |L1.662|
000296  2e00              CMP      r6,#0                 ;225
000298  d1d3              BNE      |L1.578|
00029a  e005              B        |L1.680|
                  |L1.668|
;;;247    					}
;;;248    				}
;;;249    				else
;;;250    				{
;;;251    					ucBff = '0';
00029c  2030              MOVS     r0,#0x30
00029e  9003              STR      r0,[sp,#0xc]
;;;252    					nsAPI_UART_Send(&ucBff,1);
0002a0  2101              MOVS     r1,#1
0002a2  a803              ADD      r0,sp,#0xc
0002a4  f7fffffe          BL       nsAPI_UART_Send
                  |L1.680|
;;;253    				}		   
;;;254    				break;				
0002a8  bf00              NOP      
                  |L1.682|
0002aa  e003              B        |L1.692|
                  |L1.684|
;;;255    			}
;;;256    		}
;;;257    		else // general
;;;258    		nsAPI_UART_Send(&ucBff,1); 
0002ac  2101              MOVS     r1,#1
0002ae  a803              ADD      r0,sp,#0xc
0002b0  f7fffffe          BL       nsAPI_UART_Send
                  |L1.692|
0002b4  7821              LDRB     r1,[r4,#0]            ;209
0002b6  1c64              ADDS     r4,r4,#1              ;209
0002b8  9103              STR      r1,[sp,#0xc]          ;209
0002ba  2900              CMP      r1,#0                 ;209
0002bc  dca5              BGT      |L1.522|
;;;259    	} 
;;;260    }
0002be  b005              ADD      sp,sp,#0x14
0002c0  bdf0              POP      {r4-r7,pc}
;;;261    
                          ENDP

0002c2  0000              DCW      0x0000
                  |L1.708|
                          DCD      0x40008000
                  |L1.712|
                          DCD      g_Uart_Setting
                  |L1.716|
                          DCD      0xe000e180
                  |L1.720|
                          DCD      0x40044040
                  |L1.724|
                          DCD      0x40048080
                  |L1.728|
                          DCD      SystemCoreClock
                  |L1.732|
                          DCD      0x00989680

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_Uart_Setting
                          %        28

;*** Start embedded assembler ***

#line 1 "Src\\uart.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_6d57c09f____REV16|
#line 112 ".\\Inc\\core_cmInstr.h"
|__asm___6_uart_c_6d57c09f____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_6d57c09f____REVSH|
#line 130
|__asm___6_uart_c_6d57c09f____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
