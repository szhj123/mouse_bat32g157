; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\timer16.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\obj\timer16.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I.\Inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\INC\NXP\LPC11Uxx -D__MICROLIB -D__UVISION_VERSION=536 -D__DEBUG_FLASH --omf_browse=.\obj\timer16.crf Src\timer16.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIMER16_0_IRQHandler PROC
;;;36     ******************************************************************************/
;;;37     void TIMER16_0_IRQHandler(void)
000000  4875              LDR      r0,|L1.472|
;;;38     {
;;;39     	if(LPC_CT16B0->IR & BIT0)
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  0fc0              LSRS     r0,r0,#31
000008  2800              CMP      r0,#0
00000a  d044              BEQ      |L1.150|
;;;40     	{
;;;41     		LPC_CT16B0->IR = BIT0;/*Clear interrupt flag */
00000c  2001              MOVS     r0,#1
00000e  4972              LDR      r1,|L1.472|
000010  6008              STR      r0,[r1,#0]
;;;42     		g_Timer16_Setting.Timer16_0_Counter[0]++;	// Dennis: what is this for?
000012  4872              LDR      r0,|L1.476|
000014  6800              LDR      r0,[r0,#0]  ; g_Timer16_Setting
000016  1c40              ADDS     r0,r0,#1
000018  4970              LDR      r1,|L1.476|
00001a  6008              STR      r0,[r1,#0]  ; g_Timer16_Setting
;;;43     		poll_tick_btn++;
00001c  4870              LDR      r0,|L1.480|
00001e  8800              LDRH     r0,[r0,#0]  ; poll_tick_btn
000020  1c40              ADDS     r0,r0,#1
000022  496f              LDR      r1,|L1.480|
000024  8008              STRH     r0,[r1,#0]
;;;44     		poll_usb++;
000026  486f              LDR      r0,|L1.484|
000028  8800              LDRH     r0,[r0,#0]  ; poll_usb
00002a  1c40              ADDS     r0,r0,#1
00002c  496d              LDR      r1,|L1.484|
00002e  8008              STRH     r0,[r1,#0]
;;;45     		poll_id++;
000030  486d              LDR      r0,|L1.488|
000032  8800              LDRH     r0,[r0,#0]  ; poll_id
000034  1c40              ADDS     r0,r0,#1
000036  496c              LDR      r1,|L1.488|
000038  8008              STRH     r0,[r1,#0]
;;;46     		poll_z_wheel++;
00003a  486c              LDR      r0,|L1.492|
00003c  8800              LDRH     r0,[r0,#0]  ; poll_z_wheel
00003e  1c40              ADDS     r0,r0,#1
000040  496a              LDR      r1,|L1.492|
000042  8008              STRH     r0,[r1,#0]
;;;47     		poll_motion++;
000044  486a              LDR      r0,|L1.496|
000046  8800              LDRH     r0,[r0,#0]  ; poll_motion
000048  1c40              ADDS     r0,r0,#1
00004a  4969              LDR      r1,|L1.496|
00004c  8008              STRH     r0,[r1,#0]
;;;48     		poll_counter++;
00004e  4869              LDR      r0,|L1.500|
000050  8800              LDRH     r0,[r0,#0]  ; poll_counter
000052  1c40              ADDS     r0,r0,#1
000054  4967              LDR      r1,|L1.500|
000056  8008              STRH     r0,[r1,#0]
;;;49     
;;;50     		if (glitch_prevention>0)
000058  4867              LDR      r0,|L1.504|
00005a  8800              LDRH     r0,[r0,#0]  ; glitch_prevention
00005c  2800              CMP      r0,#0
00005e  dd04              BLE      |L1.106|
;;;51     		glitch_prevention--;
000060  4865              LDR      r0,|L1.504|
000062  8800              LDRH     r0,[r0,#0]  ; glitch_prevention
000064  1e40              SUBS     r0,r0,#1
000066  4964              LDR      r1,|L1.504|
000068  8008              STRH     r0,[r1,#0]
                  |L1.106|
;;;52     
;;;53     		if (cpi_clicked_flag) {
00006a  4864              LDR      r0,|L1.508|
00006c  8800              LDRH     r0,[r0,#0]  ; cpi_clicked_flag
00006e  2800              CMP      r0,#0
000070  d011              BEQ      |L1.150|
;;;54     			if( g_GpioButtonEvent.ButtonEvent == CPI_P_CLICKED) 
000072  4863              LDR      r0,|L1.512|
000074  8840              LDRH     r0,[r0,#2]  ; g_GpioButtonEvent
000076  2808              CMP      r0,#8
000078  d104              BNE      |L1.132|
;;;55     			{
;;;56     				cpi_p_Cntr++;		
00007a  4862              LDR      r0,|L1.516|
00007c  7800              LDRB     r0,[r0,#0]  ; cpi_p_Cntr
00007e  1c40              ADDS     r0,r0,#1
000080  4960              LDR      r1,|L1.516|
000082  7008              STRB     r0,[r1,#0]
                  |L1.132|
;;;57     			}
;;;58     			if ( g_GpioButtonEvent.ButtonEvent == CPI_M_CLICKED)
000084  485e              LDR      r0,|L1.512|
000086  8840              LDRH     r0,[r0,#2]  ; g_GpioButtonEvent
000088  2810              CMP      r0,#0x10
00008a  d104              BNE      |L1.150|
;;;59     			{
;;;60     				cpi_m_Cntr++;
00008c  485e              LDR      r0,|L1.520|
00008e  7800              LDRB     r0,[r0,#0]  ; cpi_m_Cntr
000090  1c40              ADDS     r0,r0,#1
000092  495d              LDR      r1,|L1.520|
000094  7008              STRB     r0,[r1,#0]
                  |L1.150|
;;;61     			}
;;;62     		}
;;;63     
;;;64     	}
;;;65     
;;;66     	if(LPC_CT16B0->IR & BIT1)
000096  4850              LDR      r0,|L1.472|
000098  6800              LDR      r0,[r0,#0]
00009a  2102              MOVS     r1,#2
00009c  4008              ANDS     r0,r0,r1
00009e  2800              CMP      r0,#0
0000a0  d007              BEQ      |L1.178|
;;;67     	{
;;;68     		LPC_CT16B0->IR = BIT1;/*Clear interrupt flag */
0000a2  2002              MOVS     r0,#2
0000a4  494c              LDR      r1,|L1.472|
0000a6  6008              STR      r0,[r1,#0]
;;;69     		g_Timer16_Setting.Timer16_0_Counter[1]++;	// Dennis: what is this for?	
0000a8  484c              LDR      r0,|L1.476|
0000aa  6840              LDR      r0,[r0,#4]  ; g_Timer16_Setting
0000ac  1c40              ADDS     r0,r0,#1
0000ae  494b              LDR      r1,|L1.476|
0000b0  6048              STR      r0,[r1,#4]  ; g_Timer16_Setting
                  |L1.178|
;;;70     	}
;;;71     }
0000b2  4770              BX       lr
;;;72     
                          ENDP

                  TIMER16_1_IRQHandler PROC
;;;81     ******************************************************************************/
;;;82     void TIMER16_1_IRQHandler(void)
0000b4  4855              LDR      r0,|L1.524|
;;;83     {
;;;84     	if(LPC_CT16B1->IR & BIT0)
0000b6  6800              LDR      r0,[r0,#0]
0000b8  07c0              LSLS     r0,r0,#31
0000ba  0fc0              LSRS     r0,r0,#31
0000bc  2800              CMP      r0,#0
0000be  d002              BEQ      |L1.198|
;;;85     	{  
;;;86     		LPC_CT16B1->IR = BIT0;/* clear interrupt flag */
0000c0  2001              MOVS     r0,#1
0000c2  4952              LDR      r1,|L1.524|
0000c4  6008              STR      r0,[r1,#0]
                  |L1.198|
;;;87     		//g_Timer16_Setting.Timer16_1_Counter[0]++;				
;;;88     	}
;;;89     
;;;90     	if(LPC_CT16B1->IR & BIT1)
0000c6  4851              LDR      r0,|L1.524|
0000c8  6800              LDR      r0,[r0,#0]
0000ca  2102              MOVS     r1,#2
0000cc  4008              ANDS     r0,r0,r1
0000ce  2800              CMP      r0,#0
0000d0  d002              BEQ      |L1.216|
;;;91     	{  
;;;92     		LPC_CT16B1->IR = BIT1;/* clear interrupt flag */
0000d2  2002              MOVS     r0,#2
0000d4  494d              LDR      r1,|L1.524|
0000d6  6008              STR      r0,[r1,#0]
                  |L1.216|
;;;93     		//g_Timer16_Setting.Timer16_1_Counter[1]++;		
;;;94     	}	
;;;95     }
0000d8  4770              BX       lr
;;;96     
                          ENDP

                  NDrv_Timer16_Enable PROC
;;;105    ******************************************************************************/
;;;106    void NDrv_Timer16_Enable(U8 timer_num)
0000da  2800              CMP      r0,#0
;;;107    {
;;;108    	if(timer_num == 0) 
0000dc  d103              BNE      |L1.230|
;;;109    	LPC_CT16B0->TCR = 1; 
0000de  2101              MOVS     r1,#1
0000e0  4a3d              LDR      r2,|L1.472|
0000e2  6051              STR      r1,[r2,#4]
0000e4  e002              B        |L1.236|
                  |L1.230|
;;;110    	else 
;;;111    	LPC_CT16B1->TCR = 1;  
0000e6  2101              MOVS     r1,#1
0000e8  4a48              LDR      r2,|L1.524|
0000ea  6051              STR      r1,[r2,#4]
                  |L1.236|
;;;112    }
0000ec  4770              BX       lr
;;;113    
                          ENDP

                  NDrv_Timer16_Reset PROC
;;;122    ******************************************************************************/
;;;123    void NDrv_Timer16_Reset(uint8_t timer_num)
0000ee  4601              MOV      r1,r0
;;;124    {
;;;125    	uint32_t regVal;
;;;126    
;;;127    	if(timer_num == 0)
0000f0  2900              CMP      r1,#0
0000f2  d106              BNE      |L1.258|
;;;128    	{
;;;129    		regVal = LPC_CT16B0->TCR;
0000f4  4a38              LDR      r2,|L1.472|
0000f6  6850              LDR      r0,[r2,#4]
;;;130    		regVal |= 0x02;
0000f8  2202              MOVS     r2,#2
0000fa  4310              ORRS     r0,r0,r2
;;;131    		LPC_CT16B0->TCR = regVal;
0000fc  4a36              LDR      r2,|L1.472|
0000fe  6050              STR      r0,[r2,#4]
000100  e005              B        |L1.270|
                  |L1.258|
;;;132    	}
;;;133    	else
;;;134    	{
;;;135    		regVal = LPC_CT16B1->TCR;
000102  4a42              LDR      r2,|L1.524|
000104  6850              LDR      r0,[r2,#4]
;;;136    		regVal |= 0x02;
000106  2202              MOVS     r2,#2
000108  4310              ORRS     r0,r0,r2
;;;137    		LPC_CT16B1->TCR = regVal;
00010a  4a40              LDR      r2,|L1.524|
00010c  6050              STR      r0,[r2,#4]
                  |L1.270|
;;;138    	}
;;;139    }
00010e  4770              BX       lr
;;;140    
                          ENDP

                  NDrv_Timer16_Disable PROC
;;;149    ******************************************************************************/
;;;150    void NDrv_Timer16_Disable(U8 timer_num)
000110  2800              CMP      r0,#0
;;;151    {
;;;152    	if(timer_num == 0) 
000112  d103              BNE      |L1.284|
;;;153    	LPC_CT16B0->TCR = 0; 
000114  2100              MOVS     r1,#0
000116  4a30              LDR      r2,|L1.472|
000118  6051              STR      r1,[r2,#4]
00011a  e002              B        |L1.290|
                  |L1.284|
;;;154    	else 
;;;155    	LPC_CT16B1->TCR = 0; 
00011c  2100              MOVS     r1,#0
00011e  4a3b              LDR      r2,|L1.524|
000120  6051              STR      r1,[r2,#4]
                  |L1.290|
;;;156    }
000122  4770              BX       lr
;;;157    /******************************************************************************
                          ENDP

                  nsAPI_Timer16_Init PROC
;;;166    ******************************************************************************/
;;;167    void nsAPI_Timer16_Init(U8 timer_num, U32 timer) 
000124  b570              PUSH     {r4-r6,lr}
;;;168    {
000126  4604              MOV      r4,r0
000128  460d              MOV      r5,r1
;;;169    	if(timer_num == Timer16_0)
00012a  2c00              CMP      r4,#0
00012c  d121              BNE      |L1.370|
;;;170    	{
;;;171    		NVIC_DisableIRQ(TIMER_16_0_IRQn);						// disable 16bit timer_0 interrupt
00012e  2010              MOVS     r0,#0x10
000130  f7fffffe          BL       NVIC_DisableIRQ
;;;172    		NDrv_Timer16_Reset(Timer16_0);							// reset 16bit timer_0 interrupt
000134  2000              MOVS     r0,#0
000136  f7fffffe          BL       NDrv_Timer16_Reset
;;;173    		LPC_SYSCON->SYSAHBCLKCTRL |= BIT7;					// enable clock for 16bit timer_0		
00013a  4835              LDR      r0,|L1.528|
00013c  6800              LDR      r0,[r0,#0]
00013e  2180              MOVS     r1,#0x80
000140  4308              ORRS     r0,r0,r1
000142  4933              LDR      r1,|L1.528|
000144  6008              STR      r0,[r1,#0]
;;;174    		LPC_CT16B0->PR = Timer16_MHz_Prescale;			// set prescale value
000146  4933              LDR      r1,|L1.532|
000148  4833              LDR      r0,|L1.536|
00014a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00014c  f7fffffe          BL       __aeabi_uidivmod
000150  4921              LDR      r1,|L1.472|
000152  60c8              STR      r0,[r1,#0xc]
;;;175    		LPC_CT16B0->MR0 = timer*Timer16_IntervalmS;	// set Timer Counter Match value
000154  207d              MOVS     r0,#0x7d
000156  00c0              LSLS     r0,r0,#3
000158  4368              MULS     r0,r5,r0
00015a  6188              STR      r0,[r1,#0x18]
;;;176    
;;;177    		/* Capture 0 and 1 on rising edge, interrupt enable. */
;;;178    		LPC_CT16B0->CCR = (BIT0|BIT2);
00015c  2005              MOVS     r0,#5
00015e  6288              STR      r0,[r1,#0x28]
;;;179    		LPC_CT16B0->MCR = (BIT0|BIT1);/*Interrupt and Reset on MR0 and MR1*/		
000160  2003              MOVS     r0,#3
000162  6148              STR      r0,[r1,#0x14]
;;;180    
;;;181    		/* Enable the TIMER0 Interrupt */
;;;182    		NVIC_EnableIRQ(TIMER_16_0_IRQn);
000164  2010              MOVS     r0,#0x10
000166  f7fffffe          BL       NVIC_EnableIRQ
;;;183    
;;;184    		NDrv_Timer16_Enable(Timer16_0); 			
00016a  2000              MOVS     r0,#0
00016c  f7fffffe          BL       NDrv_Timer16_Enable
000170  e021              B        |L1.438|
                  |L1.370|
;;;185    	}
;;;186    	else if(timer_num ==  Timer16_1)
000172  2c01              CMP      r4,#1
000174  d11f              BNE      |L1.438|
;;;187    	{
;;;188    		NVIC_DisableIRQ(TIMER_16_1_IRQn);
000176  2011              MOVS     r0,#0x11
000178  f7fffffe          BL       NVIC_DisableIRQ
;;;189    		NDrv_Timer16_Reset(Timer16_1);
00017c  2001              MOVS     r0,#1
00017e  f7fffffe          BL       NDrv_Timer16_Reset
;;;190    		/* Some of the I/O pins need to be clearfully planned if
;;;191    		you use below module because JTAG and TIMER CAP/MAT pins are muxed. */
;;;192    		LPC_SYSCON->SYSAHBCLKCTRL |= BIT8;
000182  4823              LDR      r0,|L1.528|
000184  6800              LDR      r0,[r0,#0]
000186  0221              LSLS     r1,r4,#8
000188  4308              ORRS     r0,r0,r1
00018a  4921              LDR      r1,|L1.528|
00018c  6008              STR      r0,[r1,#0]
;;;193    		LPC_CT16B1->PR = Timer16_MHz_Prescale;	  
00018e  4921              LDR      r1,|L1.532|
000190  4821              LDR      r0,|L1.536|
000192  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000194  f7fffffe          BL       __aeabi_uidivmod
000198  491c              LDR      r1,|L1.524|
00019a  60c8              STR      r0,[r1,#0xc]
;;;194    
;;;195    		LPC_CT16B1->MR0 = timer*Timer16_IntervalmS;
00019c  207d              MOVS     r0,#0x7d
00019e  00c0              LSLS     r0,r0,#3
0001a0  4368              MULS     r0,r5,r0
0001a2  6188              STR      r0,[r1,#0x18]
;;;196    		//LPC_CT16B1->MR1 = timer*Timer16_IntervalmS;	
;;;197    
;;;198    		/* Capture 0 and 1 on rising edge, interrupt enable. */
;;;199    		LPC_CT16B1->CCR = (BIT0|BIT2);
0001a4  2005              MOVS     r0,#5
0001a6  6288              STR      r0,[r1,#0x28]
;;;200    		LPC_CT16B1->MCR = (BIT0|BIT2);/* Interrupt and Reset on MR0 and MR1 */
0001a8  6148              STR      r0,[r1,#0x14]
;;;201    
;;;202    		/* Enable the TIMER1 Interrupt */
;;;203    		NVIC_EnableIRQ(TIMER_16_1_IRQn);
0001aa  2011              MOVS     r0,#0x11
0001ac  f7fffffe          BL       NVIC_EnableIRQ
;;;204    
;;;205    		NDrv_Timer16_Enable(Timer16_1);    
0001b0  2001              MOVS     r0,#1
0001b2  f7fffffe          BL       NDrv_Timer16_Enable
                  |L1.438|
;;;206    	}
;;;207    }
0001b6  bd70              POP      {r4-r6,pc}
;;;208    
                          ENDP

                  NVIC_EnableIRQ PROC
;;;535     */
;;;536    static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
0001b8  06c2              LSLS     r2,r0,#27
;;;537    {
;;;538      NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
0001ba  0ed2              LSRS     r2,r2,#27
0001bc  2101              MOVS     r1,#1
0001be  4091              LSLS     r1,r1,r2
0001c0  4a16              LDR      r2,|L1.540|
0001c2  6011              STR      r1,[r2,#0]
;;;539    }
0001c4  4770              BX       lr
;;;540    
                          ENDP

                  NVIC_DisableIRQ PROC
;;;548     */
;;;549    static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
0001c6  06c2              LSLS     r2,r0,#27
;;;550    {
;;;551      NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
0001c8  0ed2              LSRS     r2,r2,#27
0001ca  2101              MOVS     r1,#1
0001cc  4091              LSLS     r1,r1,r2
0001ce  4a13              LDR      r2,|L1.540|
0001d0  3280              ADDS     r2,r2,#0x80
0001d2  6011              STR      r1,[r2,#0]
;;;552    }
0001d4  4770              BX       lr
;;;553    
                          ENDP

0001d6  0000              DCW      0x0000
                  |L1.472|
                          DCD      0x4000c000
                  |L1.476|
                          DCD      g_Timer16_Setting
                  |L1.480|
                          DCD      poll_tick_btn
                  |L1.484|
                          DCD      poll_usb
                  |L1.488|
                          DCD      poll_id
                  |L1.492|
                          DCD      poll_z_wheel
                  |L1.496|
                          DCD      poll_motion
                  |L1.500|
                          DCD      poll_counter
                  |L1.504|
                          DCD      glitch_prevention
                  |L1.508|
                          DCD      cpi_clicked_flag
                  |L1.512|
                          DCD      g_GpioButtonEvent
                  |L1.516|
                          DCD      cpi_p_Cntr
                  |L1.520|
                          DCD      cpi_m_Cntr
                  |L1.524|
                          DCD      0x40010000
                  |L1.528|
                          DCD      0x40048080
                  |L1.532|
                          DCD      0x000f4240
                  |L1.536|
                          DCD      SystemCoreClock
                  |L1.540|
                          DCD      0xe000e100

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_Timer16_Setting
                          %        16

                          AREA ||.data||, DATA, ALIGN=1

                  poll_tick_btn
000000  0000              DCB      0x00,0x00
                  poll_usb
000002  0000              DCB      0x00,0x00
                  poll_id
000004  0000              DCB      0x00,0x00
                  poll_z_wheel
000006  0000              DCB      0x00,0x00
                  glitch_prevention
000008  0000              DCB      0x00,0x00
                  cpi_clicked_flag
00000a  0000              DCB      0x00,0x00
                  poll_motion
00000c  0000              DCB      0x00,0x00
                  poll_counter
00000e  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "Src\\timer16.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_timer16_c_39661c92____REV16|
#line 112 ".\\Inc\\core_cmInstr.h"
|__asm___9_timer16_c_39661c92____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_timer16_c_39661c92____REVSH|
#line 130
|__asm___9_timer16_c_39661c92____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
